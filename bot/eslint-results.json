[{"filePath":"/workspace/bot/src/application/chart/ChartRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1201,1204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1201,1204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartData, ChartOptions } from './ChartService';\nimport { logger } from '../../lib/logger';\nimport { flags } from '../../utils/feature-flags';\nimport { IChartRenderStrategy } from './strategies/IChartRenderStrategy';\nimport { BasicChartRenderStrategy } from './strategies/BasicChartRenderStrategy';\nimport { AdvancedChartRenderStrategy } from './strategies/AdvancedChartRenderStrategy';\n\n/**\n * Handles the rendering of charts to various formats using strategy pattern\n */\nexport class ChartRenderer {\n  private static strategy: IChartRenderStrategy;\n\n  /**\n   * Get the appropriate rendering strategy based on feature flags\n   */\n  private static getStrategy(): IChartRenderStrategy {\n    if (!this.strategy) {\n      if (flags.newChartRendering) {\n        logger.info('Using advanced chart rendering strategy');\n        this.strategy = new AdvancedChartRenderStrategy();\n      } else {\n        logger.info('Using basic chart rendering strategy');\n        this.strategy = new BasicChartRenderStrategy();\n      }\n    }\n    return this.strategy;\n  }\n\n  /**\n   * Reset the strategy (useful for testing or configuration changes)\n   */\n  static resetStrategy(): void {\n    this.strategy = null as any;\n  }\n\n  /**\n   * Render a chart as a PNG image buffer\n   * @param chartData Data to render\n   * @param options Rendering options\n   * @returns Buffer containing the PNG image\n   */\n  static async renderPNG(chartData: ChartData, options?: Partial<ChartOptions>): Promise<Buffer | null> {\n    try {\n      const strategy = this.getStrategy();\n      return await strategy.renderPNG(chartData, options);\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        'Failed to render chart as PNG'\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Create a simple HTML representation of chart data\n   * @param chartData Data to render\n   * @param options Rendering options\n   * @returns HTML string\n   */\n  static async renderHTML(chartData: ChartData, options: Partial<ChartOptions> = {}): Promise<string> {\n    try {\n      const strategy = this.getStrategy();\n      return await strategy.renderHTML(chartData, options);\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        'Failed to render chart as HTML'\n      );\n      return `<html><body><h1>Error rendering chart</h1><p>${error}</p></body></html>`;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/application/chart/ChartService.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateShipUsageChart' has too many lines (89). Maximum allowed is 50.","line":80,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":198,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateShipUsageChart' has a complexity of 13. Maximum allowed is 10.","line":80,"column":31,"nodeType":"FunctionExpression","messageId":"complex","endLine":198,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3759,3762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3759,3762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":1,"message":"Async method 'renderChart' has a complexity of 11. Maximum allowed is 10.","line":206,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":250,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from '../../lib/logger';\nimport { flags } from '../../utils/feature-flags';\nimport { RepositoryManager } from '../../infrastructure/repositories/RepositoryManager';\nimport { CacheAdapter } from '../../cache/CacheAdapter';\nimport { CacheRedisAdapter } from '../../cache/CacheRedisAdapter';\nimport { Configuration } from '../../config';\n\n/**\n * Chart rendering options\n */\nexport interface ChartOptions {\n  /** Width of the chart in pixels */\n  width: number;\n  /** Height of the chart in pixels */\n  height: number;\n  /** Optional title for the chart */\n  title?: string;\n  /** Whether to include a legend */\n  showLegend: boolean;\n  /** Whether to add labels with values to the chart */\n  showLabels: boolean;\n  /** Whether to use light mode, otherwise dark mode */\n  lightMode: boolean;\n}\n\n/**\n * Chart data format\n */\nexport interface ChartData {\n  /** Labels for the data points */\n  labels: string[];\n  /** Datasets to be rendered */\n  datasets: Array<{\n    /** Name of the dataset */\n    label: string;\n    /** Data values */\n    data: number[];\n    /** Background colors (can be a single color or an array) */\n    backgroundColor: string | string[];\n    /** Border colors (can be a single color or an array) */\n    borderColor?: string | string[];\n  }>;\n}\n\n/**\n * Ship data entry format\n */\ninterface ShipDataEntry {\n  shipName: string;\n  count: number;\n}\n\n/**\n * Main service for chart generation and rendering\n */\nexport class ChartService {\n  private repositoryManager: RepositoryManager;\n  private cache: CacheAdapter;\n\n  /**\n   * Create a new ChartService\n   */\n  constructor(cache?: CacheAdapter) {\n    this.repositoryManager = new RepositoryManager();\n    this.cache =\n      cache ??\n      new CacheRedisAdapter(\n        process.env.REDIS_URL ?? 'redis://localhost:6379',\n        Configuration.charts.defaultCacheTTLSeconds\n      );\n  }\n\n  /**\n   * Generate ship usage statistics for a character or group\n   * @param characterId Character ID or null if using a group\n   * @param groupId Group ID or null if using a character\n   * @param days Number of days to include in the chart\n   * @returns Chart data or null if no data available\n   */\n  async generateShipUsageChart(characterId?: string, groupId?: string, days: number = 30): Promise<ChartData | null> {\n    try {\n      if (!characterId && !groupId) {\n        logger.error('Either characterId or groupId must be provided');\n        return null;\n      }\n\n      logger.info(\n        `Generating ship usage chart for ${\n          characterId ? `character ${characterId}` : `group ${groupId}`\n        } over ${days} days`\n      );\n\n      // Calculate date range\n      const endDate = new Date();\n      const startDate = new Date(endDate);\n      startDate.setDate(startDate.getDate() - days);\n\n      // Use feature flag to conditionally use real database queries or mock data\n      let shipData: ShipDataEntry[];\n\n      if (flags.newChartRendering) {\n        // Implement actual data retrieval when feature flag is enabled\n        logger.info('Using database query for ship usage (feature flag enabled)');\n\n        try {\n          // Get repositories\n          const killRepository = this.repositoryManager.getKillRepository();\n\n          let characterIds: string[] = [];\n\n          if (characterId) {\n            // Single character\n            characterIds = [characterId];\n          } else if (groupId) {\n            // Get characters from the group\n            const characterRepository = this.repositoryManager.getCharacterRepository();\n            const groups = await characterRepository.getAllCharacterGroups();\n            const group = groups.find(g => g.id === groupId);\n\n            if (group?.characters) {\n              characterIds = group.characters.map((char: any) => char.eveId);\n            }\n          }\n\n          // Get top ship types used for kills\n          const topShips = await killRepository.getTopShipTypesUsed(\n            characterIds.map(id => BigInt(id)),\n            startDate,\n            endDate,\n            Configuration.charts.defaultTopLimit // Limit to top ships\n          );\n\n          shipData = topShips.map(ship => ({\n            shipName: ship.shipTypeId, // In a real implementation, this would be mapped to ship names from ESI\n            count: ship.count,\n          }));\n\n          logger.info(`Found ${shipData.length} ship types for chart`);\n        } catch (error) {\n          logger.error('Error in ship data retrieval, falling back to mock data', error);\n          // Fall back to mock data\n          shipData = [\n            { shipName: 'Rifter (Mock)', count: 15 },\n            { shipName: 'Punisher (Mock)', count: 8 },\n            { shipName: 'Merlin (Mock)', count: 12 },\n            { shipName: 'Incursus (Mock)', count: 5 },\n          ];\n        }\n      } else {\n        // Use mock data when feature flag is disabled\n        logger.info('Using mock data for ship usage (feature flag disabled)');\n        shipData = [\n          { shipName: 'Rifter', count: 15 },\n          { shipName: 'Punisher', count: 8 },\n          { shipName: 'Merlin', count: 12 },\n          { shipName: 'Incursus', count: 5 },\n        ];\n      }\n\n      // Create chart data\n      const chartData: ChartData = {\n        labels: shipData.map(s => s.shipName),\n        datasets: [\n          {\n            label: 'Ship Usage',\n            data: shipData.map(s => s.count),\n            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'],\n          },\n        ],\n      };\n\n      // Generate cache key\n      const cacheKey = `ship-usage-${characterId}-${days}`;\n\n      // Check cache\n      const cachedData = await this.cache.get<ChartData>(cacheKey);\n      if (cachedData) {\n        logger.info(`Retrieved ship usage chart from cache for key: ${cacheKey}`);\n        return cachedData;\n      }\n\n      // Store in cache\n      // Cache for configured duration\n      await this.cache.set(cacheKey, chartData, Configuration.charts.defaultCacheTTLSeconds);\n      logger.info(`Stored ship usage chart in cache for key: ${cacheKey}`);\n\n      return chartData;\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        'Failed to generate ship usage chart'\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Render a chart as a PNG buffer\n   * @param chartData The data to render\n   * @param options Rendering options\n   * @returns Buffer containing the PNG image or null if rendering failed\n   */\n  async renderChart(_chartData: ChartData, options: Partial<ChartOptions> = {}): Promise<Buffer | null> {\n    try {\n      // Set default options\n      const chartOptions: ChartOptions = {\n        width: options.width ?? Configuration.charts.defaultWidth,\n        height: options.height ?? Configuration.charts.defaultHeight,\n        title: options.title,\n        showLegend: options.showLegend ?? true,\n        showLabels: options.showLabels ?? true,\n        lightMode: options.lightMode ?? false,\n      };\n\n      logger.info(`Rendering chart with dimensions ${chartOptions.width}x${chartOptions.height}`);\n\n      // Use feature flag to conditionally enable real chart rendering\n      if (flags.newChartRendering) {\n        logger.info('Using real chart rendering (feature flag enabled)');\n        try {\n          // This would be the actual implementation\n          // const { ChartRenderer } = await import('../ChartRenderer');\n          // return ChartRenderer.renderPNG(chartData, chartOptions);\n\n          // Placeholder for now\n          return Buffer.from('Real chart rendering output');\n        } catch (error) {\n          logger.error('Error in chart rendering, falling back to mock', error);\n          // Fall back to mock buffer\n        }\n      }\n\n      // Use mock buffer when feature flag is disabled\n      logger.info('Using mock chart rendering (feature flag disabled)');\n      const mockBuffer = Buffer.from('Mock chart rendering output');\n      return mockBuffer;\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        'Failed to render chart'\n      );\n      return null;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/application/chart/strategies/AdvancedChartRenderStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/application/chart/strategies/BaseChartRenderStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/application/chart/strategies/BasicChartRenderStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/application/chart/strategies/IChartRenderStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/cache/CacheAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/cache/CacheRedisAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/config.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":7,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":7,"endColumn":18},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":7,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":7,"endColumn":23},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":7,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":7,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 15.","line":17,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":17,"endColumn":19},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":17,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":17,"endColumn":24},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":17,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":17,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 300.","line":25,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":62},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30000.","line":34,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":34,"endColumn":70},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":35,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":35,"endColumn":74},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":36,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":36,"endColumn":93},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 45000.","line":37,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":37,"endColumn":86},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":40,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":85},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10000.","line":41,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":41,"endColumn":86},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":47,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":47,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":65,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":64},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5000.","line":66,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":66,"endColumn":67}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Configuration options for the application\n\nexport const config = {\n  // Cache settings\n  cache: {\n    // Default TTL for cache entries in milliseconds\n    defaultTTL: 5 * 60 * 1000, // 5 minutes\n\n    // Whether to enable caching\n    enabled: true,\n  },\n\n  // API settings\n  api: {\n    // Rate limiting\n    rateLimit: {\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 100, // limit each IP to 100 requests per windowMs\n    },\n  },\n};\n\n// Environment-based configuration\nexport const REDIS_URL = process.env.REDIS_URL ?? 'redis://localhost:6379';\nexport const CACHE_TTL = Number(process.env.CACHE_TTL) ?? 300; // seconds\n// Legacy URLs (to be removed)\nexport const ESI_BASE_URL = process.env.ESI_BASE_URL ?? 'https://esi.evetech.net/latest';\nexport const ZKILLBOARD_BASE_URL = process.env.ZKILLBOARD_BASE_URL ?? 'https://zkillboard.com/api';\n\n// Database configuration\nexport const DATABASE_URL = process.env.DATABASE_URL;\n\n// HTTP Client configuration\nexport const HTTP_TIMEOUT = Number(process.env.HTTP_TIMEOUT) ?? 30000; // 30 seconds\nexport const HTTP_MAX_RETRIES = Number(process.env.HTTP_MAX_RETRIES) ?? 3;\nexport const HTTP_INITIAL_RETRY_DELAY = Number(process.env.HTTP_INITIAL_RETRY_DELAY) ?? 1000; // 1 second\nexport const HTTP_MAX_RETRY_DELAY = Number(process.env.HTTP_MAX_RETRY_DELAY) ?? 45000; // 45 seconds\n\n// Rate limiting configuration\nexport const RATE_LIMIT_MIN_DELAY = Number(process.env.RATE_LIMIT_MIN_DELAY) ?? 1000; // 1 second\nexport const RATE_LIMIT_MAX_DELAY = Number(process.env.RATE_LIMIT_MAX_DELAY) ?? 10000; // 10 seconds\n\n// Feature flags\nexport const NEW_CHART_RENDERING = process.env.NEW_CHART_RENDERING === 'true';\n\n// Server configuration\nexport const PORT = Number(process.env.PORT) ?? 3000;\nexport const NODE_ENV = process.env.NODE_ENV ?? 'development';\n\n// Logging configuration\nexport const LOG_LEVEL = process.env.LOG_LEVEL ?? 'info';\n\n// Discord Bot Configuration\nexport const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;\n\n// Map API Configuration\nexport const MAP_API_URL = process.env.MAP_API_URL ?? 'https://api.eve-map.net';\nexport const MAP_API_KEY = process.env.MAP_API_KEY ?? '';\nexport const MAP_NAME = process.env.MAP_NAME;\n\n// WebSocket Configuration\nexport const WANDERER_KILLS_URL = process.env.WANDERER_KILLS_URL ?? 'ws://localhost:4004';\n\n// Retry Configuration\nexport const MAX_RETRIES = Number(process.env.MAX_RETRIES) ?? 3;\nexport const RETRY_DELAY = Number(process.env.RETRY_DELAY) ?? 5000; // 5 seconds\n\n// Sentry Configuration\nexport const SENTRY_DSN = process.env.SENTRY_DSN;\n\n// Feature Flags - Centralized boolean conversion\nconst getBooleanFlag = (envVar: string | undefined, defaultValue: boolean): boolean => {\n  if (envVar === undefined) return defaultValue;\n  return envVar.toLowerCase() === 'true';\n};\n\nexport const FEATURE_FLAGS = {\n  newChartRendering: getBooleanFlag(process.env.FEATURE_NEW_CHART_RENDERING, false),\n  redisCache: getBooleanFlag(process.env.FEATURE_REDIS_CACHE, true),\n  newIngestionService: getBooleanFlag(process.env.FEATURE_NEW_INGESTION_SERVICE, false),\n  awoxDetection: getBooleanFlag(process.env.FEATURE_AWOX_DETECTION, false),\n};\n\n// Type-safe configuration object\nexport const Configuration = {\n  server: {\n    port: PORT,\n    nodeEnv: NODE_ENV,\n  },\n  database: {\n    url: DATABASE_URL,\n  },\n  redis: {\n    url: REDIS_URL,\n    cacheTtl: CACHE_TTL,\n  },\n  apis: {\n    wandererKills: {\n      url: WANDERER_KILLS_URL,\n    },\n    map: {\n      url: MAP_API_URL,\n      key: MAP_API_KEY,\n      name: MAP_NAME,\n    },\n    // Legacy APIs (to be removed)\n    esi: {\n      baseUrl: ESI_BASE_URL,\n    },\n    zkillboard: {\n      baseUrl: ZKILLBOARD_BASE_URL,\n    },\n  },\n  http: {\n    timeout: HTTP_TIMEOUT,\n    maxRetries: HTTP_MAX_RETRIES,\n    initialRetryDelay: HTTP_INITIAL_RETRY_DELAY,\n    maxRetryDelay: HTTP_MAX_RETRY_DELAY,\n  },\n  rateLimit: {\n    minDelay: RATE_LIMIT_MIN_DELAY,\n    maxDelay: RATE_LIMIT_MAX_DELAY,\n  },\n  features: FEATURE_FLAGS,\n  logging: {\n    level: LOG_LEVEL,\n  },\n  discord: {\n    token: DISCORD_BOT_TOKEN,\n  },\n  websocket: {\n    url: WANDERER_KILLS_URL,\n    reconnectIntervalMs: 5000,\n    maxReconnectAttempts: 10,\n    timeout: 10000,\n    preload: {\n      enabled: true,\n      limitPerSystem: 100,\n      sinceHours: 168, // 7 days\n      deliveryBatchSize: 10,\n      deliveryIntervalMs: 1000,\n    },\n  },\n  sentry: {\n    dsn: SENTRY_DSN,\n  },\n  charts: {\n    defaultWidth: 800,\n    defaultHeight: 600,\n    defaultCacheTTLSeconds: 3600, // 1 hour\n    defaultTopLimit: 10,\n  },\n  bigIntConstants: {\n    zero: 0n,\n  },\n  jitter: {\n    maxMs: 1000,\n  },\n} as const;\n\n// Type definitions for configuration\nexport type ConfigurationType = typeof Configuration;\nexport type ServerConfig = ConfigurationType['server'];\nexport type DatabaseConfig = ConfigurationType['database'];\nexport type RedisConfig = ConfigurationType['redis'];\nexport type ApiConfig = ConfigurationType['apis'];\nexport type HttpConfig = ConfigurationType['http'];\nexport type RateLimitConfig = ConfigurationType['rateLimit'];\nexport type FeatureFlags = ConfigurationType['features'];\nexport type LoggingConfig = ConfigurationType['logging'];\nexport type DiscordConfig = ConfigurationType['discord'];\nexport type SentryConfig = ConfigurationType['sentry'];\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/BaseEntity.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[992,995],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[992,995],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1032,1035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1032,1035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2293,2296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2293,2296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base entity class providing common functionality for domain entities\n */\nexport abstract class BaseEntity {\n  /** Labels or tags applied to this entity */\n  protected labels: string[] = [];\n\n  /**\n   * Add a label to this entity\n   */\n  addLabel(label: string): void {\n    if (!this.labels.includes(label)) {\n      this.labels.push(label);\n    }\n  }\n\n  /**\n   * Remove a label from this entity\n   */\n  removeLabel(label: string): void {\n    const index = this.labels.indexOf(label);\n    if (index >= 0) {\n      this.labels.splice(index, 1);\n    }\n  }\n\n  /**\n   * Check if this entity has a specific label\n   */\n  hasLabel(label: string): boolean {\n    return this.labels.includes(label);\n  }\n\n  /**\n   * Get all labels for this entity\n   */\n  getLabels(): string[] {\n    return [...this.labels];\n  }\n\n  /**\n   * Default toJSON implementation that serializes all public and protected fields\n   * Can be overridden by subclasses for custom serialization\n   */\n  toJSON(): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    // Get all enumerable properties\n    for (const key in this) {\n      if (Object.prototype.hasOwnProperty.call(this, key)) {\n        const value = this[key];\n\n        // Handle BigInt conversion to string\n        if (typeof value === 'bigint') {\n          result[key] = value.toString();\n        }\n        // Handle Date conversion to ISO string\n        else if (value instanceof Date) {\n          result[key] = value.toISOString();\n        }\n        // Handle arrays and nested objects\n        else if (Array.isArray(value)) {\n          result[key] = value.map(item =>\n            typeof item === 'object' && item !== null && 'toJSON' in item ? item.toJSON() : item\n          );\n        }\n        // Handle nested objects with toJSON method\n        else if (\n          typeof value === 'object' &&\n          value !== null &&\n          'toJSON' in value &&\n          typeof value.toJSON === 'function'\n        ) {\n          result[key] = value.toJSON();\n        }\n        // Handle all other values\n        else {\n          result[key] = value;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Default toObject implementation that calls toJSON\n   * Provides backward compatibility for existing code\n   */\n  toObject(): Record<string, any> {\n    return this.toJSON();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/activity/MapActivity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/activity/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/character/Character.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1967,1970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1967,1970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Exclude, Expose, Transform } from 'class-transformer';\n\n/**\n * Character domain entity\n * Represents a character in EVE Online\n */\n@Exclude()\nexport class Character {\n  @Expose()\n  @Transform(({ value }: { value: unknown }) => value?.toString())\n  readonly eveId!: string;\n\n  @Expose()\n  readonly name!: string;\n\n  @Expose()\n  readonly allianceId?: number;\n\n  @Expose()\n  readonly allianceTicker?: string;\n\n  @Expose()\n  readonly corporationId!: number;\n\n  @Expose()\n  readonly corporationTicker!: string;\n\n  @Expose()\n  readonly characterGroupId?: string;\n\n  @Expose()\n  readonly mainCharacterId?: string;\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly createdAt!: Date;\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly updatedAt!: Date;\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly lastBackfillAt?: Date;\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly lastKillmailAt?: Date;\n\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value;\n    return new Date(value);\n  })\n  get lastUpdatedDate(): Date {\n    return this.updatedAt;\n  }\n\n  get isMain(): boolean {\n    return this.mainCharacterId === this.eveId;\n  }\n\n  constructor(data: Partial<Character>) {\n    Object.assign(this, data);\n  }\n\n  /**\n   * Converts the character to a plain object\n   */\n  toJSON(): Record<string, any> {\n    return {\n      eveId: this.eveId,\n      name: this.name,\n      allianceId: this.allianceId,\n      allianceTicker: this.allianceTicker,\n      corporationId: this.corporationId,\n      corporationTicker: this.corporationTicker,\n      characterGroupId: this.characterGroupId,\n      mainCharacterId: this.mainCharacterId,\n      createdAt: this.createdAt,\n      updatedAt: this.updatedAt,\n      lastBackfillAt: this.lastBackfillAt,\n      lastKillmailAt: this.lastKillmailAt,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/character/CharacterGroup.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1195,1198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1195,1198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Exclude, Expose, Transform } from 'class-transformer';\nimport { Character } from './Character';\n\n/**\n * CharacterGroup domain entity\n * Represents a group of characters in EVE Online\n */\n@Exclude()\nexport class CharacterGroup {\n  @Expose()\n  readonly id!: string;\n\n  @Expose()\n  readonly map_name!: string;\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly mainCharacterId?: string;\n\n  @Expose()\n  readonly characters: Character[] = [];\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly createdAt!: Date;\n\n  @Expose()\n  @Transform(({ value }: { value: Date | string | null }) => {\n    if (!value) return null;\n    if (value instanceof Date) return value.toISOString();\n    return value;\n  })\n  readonly updatedAt!: Date;\n\n  // Computed property for name - use map_name as the display name\n  get name(): string {\n    return this.map_name;\n  }\n\n  constructor(data: Partial<CharacterGroup>) {\n    Object.assign(this, data);\n  }\n\n  /**\n   * Converts the character group to a plain object\n   */\n  toJSON(): Record<string, any> {\n    return {\n      id: this.id,\n      name: this.name,\n      map_name: this.map_name,\n      mainCharacterId: this.mainCharacterId,\n      characters: this.characters.map(char => char.toJSON()),\n      createdAt: this.createdAt,\n      updatedAt: this.updatedAt,\n    };\n  }\n\n  /**\n   * Gets the main character of the group\n   */\n  getMainCharacter(): Character | undefined {\n    return this.characters?.find(c => c.eveId === this.mainCharacterId);\n  }\n\n  /**\n   * Gets all alt characters in the group\n   */\n  getAltCharacters(): Character[] {\n    return this.characters?.filter(c => c.eveId !== this.mainCharacterId) || [];\n  }\n\n  /**\n   * Checks if a character is the main character of the group\n   */\n  isMainCharacter(characterId: string): boolean {\n    return this.mainCharacterId === characterId;\n  }\n\n  /**\n   * Checks if a character is an alt in the group\n   */\n  isAltCharacter(characterId: string): boolean {\n    return (this.mainCharacterId !== characterId && this.characters?.some(c => c.eveId === characterId)) || false;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/character/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/killmail/KillFact.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":184,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":184,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4798,4801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4798,4801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4815,4818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4815,4818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4831,4834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4831,4834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7864,7867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7864,7867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9873,9876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9873,9876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseEntity } from '../BaseEntity';\nimport { ensureRequiredBigInt, ensureBigInt } from '../../utils/conversion';\nimport { validateRequired, validatePositive, validateNonNegative } from '../../utils/validation';\n\n/**\n * KillFact domain entity\n * Represents a character's kill in EVE Online\n */\nexport class KillFact extends BaseEntity {\n  /** Killmail ID from EVE Online */\n  readonly killmailId: bigint;\n\n  /** Character EVE ID */\n  readonly characterId: bigint;\n\n  /** Timestamp of the kill */\n  readonly killTime: Date;\n\n  /** Whether the kill was on an NPC */\n  npc: boolean;\n\n  /** Whether the kill was solo (no other players on killmail) */\n  solo: boolean;\n\n  /** Whether the kill was on a player in the same alliance/corp (awox) */\n  awox: boolean;\n\n  /** Ship type ID of the ship the character was flying */\n  shipTypeId: number;\n\n  /** Solar system ID where the kill occurred */\n  systemId: number;\n\n  // Labels are inherited from BaseEntity\n\n  /** Total ISK value of the kill */\n  totalValue: bigint;\n\n  /** Points awarded for the kill */\n  points: number;\n\n  /** Attackers participating in the kill (populated on demand) */\n  private _attackers: KillAttacker[] | null = null;\n\n  /** Victim information (populated on demand) */\n  private _victim: KillVictim | null = null;\n\n  /**\n   * Create a new KillFact instance\n   */\n  constructor(props: {\n    killmailId: bigint | string;\n    characterId: bigint | string;\n    killTime: Date;\n    npc: boolean;\n    solo: boolean;\n    awox: boolean;\n    shipTypeId: number;\n    systemId: number;\n    labels?: string[];\n    totalValue: bigint | string;\n    points: number;\n    attackers?: KillAttacker[];\n    victim?: KillVictim;\n  }) {\n    super();\n\n    // Convert string IDs to bigint using utility\n    this.killmailId = ensureRequiredBigInt(props.killmailId);\n    this.characterId = ensureRequiredBigInt(props.characterId);\n\n    this.killTime = props.killTime;\n    this.npc = props.npc;\n    this.solo = props.solo;\n    this.awox = props.awox;\n    this.shipTypeId = props.shipTypeId;\n    this.systemId = props.systemId;\n    // Set labels using the inherited property from BaseEntity\n    this.labels = props.labels ?? [];\n    this.totalValue = ensureRequiredBigInt(props.totalValue);\n    this.points = props.points;\n\n    if (props.attackers) {\n      this._attackers = props.attackers;\n    }\n\n    if (props.victim) {\n      this._victim = props.victim;\n    }\n\n    this.validate();\n  }\n\n  /**\n   * Validate the kill fact data using shared validation utilities\n   * @throws Error if data is invalid\n   */\n  private validate(): void {\n    validateRequired('killmailId', this.killmailId);\n    validateRequired('characterId', this.characterId);\n    validateRequired('killTime', this.killTime);\n    validatePositive('shipTypeId', this.shipTypeId);\n    validatePositive('systemId', this.systemId);\n    validateNonNegative('points', this.points);\n  }\n\n  /**\n   * Get the attackers for this kill\n   */\n  get attackers(): KillAttacker[] {\n    if (!this._attackers) {\n      throw new Error('Attackers not loaded for this kill');\n    }\n    return this._attackers;\n  }\n\n  /**\n   * Set the attackers for this kill\n   */\n  set attackers(attackers: KillAttacker[]) {\n    this._attackers = attackers;\n  }\n\n  /**\n   * Get the victim for this kill\n   */\n  get victim(): KillVictim {\n    if (!this._victim) {\n      throw new Error('Victim not loaded for this kill');\n    }\n    return this._victim;\n  }\n\n  /**\n   * Set the victim for this kill\n   */\n  set victim(victim: KillVictim) {\n    this._victim = victim;\n  }\n\n  /**\n   * Check if attackers are loaded for this kill\n   */\n  get hasAttackers(): boolean {\n    return this._attackers !== null;\n  }\n\n  /**\n   * Check if victim is loaded for this kill\n   */\n  get hasVictim(): boolean {\n    return this._victim !== null;\n  }\n\n  /**\n   * Get the number of attackers on the killmail\n   * @throws Error if attackers are not loaded\n   */\n  get attackerCount(): number {\n    if (!this._attackers) {\n      throw new Error('Attackers not loaded for this kill');\n    }\n    return this._attackers.length;\n  }\n\n  /**\n   * Get the actual solo status (if attackers are loaded)\n   * This may be different from the solo field which could be set during import\n   */\n  get actualSolo(): boolean {\n    // If attackers aren't loaded, we can't determine the real solo status\n    if (!this._attackers) {\n      return this.solo;\n    }\n\n    // Solo means only one attacker (the character)\n    return this._attackers.length === 1 && this._attackers[0].characterId === this.characterId;\n  }\n\n  /**\n   * Get the ISK value in millions (more readable)\n   */\n  get iskValueMillions(): number {\n    return Number(this.totalValue) / 1000000;\n  }\n\n  /**\n   * Create a KillFact domain entity from a database model\n   */\n  static fromModel(model: any, attackers?: any[], victim?: any): KillFact {\n    const killFact = new KillFact({\n      killmailId: model.killmail_id,\n      characterId: model.character_id,\n      killTime: model.kill_time,\n      npc: model.npc,\n      solo: model.solo,\n      awox: model.awox,\n      shipTypeId: model.ship_type_id,\n      systemId: model.system_id,\n      labels: model.labels ?? [],\n      totalValue: model.total_value,\n      points: model.points,\n    });\n\n    if (attackers) {\n      killFact.attackers = attackers.map(a => KillAttacker.fromModel(a));\n    }\n\n    if (victim) {\n      killFact.victim = KillVictim.fromModel(victim);\n    }\n\n    return killFact;\n  }\n}\n\n/**\n * KillAttacker domain entity\n * Represents an attacker on a killmail\n */\nexport class KillAttacker {\n  /** Unique ID in the database */\n  readonly id?: number;\n\n  /** Killmail ID this attacker is associated with */\n  readonly killmailId: bigint;\n\n  /** Character ID (optional - could be NPC) */\n  readonly characterId: bigint | null;\n\n  /** Corporation ID */\n  readonly corporationId: bigint | null;\n\n  /** Alliance ID (optional) */\n  readonly allianceId: bigint | null;\n\n  /** Damage done by this attacker */\n  readonly damageDone: number;\n\n  /** Whether this attacker got the final blow */\n  readonly finalBlow: boolean;\n\n  /** Security status of the attacker */\n  readonly securityStatus: number | null;\n\n  /** Ship type ID */\n  readonly shipTypeId: number | null;\n\n  /** Weapon type ID */\n  readonly weaponTypeId: number | null;\n\n  constructor(props: {\n    id?: number;\n    killmailId: bigint | string;\n    characterId?: bigint | string | null;\n    corporationId?: bigint | string | null;\n    allianceId?: bigint | string | null;\n    damageDone: number;\n    finalBlow: boolean;\n    securityStatus?: number | null;\n    shipTypeId?: number | null;\n    weaponTypeId?: number | null;\n  }) {\n    this.id = props.id;\n\n    // Convert string IDs to bigint using utility\n    this.killmailId = ensureRequiredBigInt(props.killmailId);\n    this.characterId = ensureBigInt(props.characterId);\n    this.corporationId = ensureBigInt(props.corporationId);\n    this.allianceId = ensureBigInt(props.allianceId);\n\n    this.damageDone = props.damageDone;\n    this.finalBlow = props.finalBlow;\n    this.securityStatus = props.securityStatus ?? null;\n    this.shipTypeId = props.shipTypeId ?? null;\n    this.weaponTypeId = props.weaponTypeId ?? null;\n  }\n\n  /**\n   * Check if this attacker is an NPC\n   */\n  get isNpc(): boolean {\n    return this.characterId === null;\n  }\n\n  /**\n   * Convert to a plain object for persistence\n   */\n  toObject() {\n    return {\n      id: this.id,\n      killmailId: this.killmailId,\n      characterId: this.characterId,\n      corporationId: this.corporationId,\n      allianceId: this.allianceId,\n      damageDone: this.damageDone,\n      finalBlow: this.finalBlow,\n      securityStatus: this.securityStatus,\n      shipTypeId: this.shipTypeId,\n      weaponTypeId: this.weaponTypeId,\n    };\n  }\n\n  /**\n   * Create a KillAttacker domain entity from a database model\n   */\n  static fromModel(model: any): KillAttacker {\n    return new KillAttacker({\n      id: model.id,\n      killmailId: model.killmail_id,\n      characterId: model.character_id,\n      corporationId: model.corporation_id,\n      allianceId: model.alliance_id,\n      damageDone: model.damage_done,\n      finalBlow: model.final_blow,\n      securityStatus: model.security_status,\n      shipTypeId: model.ship_type_id,\n      weaponTypeId: model.weapon_type_id,\n    });\n  }\n}\n\n/**\n * KillVictim domain entity\n * Represents the victim on a killmail\n */\nexport class KillVictim {\n  /** Unique ID in the database */\n  readonly id: number;\n  /** Killmail ID */\n  readonly killmailId: bigint;\n  /** Character ID if victim was a player */\n  readonly characterId?: bigint;\n  /** Corporation ID */\n  readonly corporationId?: bigint;\n  /** Alliance ID if victim was in an alliance */\n  readonly allianceId?: bigint;\n  /** Ship type ID */\n  readonly shipTypeId: number;\n  /** Amount of damage taken */\n  readonly damageTaken: number;\n\n  constructor(data: {\n    id: number;\n    killmailId: bigint;\n    characterId?: bigint;\n    corporationId?: bigint;\n    allianceId?: bigint;\n    shipTypeId: number;\n    damageTaken: number;\n  }) {\n    this.id = data.id;\n    this.killmailId = data.killmailId;\n    this.characterId = data.characterId;\n    this.corporationId = data.corporationId;\n    this.allianceId = data.allianceId;\n    this.shipTypeId = data.shipTypeId;\n    this.damageTaken = data.damageTaken;\n  }\n\n  /**\n   * Check if this victim is an NPC\n   */\n  get isNpc(): boolean {\n    return this.characterId === null;\n  }\n\n  /**\n   * Convert to a plain object for persistence\n   */\n  toObject() {\n    return {\n      id: this.id,\n      killmailId: this.killmailId,\n      characterId: this.characterId,\n      corporationId: this.corporationId,\n      allianceId: this.allianceId,\n      shipTypeId: this.shipTypeId,\n      damageTaken: this.damageTaken,\n    };\n  }\n\n  /**\n   * Create a KillVictim domain entity from a database model\n   */\n  static fromModel(model: any): KillVictim {\n    return new KillVictim({\n      id: model.id,\n      killmailId: model.killmail_id,\n      characterId: model.character_id,\n      corporationId: model.corporation_id,\n      allianceId: model.alliance_id,\n      shipTypeId: model.ship_type_id,\n      damageTaken: model.damage_taken,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/killmail/Killmail.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[683,686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[683,686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1704,1707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1704,1707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3012,3015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3012,3015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Exclude, Expose, Transform } from 'class-transformer';\n\n/**\n * Killmail victim domain entity\n */\n@Exclude()\nexport class KillmailVictim {\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly characterId?: bigint;\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly corporationId?: bigint;\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly allianceId?: bigint;\n\n  @Expose()\n  readonly shipTypeId!: number;\n\n  @Expose()\n  readonly damageTaken!: number;\n\n  constructor(data: Partial<KillmailVictim>) {\n    Object.assign(this, data);\n  }\n\n  /**\n   * Converts the victim to a plain object\n   */\n  toJSON(): Record<string, any> {\n    return {\n      characterId: this.characterId?.toString(),\n      corporationId: this.corporationId?.toString(),\n      allianceId: this.allianceId?.toString(),\n      shipTypeId: this.shipTypeId,\n      damageTaken: this.damageTaken,\n    };\n  }\n}\n\n/**\n * Killmail attacker domain entity\n */\n@Exclude()\nexport class KillmailAttacker {\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly characterId?: bigint;\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly corporationId?: bigint;\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly allianceId?: bigint;\n\n  @Expose()\n  readonly damageDone!: number;\n\n  @Expose()\n  readonly finalBlow!: boolean;\n\n  @Expose()\n  readonly securityStatus?: number;\n\n  @Expose()\n  readonly shipTypeId?: number;\n\n  @Expose()\n  readonly weaponTypeId?: number;\n\n  constructor(data: Partial<KillmailAttacker>) {\n    Object.assign(this, data);\n  }\n\n  /**\n   * Converts the attacker to a plain object\n   */\n  toJSON(): Record<string, any> {\n    return {\n      characterId: this.characterId?.toString(),\n      corporationId: this.corporationId?.toString(),\n      allianceId: this.allianceId?.toString(),\n      damageDone: this.damageDone,\n      finalBlow: this.finalBlow,\n      securityStatus: this.securityStatus,\n      shipTypeId: this.shipTypeId,\n      weaponTypeId: this.weaponTypeId,\n    };\n  }\n}\n\n/**\n * Killmail domain entity\n * Represents a killmail in EVE Online\n */\n@Exclude()\nexport class Killmail {\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly killmailId!: bigint;\n\n  @Expose()\n  @Transform(({ value }) => value?.toISOString())\n  readonly killTime!: Date;\n\n  @Expose()\n  readonly npc!: boolean;\n\n  @Expose()\n  readonly solo!: boolean;\n\n  @Expose()\n  readonly awox!: boolean;\n\n  @Expose()\n  readonly shipTypeId!: number;\n\n  @Expose()\n  readonly systemId!: number;\n\n  @Expose()\n  readonly labels!: string[];\n\n  @Expose()\n  @Transform(({ value }) => value?.toString())\n  readonly totalValue!: bigint;\n\n  @Expose()\n  readonly points!: number;\n\n  @Expose()\n  readonly attackers?: KillmailAttacker[];\n\n  @Expose()\n  readonly victim?: KillmailVictim;\n\n  constructor(data: Partial<Killmail>) {\n    Object.assign(this, data);\n  }\n\n  /**\n   * Converts the killmail to a plain object\n   */\n  toJSON(): Record<string, any> {\n    return {\n      killmailId: this.killmailId?.toString() ?? '',\n      killTime: this.killTime?.toISOString() ?? new Date().toISOString(),\n      npc: this.npc,\n      solo: this.solo,\n      awox: this.awox,\n      shipTypeId: this.shipTypeId,\n      systemId: this.systemId,\n      labels: this.labels,\n      totalValue: this.totalValue?.toString() ?? '0',\n      points: this.points,\n      attackers: this.attackers?.map(a => a.toJSON()),\n      victim: this.victim?.toJSON(),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/killmail/LossFact.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":93,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":93,"endColumn":45},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":103,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":27},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":105,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":107,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3086,3089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3086,3089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseEntity } from '../BaseEntity';\nimport { ensureRequiredBigInt } from '../../utils/conversion';\nimport { validateRequired, validatePositive, validateNonNegative } from '../../utils/validation';\n\n/**\n * LossFact domain entity\n * Represents a character's loss in EVE Online\n */\nexport class LossFact extends BaseEntity {\n  /** Killmail ID from EVE Online */\n  readonly killmailId: bigint;\n\n  /** Character EVE ID (who lost the ship) */\n  readonly characterId: bigint;\n\n  /** Timestamp of the loss */\n  readonly killTime: Date;\n\n  /** Ship type ID of the ship that was lost */\n  shipTypeId: number;\n\n  /** Solar system ID where the loss occurred */\n  systemId: number;\n\n  /** Total ISK value of the loss */\n  totalValue: bigint;\n\n  /** Number of attackers on the killmail */\n  attackerCount: number;\n\n  // Labels are inherited from BaseEntity\n\n  /**\n   * Create a new LossFact instance\n   */\n  constructor(props: {\n    killmailId: bigint | string;\n    characterId: bigint | string;\n    killTime: Date;\n    shipTypeId: number;\n    systemId: number;\n    totalValue: bigint | string;\n    attackerCount: number;\n    labels?: string[];\n  }) {\n    super();\n\n    // Convert string IDs to bigint using utility\n    this.killmailId = ensureRequiredBigInt(props.killmailId);\n    this.characterId = ensureRequiredBigInt(props.characterId);\n\n    this.killTime = props.killTime;\n    this.shipTypeId = props.shipTypeId;\n    this.systemId = props.systemId;\n    this.totalValue = ensureRequiredBigInt(props.totalValue);\n    this.attackerCount = props.attackerCount;\n    this.labels = props.labels ?? [];\n\n    this.validate();\n  }\n\n  /**\n   * Validate the loss fact data using shared validation utilities\n   * @throws Error if data is invalid\n   */\n  private validate(): void {\n    validateRequired('killmailId', this.killmailId);\n    validateRequired('characterId', this.characterId);\n    validateRequired('killTime', this.killTime);\n    validatePositive('shipTypeId', this.shipTypeId);\n    validatePositive('systemId', this.systemId);\n    validateNonNegative('attackerCount', this.attackerCount);\n  }\n\n  /**\n   * Check if loss was a solo kill (by a single attacker)\n   */\n  get wasSoloKill(): boolean {\n    return this.attackerCount === 1;\n  }\n\n  /**\n   * Check if loss was a \"gank\" (multiple attackers)\n   */\n  get wasGanked(): boolean {\n    return this.attackerCount > 1;\n  }\n\n  /**\n   * Get the ISK value in millions (more readable)\n   */\n  get iskValueMillions(): number {\n    return Number(this.totalValue) / 1000000;\n  }\n\n  /**\n   * Get the loss type category based on ISK value\n   * @returns 'cheap', 'moderate', 'expensive', or 'blingy'\n   */\n  getLossCategory(): 'cheap' | 'moderate' | 'expensive' | 'blingy' {\n    const valueMillions = this.iskValueMillions;\n\n    if (valueMillions < 10) {\n      return 'cheap';\n    } else if (valueMillions < 100) {\n      return 'moderate';\n    } else if (valueMillions < 1000) {\n      return 'expensive';\n    } else {\n      return 'blingy';\n    }\n  }\n\n  /**\n   * Create a LossFact domain entity from a database model\n   */\n  static fromModel(model: any): LossFact {\n    return new LossFact({\n      killmailId: model.killmail_id,\n      characterId: model.character_id,\n      killTime: model.kill_time,\n      shipTypeId: model.ship_type_id,\n      systemId: model.system_id,\n      totalValue: model.total_value,\n      attackerCount: model.attacker_count,\n      labels: model.labels ?? [],\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/domain/killmail/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/cache/redis-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/http/ESIClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1065,1068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1065,1068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1241,1244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1241,1244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1429,1432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1429,1432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1599,1602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1599,1602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1780,1783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1780,1783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1949,1952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1949,1952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AxiosRequestConfig } from 'axios';\n\n/**\n * Configuration options for the ESI client\n */\nexport interface ESIClientConfig {\n  /** Base URL for the ESI API */\n  baseUrl?: string;\n  /** Default timeout in milliseconds */\n  timeout?: number;\n  /** User-Agent string to identify the client */\n  userAgent?: string;\n  /** Cache TTL in seconds */\n  cacheTtl?: number;\n  /** Maximum number of retries for failed requests */\n  maxRetries?: number;\n  /** Initial retry delay in milliseconds */\n  initialRetryDelay?: number;\n}\n\n/**\n * Interface for the unified ESI client\n */\nexport interface IESIClient {\n  /**\n   * Fetch data from the ESI API\n   * @param endpoint The ESI endpoint to call\n   * @param options Additional request options\n   * @returns The response data\n   */\n  fetch<T>(endpoint: string, options?: AxiosRequestConfig): Promise<T>;\n\n  /**\n   * Fetch killmail data from ESI\n   * @param killmailId The ID of the killmail\n   * @param hash The killmail hash\n   * @returns The killmail data\n   */\n  fetchKillmail(killmailId: number, hash: string): Promise<any>;\n\n  /**\n   * Fetch character information\n   * @param characterId The character ID\n   * @returns Character information\n   */\n  fetchCharacter(characterId: number): Promise<any>;\n\n  /**\n   * Fetch corporation information\n   * @param corporationId The corporation ID\n   * @returns Corporation information\n   */\n  fetchCorporation(corporationId: number): Promise<any>;\n\n  /**\n   * Fetch alliance information\n   * @param allianceId The alliance ID\n   * @returns Alliance information\n   */\n  fetchAlliance(allianceId: number): Promise<any>;\n\n  /**\n   * Fetch solar system information\n   * @param systemId The solar system ID\n   * @returns Solar system information\n   */\n  fetchSolarSystem(systemId: number): Promise<any>;\n\n  /**\n   * Fetch type information (ships, modules, etc.)\n   * @param typeId The type ID\n   * @returns Type information\n   */\n  fetchType(typeId: number): Promise<any>;\n\n  /**\n   * Clear the cache for a specific endpoint\n   * @param endpoint Optional endpoint to clear cache for. If not provided, clears all cache.\n   */\n  clearCache(endpoint?: string): Promise<void>;\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/http/MapClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[602,605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[602,605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[626,629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[626,629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[653,656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[653,656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1292,1295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1292,1295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2305,2308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2305,2308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UnifiedESIClient } from './UnifiedESIClient';\nimport { MapActivityResponseSchema, UserCharactersResponseSchema } from '../../types/ingestion';\nimport { z } from 'zod';\nimport { logger } from '../../lib/logger';\nimport { RateLimiter } from '../../utils/rateLimiter';\nimport { rateLimiterManager } from '../../utils/RateLimiterManager';\n\n// Infer types from schemas\ntype MapActivityResponse = z.infer<typeof MapActivityResponseSchema>;\ntype UserCharactersResponse = z.infer<typeof UserCharactersResponseSchema>;\n\n// Define response type for raw API responses\ninterface RawApiResponse {\n  data?: any[];\n  [key: string]: any;\n}\n\ntype ApiResponse = any[] | RawApiResponse;\n\nexport class MapClient {\n  private readonly client: UnifiedESIClient;\n  private readonly apiKey: string;\n  private readonly rateLimiter: RateLimiter;\n\n  constructor(baseUrl: string, apiKey: string) {\n    this.apiKey = apiKey;\n    this.client = new UnifiedESIClient({\n      baseUrl,\n      userAgent: 'EVE-Chart-Bot/1.0',\n      timeout: 10000,\n    });\n\n    // Use shared rate limiter from singleton manager\n    this.rateLimiter = rateLimiterManager.getRateLimiter('Map API');\n  }\n\n  /**\n   * Get data array from response, handling both array and object responses\n   */\n  private getDataArray(response: ApiResponse): any[] {\n    if (Array.isArray(response)) {\n      return response;\n    }\n    return response.data ?? [];\n  }\n\n  /**\n   * Fetch character activity data from the Map API\n   */\n  async getCharacterActivity(slug: string, days: number = 7, signal?: AbortSignal): Promise<MapActivityResponse> {\n    try {\n      logger.info(`Fetching character activity for map: ${slug}, days: ${days}`);\n\n      // Respect rate limit\n      await this.rateLimiter.wait(signal);\n\n      const url = `/api/map/character-activity?slug=${slug}&days=${days}`;\n      const response = await this.client.fetch<ApiResponse>(url, {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        signal,\n      });\n\n      if (response) {\n        const dataArray = this.getDataArray(response);\n        const dataCount = dataArray.length;\n        logger.info(`Received ${dataCount} records in response`);\n\n        // Log date range in the response\n        if (dataArray.length > 0) {\n          const dates = dataArray.map((item: any) => new Date(item.timestamp));\n          const oldestDate = new Date(Math.min(...dates.map((d: Date) => d.getTime())));\n          const newestDate = new Date(Math.max(...dates.map((d: Date) => d.getTime())));\n          logger.info(`Date range in response: ${oldestDate.toISOString()} to ${newestDate.toISOString()}`);\n        }\n\n        // Try to validate the response against our schema\n        try {\n          const validated = MapActivityResponseSchema.parse(response);\n          logger.info(`Successfully validated response with ${validated.data.length} activity records`);\n          return validated;\n        } catch (schemaError) {\n          logger.error(`Schema validation error for map activity response:`, schemaError);\n          // Return empty data array if validation fails\n          return { data: [] };\n        }\n      }\n\n      logger.warn(`No data received from map API`);\n      return { data: [] };\n    } catch (error) {\n      logger.error(`Error fetching character activity from Map API:`, error);\n      throw error;\n    }\n  }\n\n  async getUserCharacters(slug: string, signal?: AbortSignal): Promise<UserCharactersResponse> {\n    try {\n      await this.rateLimiter.wait(signal);\n      logger.info(`Fetching user characters for slug: ${slug}`);\n\n      const response = await this.client.fetch<ApiResponse>('/api/map/user_characters', {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n        params: {\n          slug,\n        },\n        signal,\n      });\n\n      const parsedData = UserCharactersResponseSchema.parse(response);\n      logger.info(`Parsed ${parsedData.data.length} user entries`);\n      logger.info(`Total characters: ${parsedData.data.reduce((acc, user) => acc + user.characters.length, 0)}`);\n\n      return parsedData;\n    } catch (error) {\n      logger.error({ error, slug }, 'Failed to fetch user characters from Map API');\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup(): void {\n    // Rate limiter is now managed by the singleton, no need to reset here\n    // The manager will handle cleanup centrally\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/http/UnifiedESIClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3926,3929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3926,3929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4368,4371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4368,4371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4538,4541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4538,4541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4708,4711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4708,4711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4873,4876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4873,4876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5037,5040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5037,5040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5189,5192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5189,5192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { logger } from '../../lib/logger';\nimport { CacheAdapter } from '../../cache/CacheAdapter';\nimport { CacheRedisAdapter } from '../../cache/CacheRedisAdapter';\nimport { ESIClientConfig, IESIClient } from './ESIClient';\nimport { retryOperation } from '../../utils/retry';\nimport { RateLimiter } from '../../utils/rateLimiter';\nimport { rateLimiterManager } from '../../utils/RateLimiterManager';\nimport {\n  REDIS_URL,\n  ESI_BASE_URL,\n  CACHE_TTL,\n  HTTP_TIMEOUT,\n  HTTP_MAX_RETRIES,\n  HTTP_INITIAL_RETRY_DELAY,\n} from '../../config';\n\n/**\n * Unified client for interacting with EVE Online's ESI API\n * Combines caching and retry logic from previous implementations\n */\nexport class UnifiedESIClient implements IESIClient {\n  private readonly client: AxiosInstance;\n  private readonly config: Required<ESIClientConfig>;\n  private readonly cache: CacheAdapter;\n  private readonly rateLimiter: RateLimiter | null = null;\n\n  /**\n   * Create a new unified ESI client\n   * @param config Optional configuration for the client\n   * @param cache Optional cache adapter to use for requests\n   */\n  constructor(config: ESIClientConfig = {}, cache?: CacheAdapter) {\n    this.config = {\n      baseUrl: config.baseUrl ?? ESI_BASE_URL,\n      timeout: config.timeout ?? HTTP_TIMEOUT,\n      userAgent: config.userAgent ?? 'EVE-Chart-Bot/1.0',\n      cacheTtl: config.cacheTtl ?? CACHE_TTL,\n      maxRetries: config.maxRetries ?? HTTP_MAX_RETRIES,\n      initialRetryDelay: config.initialRetryDelay ?? HTTP_INITIAL_RETRY_DELAY,\n    };\n\n    this.client = axios.create({\n      baseURL: this.config.baseUrl,\n      timeout: this.config.timeout,\n      headers: {\n        'User-Agent': this.config.userAgent,\n        Accept: 'application/json',\n      },\n    });\n\n    this.cache = cache ?? new CacheRedisAdapter(REDIS_URL, this.config.cacheTtl);\n\n    // Only use rate limiter if this is an ESI client (not used for other APIs)\n    if (this.config.baseUrl.includes('esi')) {\n      this.rateLimiter = rateLimiterManager.getRateLimiter('ESI');\n    }\n  }\n\n  /**\n   * Fetch data from ESI with caching and retry logic\n   * @param endpoint API endpoint to fetch\n   * @param options Additional request options\n   */\n  async fetch<T>(endpoint: string, options: AxiosRequestConfig = {}): Promise<T> {\n    const url = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\n    const cacheKey = this.buildCacheKey(url, options.params ?? {});\n\n    try {\n      // Try to get from cache first\n      const cachedData = await this.cache.get<T>(cacheKey);\n      if (cachedData) {\n        logger.debug(`ESI cache hit for ${url}`);\n        return cachedData;\n      }\n\n      // Not in cache, fetch from API with retry logic\n      logger.debug(`ESI cache miss for ${url}, fetching from API`);\n\n      // Apply rate limiting if configured\n      if (this.rateLimiter && options.signal) {\n        // Cast to AbortSignal if it's compatible\n        await this.rateLimiter.wait(options.signal as AbortSignal);\n      } else if (this.rateLimiter) {\n        await this.rateLimiter.wait();\n      }\n\n      const data = await retryOperation(\n        () => this.client.get<T>(url, options).then(response => response.data),\n        `ESI request to ${url}`,\n        {\n          maxRetries: this.config.maxRetries,\n          initialRetryDelay: this.config.initialRetryDelay,\n          timeout: this.config.timeout,\n        }\n      );\n\n      if (!data) {\n        throw new Error(`Failed to fetch data from ESI after ${this.config.maxRetries} retries`);\n      }\n\n      // Cache the response\n      await this.cache.set(cacheKey, data, this.config.cacheTtl);\n\n      return data;\n    } catch (error) {\n      logger.error(`Error fetching from ESI ${url}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Build a cache key from an endpoint and parameters\n   */\n  private buildCacheKey(endpoint: string, params: Record<string, any>): string {\n    const paramString =\n      Object.keys(params).length > 0\n        ? Object.entries(params)\n            .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&')\n        : '';\n\n    return `esi:${endpoint}${paramString ? `?${paramString}` : ''}`;\n  }\n\n  /**\n   * Fetch killmail data\n   */\n  async fetchKillmail(killmailId: number, hash: string): Promise<any> {\n    return this.fetch(`/killmails/${killmailId}/${hash}/`);\n  }\n\n  /**\n   * Fetch character information\n   */\n  async fetchCharacter(characterId: number): Promise<any> {\n    return this.fetch(`/characters/${characterId}/`);\n  }\n\n  /**\n   * Fetch corporation information\n   */\n  async fetchCorporation(corporationId: number): Promise<any> {\n    return this.fetch(`/corporations/${corporationId}/`);\n  }\n\n  /**\n   * Fetch alliance information\n   */\n  async fetchAlliance(allianceId: number): Promise<any> {\n    return this.fetch(`/alliances/${allianceId}/`);\n  }\n\n  /**\n   * Fetch solar system information\n   */\n  async fetchSolarSystem(systemId: number): Promise<any> {\n    return this.fetch(`/universe/systems/${systemId}/`);\n  }\n\n  /**\n   * Fetch type information\n   */\n  async fetchType(typeId: number): Promise<any> {\n    return this.fetch(`/universe/types/${typeId}/`);\n  }\n\n  /**\n   * Clear the cache for a specific endpoint\n   */\n  async clearCache(endpoint?: string): Promise<void> {\n    if (endpoint) {\n      const normalizedEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\n      await this.cache.delete(`esi:${normalizedEndpoint}`);\n    } else {\n      // Clear all ESI cache\n      await this.cache.clear();\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/http/ZkillClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[459,462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[459,462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":1,"message":"Async method 'getKillmail' has a complexity of 11. Maximum allowed is 10.","line":40,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":97,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1371,1374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1371,1374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3513,3516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3513,3516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4997,5000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4997,5000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UnifiedESIClient } from './UnifiedESIClient';\nimport { logger } from '../../lib/logger';\nimport { RateLimiter } from '../../utils/rateLimiter';\nimport { rateLimiterManager } from '../../utils/RateLimiterManager';\nimport { RATE_LIMIT_MIN_DELAY } from '../../config';\n\ninterface ZkillResponse {\n  killID: number;\n  killmail_id: number;\n  zkb: {\n    hash: string;\n    totalValue: number;\n    points: number;\n    labels?: string[];\n  };\n  [key: string]: any; // Allow additional fields\n}\n\nexport class ZkillClient {\n  private readonly client: UnifiedESIClient;\n  private readonly rateLimiter: RateLimiter;\n\n  constructor(baseUrl: string = 'https://zkillboard.com/api') {\n    this.client = new UnifiedESIClient({\n      baseUrl,\n      userAgent: 'EVE-Chart-Bot/1.0',\n      timeout: 15000,\n    });\n\n    // Use shared rate limiter from singleton manager\n    // Override the default delay with config value if needed\n    this.rateLimiter = rateLimiterManager.getRateLimiter('zKillboard', {\n      minDelayMs: RATE_LIMIT_MIN_DELAY,\n    });\n  }\n\n  /**\n   * Get a single killmail from zKillboard\n   */\n  async getKillmail(killId: number, signal?: AbortSignal): Promise<ZkillResponse | null> {\n    try {\n      await this.rateLimiter.wait(signal);\n      logger.info(`Fetching killmail ${killId} from zKillboard`);\n\n      const response = await this.client.fetch<Record<string, any>>(`/killID/${killId}/`, { signal });\n\n      // Log the raw response for debugging\n      logger.debug(`Raw zKill response for killmail ${killId}:`, JSON.stringify(response, null, 2));\n\n      // Validate response structure\n      if (!response || typeof response !== 'object') {\n        logger.warn(`Invalid response format for killmail ${killId}`);\n        return null;\n      }\n\n      // The response might be wrapped in an object with the killID as the key\n      const killData = response[killId.toString()] || response;\n\n      if (!killData || typeof killData !== 'object') {\n        logger.warn(`Invalid kill data format for killmail ${killId}`);\n        return null;\n      }\n\n      // Log the kill data structure\n      logger.debug(`Kill data structure for ${killId}:`, {\n        hasKillmailId: !!killData.killmail_id,\n        hasZkb: !!killData.zkb,\n        hasHash: !!killData.zkb?.hash,\n        keys: Object.keys(killData),\n        zkbKeys: killData.zkb ? Object.keys(killData.zkb) : [],\n      });\n\n      // Ensure required fields exist\n      if (!killData.killmail_id || !killData.zkb?.hash) {\n        logger.warn(`Missing required fields for killmail ${killId}`, {\n          killmail_id: killData.killmail_id,\n          hasZkb: !!killData.zkb,\n          hasHash: !!killData.zkb?.hash,\n        });\n        return null;\n      }\n\n      // Ensure the killID matches\n      if (killData.killID !== killId) {\n        logger.warn(`KillID mismatch for killmail ${killId}`, {\n          expected: killId,\n          actual: killData.killID,\n        });\n        return null;\n      }\n\n      return killData as ZkillResponse;\n    } catch (error) {\n      logger.error(`Error fetching killmail ${killId} from zKillboard:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get kills for a character from zKillboard\n   */\n  async getCharacterKills(characterId: number, page: number = 1, signal?: AbortSignal): Promise<ZkillResponse[]> {\n    try {\n      await this.rateLimiter.wait(signal);\n      logger.info(`Fetching kills for character ${characterId} from zKillboard (page ${page})`);\n\n      const response = await this.client.fetch<Record<string, any>>(`/characterID/${characterId}/page/${page}/`, {\n        signal,\n      });\n\n      // Log the raw response for debugging\n      logger.debug(`Raw zKill response for character ${characterId} kills:`, JSON.stringify(response, null, 2));\n\n      if (!response || typeof response !== 'object') {\n        logger.warn(`Invalid response format for character ${characterId} kills`);\n        return [];\n      }\n\n      // Convert object response to array\n      const kills = Object.values(response).filter(kill => {\n        const isValid = kill && typeof kill === 'object' && kill.killmail_id && kill.zkb?.hash;\n\n        if (!isValid) {\n          logger.debug(`Invalid kill entry:`, {\n            hasKillmailId: !!kill?.killmail_id,\n            hasZkb: !!kill?.zkb,\n            hasHash: !!kill?.zkb?.hash,\n            keys: kill ? Object.keys(kill) : [],\n          });\n        }\n\n        return isValid;\n      }) as ZkillResponse[];\n\n      return kills;\n    } catch (error) {\n      logger.error(`Error fetching kills for character ${characterId} from zKillboard:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get losses for a character from zKillboard\n   */\n  async getCharacterLosses(characterId: number, page: number = 1, signal?: AbortSignal): Promise<ZkillResponse[]> {\n    try {\n      await this.rateLimiter.wait(signal);\n      logger.info(`Fetching losses for character ${characterId} from zKillboard (page ${page})`);\n\n      const response = await this.client.fetch<Record<string, any>>(\n        `/losses/characterID/${characterId}/page/${page}/`,\n        { signal }\n      );\n\n      // Log the raw response for debugging\n      logger.debug(`Raw zKill response for character ${characterId} losses:`, JSON.stringify(response, null, 2));\n\n      if (!response || typeof response !== 'object') {\n        logger.warn(`Invalid response format for character ${characterId} losses`);\n        return [];\n      }\n\n      // Convert object response to array\n      const losses = Object.values(response).filter(kill => {\n        const isValid = kill && typeof kill === 'object' && kill.killmail_id && kill.zkb?.hash;\n\n        if (!isValid) {\n          logger.debug(`Invalid loss entry:`, {\n            hasKillmailId: !!kill?.killmail_id,\n            hasZkb: !!kill?.zkb,\n            hasHash: !!kill?.zkb?.hash,\n            keys: kill ? Object.keys(kill) : [],\n          });\n        }\n\n        return isValid;\n      }) as ZkillResponse[];\n\n      return losses;\n    } catch (error) {\n      logger.error(`Error fetching losses for character ${characterId} from zKillboard:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup(): void {\n    // Rate limiter is now managed by the singleton, no need to reset here\n    // The manager will handle cleanup centrally\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/http/zkill.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'fetch' has too many lines (75). Maximum allowed is 50.","line":106,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":198,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'fetch' has a complexity of 15. Maximum allowed is 10.","line":106,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":198,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5202,5205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5202,5205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 429.","line":167,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":167,"endColumn":52},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":168,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 400.","line":169,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":169,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":169,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":169,"endColumn":85},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 429.","line":173,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":173,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":175,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":175,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7406,7409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7406,7409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7466,7469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7466,7469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8642,8645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8642,8645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8701,8704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8701,8704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9521,9524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9521,9524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9580,9583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9580,9583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10017,10020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10017,10020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10209,10212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10209,10212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10384,10387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10384,10387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ZKillboard API Client\n *\n * API Documentation: https://zkillboard.com/api/\n *\n * Features:\n * - Rate limiting with exponential backoff\n * - Automatic retries with increasing timeouts\n * - Pagination support for all list endpoints\n * - Detailed error logging\n * - Response validation\n *\n * Rate Limiting:\n * - 20 requests per minute\n * - Minimum 3s delay between requests\n * - Exponential backoff on errors\n * - Maximum 60s delay between requests\n * - Maximum 3 retries per request\n * - Timeout starts at 15s, increases with retries up to 45s\n *\n * Example URLs:\n * - Character Kills: https://zkillboard.com/api/kills/characterID/268946627/page/1/\n * - Character Losses: https://zkillboard.com/api/losses/characterID/268946627/page/1/\n * - Corporation Kills: https://zkillboard.com/api/kills/corporationID/123456789/\n * - System Kills: https://zkillboard.com/api/kills/systemID/30000142/\n *\n * Note: The API returns results in reverse chronological order (newest first).\n * Each page typically contains 100 results.\n */\n\nimport axios, { AxiosInstance } from 'axios';\nimport { logger } from '../../lib/logger';\nimport { timerManager } from '../../utils/timerManager';\n\n// Rate limiting configuration\nconst RATE_LIMIT = {\n  requestsPerMinute: 20, // More conservative than zKillboard's documented rate limit\n  minDelay: 3000, // Minimum delay between requests (3 seconds)\n  maxDelay: 60000, // Maximum delay between requests (60 seconds)\n  backoffFactor: 2, // More aggressive exponential backoff\n  maxRetries: 3, // Maximum number of retries per request\n  initialTimeout: 15000, // Initial timeout of 15 seconds\n  maxTimeout: 45000, // Maximum timeout of 45 seconds\n};\n\n/**\n * Client for interacting with ZKillboard API\n */\nexport class ZKillboardClient {\n  private readonly client: AxiosInstance;\n  private readonly baseUrl: string;\n  private lastRequestTime: number = 0;\n  private currentDelay: number = RATE_LIMIT.minDelay;\n  private consecutiveErrors: number = 0;\n  private currentTimeout: number = RATE_LIMIT.initialTimeout;\n\n  constructor() {\n    this.baseUrl = 'https://zkillboard.com/api';\n\n    this.client = axios.create({\n      baseURL: this.baseUrl,\n      timeout: RATE_LIMIT.initialTimeout,\n      headers: {\n        'User-Agent': 'EVE-Chart-Bot/1.0',\n        Accept: 'application/json',\n      },\n    });\n  }\n\n  private async rateLimit(signal?: AbortSignal): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequestTime;\n\n    // If we've had consecutive errors, use exponential backoff\n    if (this.consecutiveErrors > 0) {\n      this.currentDelay = Math.min(\n        RATE_LIMIT.maxDelay,\n        RATE_LIMIT.minDelay * Math.pow(RATE_LIMIT.backoffFactor, this.consecutiveErrors)\n      );\n      // Also increase timeout with each error\n      this.currentTimeout = Math.min(\n        RATE_LIMIT.maxTimeout,\n        RATE_LIMIT.initialTimeout * Math.pow(RATE_LIMIT.backoffFactor, this.consecutiveErrors)\n      );\n    } else {\n      // Reset delays on successful requests\n      this.currentDelay = RATE_LIMIT.minDelay;\n      this.currentTimeout = RATE_LIMIT.initialTimeout;\n    }\n\n    // Ensure minimum time between requests\n    if (timeSinceLastRequest < this.currentDelay) {\n      const waitTime = this.currentDelay - timeSinceLastRequest;\n      logger.debug(`Rate limiting: waiting ${waitTime}ms before next request`);\n\n      try {\n        await timerManager.delay(waitTime, signal);\n      } catch (error) {\n        throw new Error('Rate limiting aborted');\n      }\n    }\n\n    this.lastRequestTime = Date.now();\n  }\n\n  private async fetch<T>(endpoint: string, retryCount = 0, signal?: AbortSignal): Promise<T> {\n    const url = `${this.baseUrl}/${endpoint}`;\n    logger.debug(`Making request to zKillboard: ${url}`);\n\n    // Check if already aborted\n    if (signal?.aborted) {\n      throw new Error('Request aborted');\n    }\n\n    try {\n      await this.rateLimit(signal);\n\n      // Update timeout for this request\n      this.client.defaults.timeout = this.currentTimeout;\n\n      // Create a managed abort controller for this request\n      const requestAbortController = timerManager.createAbortController();\n\n      // Link to parent signal if provided\n      if (signal) {\n        const abortHandler = () => requestAbortController.abort();\n        signal.addEventListener('abort', abortHandler, { once: true });\n        // Clean up the listener when request completes\n        requestAbortController.signal.addEventListener(\n          'abort',\n          () => {\n            signal.removeEventListener('abort', abortHandler);\n          },\n          { once: true }\n        );\n      }\n\n      try {\n        const response = await this.client.get<T>(endpoint, {\n          signal: requestAbortController.signal,\n        });\n        // Remove controller from management after successful request\n        timerManager.removeAbortController(requestAbortController);\n        this.consecutiveErrors = 0; // Reset error count on success\n        return response.data;\n      } catch (error) {\n        // Remove controller from management on error\n        timerManager.removeAbortController(requestAbortController);\n        throw error;\n      }\n    } catch (error: any) {\n      this.consecutiveErrors++;\n      const errorDetails = {\n        url,\n        status: error.response?.status,\n        statusText: error.response?.statusText,\n        data: error.response?.data,\n        headers: error.response?.headers,\n        timeout: error.code === 'ECONNABORTED' ? this.currentTimeout : undefined,\n        error: error.message,\n        consecutiveErrors: this.consecutiveErrors,\n        currentDelay: this.currentDelay,\n        currentTimeout: this.currentTimeout,\n        retryCount,\n        isTimeout: error.code === 'ECONNABORTED',\n        isNetworkError: error.code === 'ECONNREFUSED' || error.code === 'ECONNRESET',\n        isRateLimit: error.response?.status === 429,\n        isServerError: error.response?.status >= 500,\n        isClientError: error.response?.status >= 400 && error.response?.status < 500,\n      };\n\n      // Log different error types with appropriate severity\n      if (error.response?.status === 429) {\n        logger.warn(`ZKillboard rate limit hit:`, errorDetails);\n      } else if (error.response?.status >= 500) {\n        logger.error(`ZKillboard server error:`, errorDetails);\n      } else if (error.code === 'ECONNABORTED') {\n        logger.error(`ZKillboard request timeout:`, errorDetails);\n      } else if (error.code === 'ECONNREFUSED' || error.code === 'ECONNRESET') {\n        logger.error(`ZKillboard connection error:`, errorDetails);\n      } else {\n        logger.error(`ZKillboard request failed:`, errorDetails);\n      }\n\n      // Retry logic\n      if (retryCount < RATE_LIMIT.maxRetries) {\n        const nextRetry = retryCount + 1;\n        logger.info(\n          `Retrying request to ${endpoint} (attempt ${nextRetry}/${\n            RATE_LIMIT.maxRetries\n          }) - Last error: ${error.response?.status || error.code}`\n        );\n        return this.fetch(endpoint, nextRetry, signal);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get a single killmail by ID\n   * @param killId - The killmail ID to fetch\n   * @returns The killmail data or null if not found\n   *\n   * Note: This method will retry up to 3 times with exponential backoff\n   * if the request fails.\n   */\n  public async getKillmail(killId: number): Promise<any> {\n    const response = await this.fetch<Record<string, any>>(`killID/${killId}/`);\n    logger.debug(`ZKillboard response for killmail ${killId}:`, response);\n\n    // Handle both array and object responses\n    if (Array.isArray(response)) {\n      return response[0] || null;\n    }\n\n    // The response might be wrapped in an object with the killID as the key\n    const killData = response[killId.toString()] || response;\n    if (!killData || typeof killData !== 'object') {\n      logger.warn(`Invalid kill data format for killmail ${killId}`, {\n        responseType: typeof response,\n        isArray: Array.isArray(response),\n        responseKeys: Object.keys(response),\n      });\n      return null;\n    }\n\n    return killData;\n  }\n\n  /**\n   * Get kills for a character\n   * @param characterId - The EVE character ID\n   * @param page - The page number to fetch (default: 1)\n   * @returns Array of killmails for the character\n   *\n   * Note: The API returns kills in reverse chronological order (newest first).\n   * Each page typically contains 100 killmails.\n   *\n   * Example URL: https://zkillboard.com/api/kills/characterID/268946627/page/1/\n   */\n  public async getCharacterKills(characterId: number, page: number = 1): Promise<any[]> {\n    try {\n      const response = await this.fetch<any[]>(`kills/characterID/${characterId}/page/${page}/`);\n      logger.debug(`ZKillboard response for character ${characterId} page ${page}:`, response);\n      return response;\n    } catch (error) {\n      logger.error(`Error fetching kills for character ${characterId} page ${page}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get losses for a character\n   * @param characterId - The EVE character ID\n   * @param page - The page number to fetch (default: 1)\n   * @returns Array of losses for the character\n   *\n   * Note: The API returns losses in reverse chronological order (newest first).\n   * Each page typically contains 100 losses.\n   *\n   * Example URL: https://zkillboard.com/api/losses/characterID/268946627/page/1/\n   */\n  public async getCharacterLosses(characterId: number, page: number = 1): Promise<any[]> {\n    try {\n      const response = await this.fetch<any[]>(`losses/characterID/${characterId}/page/${page}/`);\n      logger.debug(`ZKillboard response for character ${characterId} page ${page}:`, response);\n      return response;\n    } catch (error) {\n      logger.error(`Error fetching losses for character ${characterId} page ${page}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get kills for a corporation\n   */\n  public async getCorporationKills(corporationId: number): Promise<any[]> {\n    return this.fetch(`kills/corporationID/${corporationId}/`);\n  }\n\n  /**\n   * Get losses for a corporation\n   */\n  public async getCorporationLosses(corporationId: number): Promise<any[]> {\n    return this.fetch(`losses/corporationID/${corporationId}/`);\n  }\n\n  /**\n   * Get kills in a system\n   */\n  public async getSystemKills(systemId: number): Promise<any[]> {\n    return this.fetch(`kills/systemID/${systemId}/`);\n  }\n\n  /**\n   * Clean up resources and cancel any pending operations\n   */\n  public cleanup(): void {\n    // Cleanup is now handled by the TimerManager\n    logger.debug('ZKillboardClient cleanup called - managed by TimerManager');\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/mapper/PrismaMapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[504,507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[504,507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[770,773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[770,773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1243,1246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1243,1246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1810,1813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1810,1813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2132,2135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2132,2135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2153,2156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2153,2156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2193,2196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2193,2196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ClassConstructor, plainToInstance } from 'class-transformer';\n\n/**\n * Generic mapper for converting between Prisma models and domain entities\n */\nexport class PrismaMapper {\n  /**\n   * Converts snake_case to camelCase\n   */\n  private static toCamelCase(str: string): string {\n    return str.replace(/_([a-z])/g, (_match, letter) => letter.toUpperCase());\n  }\n\n  /**\n   * Recursively converts an object's keys from snake_case to camelCase\n   */\n  private static convertKeysToCamelCase(obj: any): any {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.convertKeysToCamelCase(item));\n    }\n\n    if (typeof obj === 'object' && obj.constructor === Object) {\n      const converted: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        const camelKey = this.toCamelCase(key);\n        converted[camelKey] = this.convertKeysToCamelCase(value);\n      }\n      return converted;\n    }\n\n    return obj;\n  }\n\n  /**\n   * Maps a Prisma model to a domain entity\n   * @param model The Prisma model instance\n   * @param EntityClass The domain entity class constructor\n   * @returns A new instance of the domain entity\n   */\n  static map<T>(model: any, EntityClass: ClassConstructor<T>): T {\n    // Convert snake_case keys to camelCase before mapping\n    const convertedModel = this.convertKeysToCamelCase(model);\n\n    return plainToInstance(EntityClass, convertedModel, {\n      excludeExtraneousValues: true,\n      enableImplicitConversion: true,\n    });\n  }\n\n  /**\n   * Maps an array of Prisma models to domain entities\n   * @param models Array of Prisma model instances\n   * @param EntityClass The domain entity class constructor\n   * @returns Array of domain entity instances\n   */\n  static mapArray<T>(models: any[], EntityClass: ClassConstructor<T>): T[] {\n    return models.map(model => this.map(model, EntityClass));\n  }\n\n  /**\n   * Maps a Prisma model to a plain object, excluding Prisma-specific fields\n   * @param model The Prisma model instance\n   * @returns A plain object representation\n   */\n  static toPlainObject(model: any): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    // Skip Prisma-specific fields\n    const skipFields = ['$type', '$parent', '$path', '$args'];\n\n    for (const [key, value] of Object.entries(model)) {\n      if (!skipFields.includes(key)) {\n        result[key] = value;\n      }\n    }\n\n    return result;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/persistence/client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[321,324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[321,324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\nimport { logger } from '../../lib/logger';\n\n// Initialize a single PrismaClient instance to be used throughout the application\nconst prisma = new PrismaClient();\n\n// Log queries in development\nif (process.env.NODE_ENV === 'development') {\n  prisma.$on('query' as never, (e: any) => {\n    logger.debug(`Query: ${e.query}`);\n    logger.debug(`Duration: ${e.duration}ms`);\n  });\n}\n\nexport default prisma;\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/BaseRepository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1434,1437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1434,1437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1711,1714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1711,1714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2424,2427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2424,2427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2537,2540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2537,2540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2900,2903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2900,2903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3039,3042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3039,3042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3534,3537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3534,3537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3551,3554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3551,3554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3568,3571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3568,3571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3714,3717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3714,3717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4023,4026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4023,4026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4116,4119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4116,4119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4351,4354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4351,4354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4458,4461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4458,4461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\nimport { ClassConstructor } from 'class-transformer';\nimport { logger } from '../../lib/logger';\nimport prisma from '../persistence/client';\nimport { PrismaMapper } from '../mapper/PrismaMapper';\nimport { ensureBigInt } from '../../utils/conversion';\n\n/**\n * Base repository class that all specific repositories will extend.\n * Provides common functionality and access to the database.\n */\nexport abstract class BaseRepository {\n  protected prisma: PrismaClient;\n  protected modelName: string;\n\n  constructor(modelName: string) {\n    this.prisma = prisma;\n    this.modelName = modelName;\n  }\n\n  /**\n   * Execute a database query with error handling\n   */\n  protected async executeQuery<R>(queryFn: () => Promise<R>): Promise<R> {\n    try {\n      // Execute query directly\n      const result = await queryFn();\n      return result;\n    } catch (error) {\n      logger.error(`Error in ${this.modelName} repository:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generic find by ID method\n   * @param model Prisma model name (e.g., 'character', 'killFact')\n   * @param id The ID to search for\n   * @param EntityClass The domain entity class constructor\n   * @param options Additional query options (include, select, etc.)\n   * @returns Domain entity instance or null\n   */\n  protected async findById<T>(\n    model: string,\n    id: any,\n    EntityClass: ClassConstructor<T>,\n    options: any = {}\n  ): Promise<T | null> {\n    return this.executeQuery(async () => {\n      // Convert string/number IDs to BigInt if needed\n      const normalizedId = typeof id === 'string' || typeof id === 'number' ? ensureBigInt(id) : id;\n\n      const record = await (this.prisma as any)[model].findUnique({\n        where: {\n          id: normalizedId,\n          // Also try common ID field patterns\n          ...(model === 'character' && { eveId: normalizedId }),\n          ...(model === 'killFact' && { killmailId: normalizedId }),\n        },\n        ...options,\n      });\n\n      return record ? PrismaMapper.map(record, EntityClass) : null;\n    });\n  }\n\n  /**\n   * Generic find many method\n   * @param model Prisma model name\n   * @param EntityClass The domain entity class constructor\n   * @param options Query options (where, include, orderBy, etc.)\n   * @returns Array of domain entity instances\n   */\n  protected async findMany<T>(model: string, EntityClass: ClassConstructor<T>, options: any = {}): Promise<T[]> {\n    return this.executeQuery(async () => {\n      const records = await (this.prisma as any)[model].findMany(options);\n      return PrismaMapper.mapArray(records, EntityClass);\n    });\n  }\n\n  /**\n   * Generic create method\n   * @param model Prisma model name\n   * @param data Data to create\n   * @param EntityClass The domain entity class constructor\n   * @returns Created domain entity instance\n   */\n  protected async create<T>(model: string, data: any, EntityClass: ClassConstructor<T>): Promise<T> {\n    return this.executeQuery(async () => {\n      const record = await (this.prisma as any)[model].create({ data });\n      return PrismaMapper.map(record, EntityClass);\n    });\n  }\n\n  /**\n   * Generic upsert method\n   * @param model Prisma model name\n   * @param where Where clause for finding existing record\n   * @param create Data for creating new record\n   * @param update Data for updating existing record\n   * @param EntityClass The domain entity class constructor\n   * @returns Upserted domain entity instance\n   */\n  protected async upsert<T>(\n    model: string,\n    where: any,\n    create: any,\n    update: any,\n    EntityClass: ClassConstructor<T>\n  ): Promise<T> {\n    return this.executeQuery(async () => {\n      const record = await (this.prisma as any)[model].upsert({\n        where,\n        create,\n        update,\n      });\n      return PrismaMapper.map(record, EntityClass);\n    });\n  }\n\n  /**\n   * Generic delete method\n   * @param model Prisma model name\n   * @param where Where clause for deletion\n   */\n  protected async delete(model: string, where: any): Promise<void> {\n    return this.executeQuery(async () => {\n      await (this.prisma as any)[model].delete({ where });\n    });\n  }\n\n  /**\n   * Generic count method\n   * @param model Prisma model name\n   * @param where Optional where clause\n   * @returns Count of records\n   */\n  protected async count(model: string, where: any = {}): Promise<number> {\n    return this.executeQuery(async () => {\n      return await (this.prisma as any)[model].count({ where });\n    });\n  }\n\n  /**\n   * Disconnect from the database\n   */\n  async disconnect(): Promise<void> {\n    await this.prisma.$disconnect();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/CharacterRepository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/KillRepository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2163,2166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2163,2166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2564,2567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2564,2567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3354,3357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3354,3357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4364,4367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4364,4367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5206,5209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5206,5209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5220,5223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5220,5223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6368,6371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6368,6371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6961,6964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6961,6964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7576,7579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7576,7579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8853,8856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8853,8856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9049,9052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9049,9052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (363). Maximum allowed is 300.","line":356,"column":1,"nodeType":null,"messageId":"exceed","endLine":424,"endColumn":1},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":357,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9360,9363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9360,9363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9638,9641],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9638,9641],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9902,9905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9902,9905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":387,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":387,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10207,10210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10207,10210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":401,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":401,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10524,10527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10524,10527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":415,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":415,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10843,10846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10843,10846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\nimport { logger } from '../../lib/logger';\n\n/**\n * Simplified Kill Repository for WebSocket-based ingestion\n * No longer handles partial killmails since WebSocket provides complete data\n */\nexport class KillRepository {\n  constructor(private prisma: PrismaClient) {}\n\n  /**\n   * Ingest a complete killmail from WebSocket data\n   */\n  async ingestKillmail(\n    killFact: {\n      killmail_id: bigint;\n      kill_time: Date;\n      npc: boolean;\n      solo: boolean;\n      awox: boolean;\n      ship_type_id: number;\n      system_id: number;\n      labels: string[];\n      total_value: bigint;\n      points: number;\n    },\n    victim: {\n      character_id?: bigint;\n      corporation_id?: bigint;\n      alliance_id?: bigint;\n      ship_type_id: number;\n      damage_taken: number;\n    },\n    attackers: Array<{\n      character_id?: bigint;\n      corporation_id?: bigint;\n      alliance_id?: bigint;\n      damage_done: number;\n      final_blow: boolean;\n      security_status?: number;\n      ship_type_id?: number;\n      weapon_type_id?: number;\n    }>,\n    involvedCharacters: Array<{\n      character_id: bigint;\n      role: 'attacker' | 'victim';\n    }>\n  ): Promise<void> {\n    try {\n      await this.prisma.$transaction(async tx => {\n        await this.upsertKillFacts(killFact, tx);\n        await this.processVictimData(killFact.killmail_id, victim, tx);\n        await this.processAttackerData(killFact.killmail_id, attackers, tx);\n        await this.manageCharacterRelationships(killFact.killmail_id, involvedCharacters, tx);\n        await this.createLossFact(killFact, victim, attackers, tx);\n      });\n\n      logger.debug(`Successfully ingested killmail ${killFact.killmail_id}`);\n    } catch (error) {\n      logger.error(`Failed to ingest killmail ${killFact.killmail_id}`, error);\n      throw error;\n    }\n  }\n\n  private async upsertKillFacts(\n    killFact: {\n      killmail_id: bigint;\n      kill_time: Date;\n      npc: boolean;\n      solo: boolean;\n      awox: boolean;\n      ship_type_id: number;\n      system_id: number;\n      labels: string[];\n      total_value: bigint;\n      points: number;\n    },\n    tx: any\n  ): Promise<void> {\n    await tx.killFact.upsert({\n      where: { killmail_id: killFact.killmail_id },\n      create: killFact,\n      update: killFact,\n    });\n  }\n\n  private async processVictimData(\n    killmailId: bigint,\n    victim: {\n      character_id?: bigint;\n      corporation_id?: bigint;\n      alliance_id?: bigint;\n      ship_type_id: number;\n      damage_taken: number;\n    },\n    tx: any\n  ): Promise<void> {\n    await tx.killVictim.deleteMany({\n      where: { killmail_id: killmailId },\n    });\n\n    await tx.killVictim.create({\n      data: {\n        killmail_id: killmailId,\n        character_id: victim.character_id ?? null,\n        corporation_id: victim.corporation_id ?? null,\n        alliance_id: victim.alliance_id ?? null,\n        ship_type_id: victim.ship_type_id,\n        damage_taken: victim.damage_taken,\n      },\n    });\n  }\n\n  private async processAttackerData(\n    killmailId: bigint,\n    attackers: Array<{\n      character_id?: bigint;\n      corporation_id?: bigint;\n      alliance_id?: bigint;\n      damage_done: number;\n      final_blow: boolean;\n      security_status?: number;\n      ship_type_id?: number;\n      weapon_type_id?: number;\n    }>,\n    tx: any\n  ): Promise<void> {\n    await tx.killAttacker.deleteMany({\n      where: { killmail_id: killmailId },\n    });\n\n    // Use Promise.all for parallel attacker creation instead of sequential loop\n    await Promise.all(\n      attackers.map(attacker =>\n        tx.killAttacker.create({\n          data: {\n            killmail_id: killmailId,\n            character_id: attacker.character_id ?? null,\n            corporation_id: attacker.corporation_id ?? null,\n            alliance_id: attacker.alliance_id ?? null,\n            damage_done: attacker.damage_done,\n            final_blow: attacker.final_blow,\n            security_status: attacker.security_status ?? null,\n            ship_type_id: attacker.ship_type_id ?? null,\n            weapon_type_id: attacker.weapon_type_id ?? null,\n          },\n        })\n      )\n    );\n  }\n\n  private async manageCharacterRelationships(\n    killmailId: bigint,\n    involvedCharacters: Array<{\n      character_id: bigint;\n      role: 'attacker' | 'victim';\n    }>,\n    tx: any\n  ): Promise<void> {\n    await tx.killCharacter.deleteMany({\n      where: { killmail_id: killmailId },\n    });\n\n    for (const character of involvedCharacters) {\n      const isTracked = await tx.character.findUnique({\n        where: { eveId: character.character_id },\n        select: { eveId: true },\n      });\n\n      if (isTracked) {\n        await tx.killCharacter.create({\n          data: {\n            killmail_id: killmailId,\n            character_id: character.character_id,\n            role: character.role,\n          },\n        });\n      }\n    }\n  }\n\n  private async createLossFact(\n    killFact: {\n      killmail_id: bigint;\n      kill_time: Date;\n      system_id: number;\n      total_value: bigint;\n      labels: string[];\n    },\n    victim: {\n      character_id?: bigint;\n      ship_type_id: number;\n    },\n    attackers: Array<any>,\n    tx: any\n  ): Promise<void> {\n    if (!victim.character_id) return;\n\n    const isTrackedVictim = await tx.character.findUnique({\n      where: { eveId: victim.character_id },\n      select: { eveId: true },\n    });\n\n    if (isTrackedVictim) {\n      await tx.lossFact.upsert({\n        where: { killmail_id: killFact.killmail_id },\n        create: {\n          killmail_id: killFact.killmail_id,\n          character_id: victim.character_id,\n          kill_time: killFact.kill_time,\n          ship_type_id: victim.ship_type_id,\n          system_id: killFact.system_id,\n          total_value: killFact.total_value,\n          attacker_count: attackers.length,\n          labels: killFact.labels,\n        },\n        update: {\n          kill_time: killFact.kill_time,\n          ship_type_id: victim.ship_type_id,\n          system_id: killFact.system_id,\n          total_value: killFact.total_value,\n          attacker_count: attackers.length,\n          labels: killFact.labels,\n        },\n      });\n    }\n  }\n\n  /**\n   * Get kills for a character within a date range\n   */\n  async getKillsForCharacter(characterId: bigint, startDate: Date, endDate: Date): Promise<any[]> {\n    return this.prisma.killFact.findMany({\n      where: {\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n        characters: {\n          some: {\n            character_id: characterId,\n          },\n        },\n      },\n      include: {\n        attackers: true,\n        victims: true,\n        characters: true,\n      },\n      orderBy: {\n        kill_time: 'desc',\n      },\n    });\n  }\n\n  /**\n   * Get kills for multiple characters within a date range\n   */\n  async getKillsForCharacters(characterIds: bigint[], startDate: Date, endDate: Date): Promise<any[]> {\n    return this.prisma.killFact.findMany({\n      where: {\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n        characters: {\n          some: {\n            character_id: {\n              in: characterIds,\n            },\n          },\n        },\n      },\n      include: {\n        attackers: true,\n        victims: true,\n        characters: true,\n      },\n      orderBy: {\n        kill_time: 'desc',\n      },\n    });\n  }\n\n  /**\n   * Get kills for a character group within a date range\n   */\n  async getKillsForGroup(groupId: string, startDate: Date, endDate: Date): Promise<any[]> {\n    const group = await this.prisma.characterGroup.findUnique({\n      where: { id: groupId },\n      include: { characters: true },\n    });\n\n    if (!group) {\n      return [];\n    }\n\n    const characterIds = group.characters.map(c => c.eveId);\n    return this.getKillsForCharacters(characterIds, startDate, endDate);\n  }\n\n  /**\n   * Check if a killmail exists\n   */\n  async killmailExists(killmailId: bigint): Promise<boolean> {\n    const count = await this.prisma.killFact.count({\n      where: { killmail_id: killmailId },\n    });\n    return count > 0;\n  }\n\n  /**\n   * Get total kill count for a character\n   */\n  async getKillCount(characterId: bigint): Promise<number> {\n    return this.prisma.killCharacter.count({\n      where: {\n        character_id: characterId,\n        role: 'attacker',\n      },\n    });\n  }\n\n  /**\n   * Get total loss count for a character\n   */\n  async getLossCount(characterId: bigint): Promise<number> {\n    return this.prisma.lossFact.count({\n      where: {\n        character_id: characterId,\n      },\n    });\n  }\n\n  /**\n   * Placeholder implementations for chart generators\n   * These can be enhanced later with proper implementations\n   */\n  async getAllKillsForCharacters(characterIds: bigint[], startDate: Date, endDate: Date): Promise<any[]> {\n    return this.getKillsForCharacters(characterIds, startDate, endDate);\n  }\n\n  async getTopShipTypesUsed(_characterIds: bigint[], _startDate: Date, _endDate: Date, _limit = 10): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    void _limit;\n    logger.warn('Method not yet implemented: getTopShipTypesUsed');\n    return [];\n  }\n\n  async getTopEnemyCorporations(\n    _characterIds: bigint[],\n    _startDate: Date,\n    _endDate: Date,\n    _limit = 10\n  ): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    void _limit;\n    logger.warn('Method not yet implemented: getTopEnemyCorporations');\n    return [];\n  }\n\n  async getDistributionData(_characterIds: bigint[], _startDate: Date, _endDate: Date): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    logger.warn('Method not yet implemented: getDistributionData');\n    return [];\n  }\n\n  async getKillActivityByTimeOfDay(_characterIds: bigint[], _startDate: Date, _endDate: Date): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    logger.warn('Method not yet implemented: getKillActivityByTimeOfDay');\n    return [];\n  }\n\n  async getKillsGroupedByTime(\n    _characterIds: bigint[],\n    _startDate: Date,\n    _endDate: Date,\n    _interval: string\n  ): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    void _interval;\n    logger.warn('Method not yet implemented: getKillsGroupedByTime');\n    return [];\n  }\n\n  async getTopShipTypesDestroyed(\n    _characterIds: bigint[],\n    _startDate: Date,\n    _endDate: Date,\n    _limit = 10\n  ): Promise<any[]> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    void _limit;\n    logger.warn('Method not yet implemented: getTopShipTypesDestroyed');\n    return [];\n  }\n\n  async getShipTypesOverTime(\n    _characterIds: bigint[],\n    _startDate: Date,\n    _endDate: Date,\n    _interval: string\n  ): Promise<any> {\n    void _characterIds;\n    void _startDate;\n    void _endDate;\n    void _interval;\n    logger.warn('Method not yet implemented: getShipTypesOverTime');\n    return {};\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/LossRepository.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100000000.","line":50,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":46},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100000000.","line":136,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":136,"endColumn":91}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseRepository } from './BaseRepository';\nimport { logger } from '../../lib/logger';\nimport { LossFact } from '../../domain/killmail/LossFact';\nimport { PrismaMapper } from '../mapper/PrismaMapper';\nimport { buildWhereFilter } from '../../utils/query-helper';\n\n/**\n * Repository for accessing ship loss data\n */\nexport class LossRepository extends BaseRepository {\n  constructor() {\n    super('lossFact');\n  }\n\n  /**\n   * Get total losses for a character in a time period\n   * @param characterId Character EVE ID\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   */\n  async getLossesByCharacter(characterId: bigint, startDate: Date, endDate: Date): Promise<number> {\n    return this.executeQuery(async () => {\n      logger.debug(`Fetching losses for character ${characterId} from ${startDate} to ${endDate}`);\n\n      const where = buildWhereFilter({\n        character_id: characterId,\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n      });\n\n      const result = await this.prisma.lossFact.count({ where });\n\n      return result;\n    });\n  }\n\n  /**\n   * Get high value losses for a character in a time period\n   * @param characterId Character EVE ID\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   * @param valueThreshold Minimum ISK value to be considered high value\n   */\n  async getHighValueLossesByCharacter(\n    characterId: bigint,\n    startDate: Date,\n    endDate: Date,\n    valueThreshold: bigint = BigInt(100000000) // 100M ISK default threshold\n  ): Promise<number> {\n    return this.executeQuery(async () => {\n      logger.debug(`Fetching high value losses for character ${characterId} from ${startDate} to ${endDate}`);\n\n      const where = buildWhereFilter({\n        character_id: characterId,\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n        total_value: {\n          gte: valueThreshold,\n        },\n      });\n\n      const result = await this.prisma.lossFact.count({ where });\n\n      return result;\n    });\n  }\n\n  /**\n   * Get total value lost for a character in a time period\n   * @param characterId Character EVE ID\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   */\n  async getTotalValueLostByCharacter(characterId: bigint, startDate: Date, endDate: Date): Promise<bigint> {\n    return this.executeQuery(async () => {\n      logger.debug(`Fetching total value lost for character ${characterId} from ${startDate} to ${endDate}`);\n\n      const where = buildWhereFilter({\n        character_id: characterId,\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n      });\n\n      const results = await this.prisma.lossFact.findMany({\n        where,\n        select: {\n          total_value: true,\n        },\n      });\n\n      // Sum up the total values\n      return results.reduce((sum, result) => sum + result.total_value, BigInt(0));\n    });\n  }\n\n  /**\n   * Get losses summary for a group of characters\n   * @param characterIds Array of character EVE IDs\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   */\n  async getLossesSummaryByCharacters(\n    characterIds: bigint[],\n    startDate: Date,\n    endDate: Date\n  ): Promise<{\n    totalLosses: number;\n    highValueLosses: number;\n    totalValueLost: bigint;\n  }> {\n    return this.executeQuery(async () => {\n      logger.debug(`Fetching losses summary for ${characterIds.length} characters from ${startDate} to ${endDate}`);\n\n      // Get all losses for these characters\n      const where = buildWhereFilter({\n        character_id: {\n          in: characterIds,\n        },\n        kill_time: {\n          gte: startDate,\n          lte: endDate,\n        },\n      });\n\n      const losses = await this.prisma.lossFact.findMany({ where });\n      const lossFacts = PrismaMapper.mapArray(losses, LossFact);\n\n      // Calculate summary\n      const totalLosses = lossFacts.length;\n      const highValueLosses = lossFacts.filter(loss => loss.totalValue >= BigInt(100000000)).length;\n      const totalValueLost = lossFacts.reduce((sum, loss) => sum + loss.totalValue, BigInt(0));\n\n      return {\n        totalLosses,\n        highValueLosses,\n        totalValueLost,\n      };\n    });\n  }\n\n  /**\n   * Get a loss by killmail ID\n   * @param killmailId Killmail ID to look up\n   */\n  async getLoss(killmailId: bigint): Promise<LossFact | null> {\n    return this.executeQuery(async () => {\n      const loss = await this.prisma.lossFact.findUnique({\n        where: { killmail_id: killmailId },\n      });\n\n      if (!loss) {\n        return null;\n      }\n\n      return PrismaMapper.map(loss, LossFact);\n    });\n  }\n\n  /**\n   * Get all losses for a character\n   * @param characterId Character EVE ID\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   */\n  async getLossesForCharacter(characterId: bigint, startDate: Date, endDate: Date): Promise<LossFact[]> {\n    return this.executeQuery(async () => {\n      const losses = await this.prisma.lossFact.findMany({\n        where: {\n          character_id: characterId,\n          kill_time: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        orderBy: {\n          kill_time: 'desc',\n        },\n      });\n\n      return PrismaMapper.mapArray(losses, LossFact);\n    });\n  }\n\n  /**\n   * Save a loss record\n   * @param loss LossFact domain entity to save\n   */\n  async saveLoss(loss: LossFact): Promise<void> {\n    return this.executeQuery(async () => {\n      // Check if this character is tracked (exists in characters table)\n      const trackedCharacter = await this.prisma.character.findUnique({\n        where: { eveId: loss.characterId },\n        select: { eveId: true },\n      });\n\n      if (!trackedCharacter) {\n        // Skip saving loss for untracked character\n        return;\n      }\n\n      const data = loss.toObject();\n      await this.prisma.lossFact.upsert({\n        where: { killmail_id: loss.killmailId },\n        update: {\n          kill_time: data.killTime,\n          system_id: data.systemId,\n          total_value: data.totalValue,\n          attacker_count: data.attackerCount,\n          labels: data.labels,\n          character_id: data.characterId,\n          ship_type_id: data.shipTypeId,\n        },\n        create: {\n          killmail_id: data.killmailId,\n          kill_time: data.killTime,\n          system_id: data.systemId,\n          total_value: data.totalValue,\n          attacker_count: data.attackerCount,\n          labels: data.labels,\n          character_id: data.characterId,\n          ship_type_id: data.shipTypeId,\n        },\n      });\n    });\n  }\n\n  /**\n   * Delete all loss records\n   */\n  async deleteAllLosses(): Promise<void> {\n    await this.executeQuery(async () => {\n      await this.prisma.lossFact.deleteMany();\n    });\n  }\n\n  /**\n   * Get losses within a time range\n   * @param startDate Start date for query range\n   * @param endDate End date for query range\n   */\n  async getLossesByTimeRange(startDate: Date, endDate: Date): Promise<LossFact[]> {\n    return this.executeQuery(async () => {\n      const losses = await this.prisma.lossFact.findMany({\n        where: {\n          kill_time: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        orderBy: {\n          kill_time: 'desc',\n        },\n      });\n\n      return PrismaMapper.mapArray(losses, LossFact);\n    });\n  }\n\n  /**\n   * Count total loss records\n   */\n  override async count(): Promise<number> {\n    return this.executeQuery(async () => {\n      return this.prisma.lossFact.count();\n    });\n  }\n\n  /**\n   * Get the top ship types lost within a date range\n   */\n  async getTopShipTypesLost(\n    characterIds: (string | bigint)[],\n    startDate: Date,\n    endDate: Date,\n    limit: number = 10\n  ): Promise<Array<{ shipTypeId: string; count: number }>> {\n    return this.executeQuery(async () => {\n      // Find all losses for these characters in the date range\n      const losses = await this.prisma.lossFact.findMany({\n        where: {\n          character_id: {\n            in: characterIds.map(id => BigInt(id)),\n          },\n          kill_time: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        select: {\n          ship_type_id: true,\n        },\n      });\n      // Count occurrences of each ship type\n      const shipTypeCounts = new Map<string, number>();\n      for (const loss of losses) {\n        const shipTypeId = loss.ship_type_id.toString();\n        shipTypeCounts.set(shipTypeId, (shipTypeCounts.get(shipTypeId) ?? 0) + 1);\n      }\n      return Array.from(shipTypeCounts.entries())\n        .map(([shipTypeId, count]) => ({ shipTypeId, count }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, limit);\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/MapActivityRepository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[968,971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[968,971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'getActivityForCharacters' has too many lines (52). Maximum allowed is 50.","line":49,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":107,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2960,2963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2960,2963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'getGroupActivityStats' has too many lines (55). Maximum allowed is 50.","line":175,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":245,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'getActivityGroupedByTime' has too many lines (53). Maximum allowed is 50.","line":250,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":314,"endColumn":4},{"ruleId":"no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":307,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":307,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MapActivity } from '../../domain/activity/MapActivity';\nimport { BaseRepository } from './BaseRepository';\nimport { logger } from '../../lib/logger';\n\n/**\n * Repository for map activity data access\n */\nexport class MapActivityRepository extends BaseRepository {\n  constructor() {\n    super('MapActivity');\n  }\n\n  /**\n   * Get map activity for a character within a date range\n   */\n  async getActivityForCharacter(characterId: string, startDate: Date, endDate: Date): Promise<MapActivity[]> {\n    return this.executeQuery(async () => {\n      const activities = await this.prisma.mapActivity.findMany({\n        where: {\n          characterId: BigInt(characterId),\n          timestamp: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        orderBy: {\n          timestamp: 'desc',\n        },\n      });\n\n      // Map activities with proper field name conversion from snake_case to camelCase\n      return activities.map((activity: any) => {\n        return new MapActivity({\n          characterId: activity.characterId || activity.character_id,\n          timestamp: activity.timestamp,\n          signatures: activity.signatures,\n          connections: activity.connections,\n          passages: activity.passages,\n          allianceId: activity.allianceId || activity.alliance_id,\n          corporationId: activity.corporationId || activity.corporation_id,\n        });\n      });\n    });\n  }\n\n  /**\n   * Get map activity for multiple characters within a date range\n   */\n  async getActivityForCharacters(characterIds: string[], startDate: Date, endDate: Date): Promise<MapActivity[]> {\n    return this.executeQuery(async () => {\n      // Filter out invalid character IDs and convert valid ones to BigInt\n      const validCharacterIds = characterIds\n        .filter(id => id && id !== '' && id !== 'undefined' && id !== 'null')\n        .map(id => {\n          try {\n            return BigInt(id);\n          } catch (error) {\n            logger.warn(`Invalid character ID for BigInt conversion: ${id}`);\n            return null;\n          }\n        })\n        .filter((id): id is bigint => id !== null);\n\n      if (validCharacterIds.length === 0) {\n        logger.warn('No valid character IDs provided to getActivityForCharacters');\n        return [];\n      }\n\n      logger.debug(`Querying map activity for ${validCharacterIds.length} valid character IDs`);\n\n      const activities = await this.prisma.mapActivity.findMany({\n        where: {\n          characterId: {\n            in: validCharacterIds,\n          },\n          timestamp: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        orderBy: {\n          timestamp: 'desc',\n        },\n      });\n\n      logger.debug(`Raw activities from database:`, activities.slice(0, 2)); // Log first 2 records\n\n      try {\n        // Map activities with proper field name conversion from snake_case to camelCase\n        return activities.map((activity: any) => {\n          return new MapActivity({\n            characterId: activity.characterId || activity.character_id,\n            timestamp: activity.timestamp,\n            signatures: activity.signatures,\n            connections: activity.connections,\n            passages: activity.passages,\n            allianceId: activity.allianceId || activity.alliance_id,\n            corporationId: activity.corporationId || activity.corporation_id,\n          });\n        });\n      } catch (error) {\n        logger.error(`Error mapping activities to MapActivity domain objects:`, error);\n        logger.error(`Sample raw activity data:`, activities.slice(0, 1));\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Get map activity for a character group within a date range\n   */\n  async getActivityForGroup(groupId: string, startDate: Date, endDate: Date): Promise<MapActivity[]> {\n    return this.executeQuery(async () => {\n      // First, get all characters in the group\n      const group = await this.prisma.characterGroup.findUnique({\n        where: { id: groupId },\n        include: { characters: true },\n      });\n\n      if (!group) {\n        return [];\n      }\n\n      // Get character IDs and convert to strings\n      const characterIds = group.characters.map(c => c.eveId.toString());\n\n      // Get activity for all characters\n      return this.getActivityForCharacters(characterIds, startDate, endDate);\n    });\n  }\n\n  /**\n   * Get map activity statistics for a character\n   */\n  async getActivityStats(\n    characterId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<{\n    totalSystems: number;\n    totalSignatures: number;\n    averageSignaturesPerSystem: number;\n  }> {\n    return this.executeQuery(async () => {\n      const activities = await this.getActivityForCharacter(characterId, startDate, endDate);\n\n      if (activities.length === 0) {\n        return {\n          totalSystems: 0,\n          totalSignatures: 0,\n          averageSignaturesPerSystem: 0,\n        };\n      }\n\n      // Count unique activities as a proxy for systems since systemId doesn't exist\n      const uniqueSystems = activities.length;\n\n      // Sum total signatures\n      const totalSignatures = activities.reduce((sum, a) => sum + a.signatures, 0);\n\n      // Calculate average\n      const averageSignaturesPerSystem = uniqueSystems > 0 ? totalSignatures / uniqueSystems : 0;\n\n      return {\n        totalSystems: uniqueSystems,\n        totalSignatures,\n        averageSignaturesPerSystem,\n      };\n    });\n  }\n\n  /**\n   * Get map activity statistics for a character group\n   */\n  async getGroupActivityStats(\n    groupId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<{\n    totalSystems: number;\n    totalSignatures: number;\n    averageSignaturesPerSystem: number;\n  }> {\n    logger.info(\n      `Getting map activity stats for group ${groupId} from ${startDate.toISOString()} to ${endDate.toISOString()}`\n    );\n\n    return this.executeQuery(async () => {\n      // First, get all characters in the group\n      const group = await this.prisma.characterGroup.findUnique({\n        where: { id: groupId },\n        include: { characters: true },\n      });\n\n      if (!group) {\n        logger.warn(`Group ${groupId} not found`);\n        return {\n          totalSystems: 0,\n          totalSignatures: 0,\n          averageSignaturesPerSystem: 0,\n        };\n      }\n\n      // Get character IDs\n      const characterIds = group.characters.map(c => c.eveId);\n      logger.info(`Group ${groupId} has ${characterIds.length} characters: ${characterIds.join(', ')}`);\n\n      if (characterIds.length === 0) {\n        logger.warn(`Group ${groupId} has no characters`);\n        return {\n          totalSystems: 0,\n          totalSignatures: 0,\n          averageSignaturesPerSystem: 0,\n        };\n      }\n\n      const activities = await this.getActivityForGroup(groupId, startDate, endDate);\n\n      if (activities.length === 0) {\n        logger.warn(`No map activities found for group ${groupId}`);\n        return {\n          totalSystems: 0,\n          totalSignatures: 0,\n          averageSignaturesPerSystem: 0,\n        };\n      }\n\n      logger.info(`Found ${activities.length} map activities for group ${groupId}`);\n\n      // Count unique activities as a proxy for systems since systemId doesn't exist\n      const uniqueSystems = activities.length;\n\n      // Sum total signatures\n      const totalSignatures = activities.reduce((sum, a) => sum + a.signatures, 0);\n\n      // Calculate average\n      const averageSignaturesPerSystem = uniqueSystems > 0 ? totalSignatures / uniqueSystems : 0;\n\n      return {\n        totalSystems: uniqueSystems,\n        totalSignatures,\n        averageSignaturesPerSystem,\n      };\n    });\n  }\n\n  /**\n   * Get map activity grouped by time period for chart data\n   */\n  async getActivityGroupedByTime(\n    characterIds: string[],\n    startDate: Date,\n    endDate: Date,\n    groupBy: 'hour' | 'day' | 'week' = 'day'\n  ): Promise<Array<{ timestamp: Date; signatures: number; systems: number }>> {\n    return this.executeQuery(async () => {\n      // Get all activity for the characters\n      const activities = await this.getActivityForCharacters(characterIds, startDate, endDate);\n\n      // Group by time period\n      const timeMap = new Map<\n        string,\n        {\n          timestamp: Date;\n          signatures: number;\n          systems: Set<string>; // Use a string combination of characterId+timestamp as unique identifier\n        }\n      >();\n\n      // Format string for grouping\n      const getTimeKey = (date: Date): string => {\n        switch (groupBy) {\n          case 'hour':\n            return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}-${date.getHours()}`;\n          case 'week': {\n            const d = new Date(date);\n            d.setDate(d.getDate() - d.getDay()); // Start of week (Sunday)\n            return `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;\n          }\n          case 'day':\n          default:\n            return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;\n        }\n      };\n\n      // Group the activities\n      for (const activity of activities) {\n        const timeKey = getTimeKey(activity.timestamp);\n\n        if (!timeMap.has(timeKey)) {\n          timeMap.set(timeKey, {\n            timestamp: new Date(activity.timestamp),\n            signatures: 0,\n            systems: new Set<string>(),\n          });\n        }\n\n        const group = timeMap.get(timeKey);\n        if (!group) continue;\n        group.signatures += activity.signatures;\n        // Use a composite key since systemId doesn't exist\n        group.systems.add(`${activity.characterId}-${activity.timestamp.toISOString()}`);\n      }\n\n      // Convert to array and sort by timestamp\n      return Array.from(timeMap.entries())\n        .map(([_, group]) => ({\n          timestamp: group.timestamp,\n          signatures: group.signatures,\n          systems: group.systems.size,\n        }))\n        .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n    });\n  }\n\n  /**\n   * Create or update a map activity record\n   */\n  async upsertMapActivity(\n    characterId: bigint,\n    timestamp: Date,\n    signatures: number,\n    connections: number,\n    passages: number,\n    allianceId: number | null,\n    corporationId: number | null\n  ): Promise<void> {\n    await this.prisma.mapActivity.upsert({\n      where: {\n        characterId_timestamp: {\n          characterId,\n          timestamp,\n        },\n      },\n      update: {\n        signatures,\n        connections,\n        passages,\n        allianceId: allianceId ?? undefined,\n        corporationId: corporationId ?? 0,\n      },\n      create: {\n        characterId,\n        timestamp,\n        signatures,\n        connections,\n        passages,\n        allianceId: allianceId ?? undefined,\n        corporationId: corporationId ?? 0,\n      },\n    });\n  }\n\n  /**\n   * Delete all map activity records\n   */\n  async deleteAllMapActivity(): Promise<void> {\n    await this.executeQuery(async () => {\n      await this.prisma.mapActivity.deleteMany();\n    });\n  }\n\n  /**\n   * Count total map activity records\n   */\n  override async count(): Promise<number> {\n    return this.executeQuery(async () => {\n      return this.prisma.mapActivity.count();\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/RepositoryManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/repositories/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/infrastructure/utils/retry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/circuit-breaker/CircuitBreaker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/chartHandlers.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":102,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3606,3609],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3606,3609],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":152,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4956,4959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4956,4959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { logger } from '../logger';\nimport { ChartService } from '../../services/ChartService';\nimport { ChartRenderer } from '../../services/ChartRenderer';\nimport { ChartsCommandHandler } from './handlers/ChartsCommandHandler';\n\nconst chartService = new ChartService();\nconst chartRenderer = new ChartRenderer();\nconst chartsCommandHandler = new ChartsCommandHandler();\n\n/**\n * Main handler for the /charts command and its subcommands\n * Delegates to the new handler system\n */\nexport async function handleChartsCommand(interaction: CommandInteraction) {\n  // Use the new command handler\n  await chartsCommandHandler.handle(interaction);\n}\n\n// Legacy handlers kept for backward compatibility\nexport async function handleKillsCommand(interaction: CommandInteraction) {\n  if (!interaction.isChatInputCommand()) return;\n\n  try {\n    logger.info('Legacy /kills command used - consider using /charts kills instead');\n\n    // Get the display type from options\n    const displayType = interaction.options.getString('type') ?? 'line';\n\n    await handleLegacyKillCommand(interaction, displayType);\n  } catch (error) {\n    logger.error('Error handling legacy kill command:', error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    if (interaction.replied) {\n      await interaction.followUp({\n        content: `Error generating kill chart: ${errorMessage}`,\n        ephemeral: true,\n      });\n    } else if (interaction.deferred) {\n      await interaction.editReply({\n        content: `Error generating kill chart: ${errorMessage}`,\n      });\n    } else {\n      await interaction.reply({\n        content: `Error generating kill chart: ${errorMessage}`,\n        ephemeral: true,\n      });\n    }\n  }\n}\n\nexport async function handleMapCommand(interaction: CommandInteraction) {\n  if (!interaction.isChatInputCommand()) return;\n\n  try {\n    logger.info('Legacy /map command used - consider using /charts map instead');\n\n    // Get the display type from options\n    const displayType = interaction.options.getString('type') ?? 'line';\n\n    await handleLegacyMapCommand(interaction, displayType);\n  } catch (error) {\n    logger.error('Error handling legacy map command:', error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    if (interaction.replied) {\n      await interaction.followUp({\n        content: `Error generating map chart: ${errorMessage}`,\n        ephemeral: true,\n      });\n    } else if (interaction.deferred) {\n      await interaction.editReply({\n        content: `Error generating map chart: ${errorMessage}`,\n      });\n    } else {\n      await interaction.reply({\n        content: `Error generating map chart: ${errorMessage}`,\n        ephemeral: true,\n      });\n    }\n  }\n}\n\n// Helper function for legacy kill command\nasync function handleLegacyKillCommand(interaction: CommandInteraction, displayType: string) {\n  await interaction.deferReply();\n\n  // Get tracked characters\n  const characterIds = await getTrackedCharacters();\n\n  if (characterIds.length === 0) {\n    await interaction.editReply({\n      content: 'No characters are currently being tracked. Please add characters first.',\n    });\n    return;\n  }\n\n  // Generate time range (default to 7 days for legacy commands)\n  const endDate = new Date();\n  const startDate = new Date();\n  startDate.setDate(endDate.getDate() - 7);\n\n  // Generate chart using legacy chart service\n  const chartData = await chartService.generateChart({\n    type: 'kills',\n    characterIds,\n    period: '7d',\n    displayType: displayType as any,\n  });\n\n  // Render chart\n  const buffer = await chartRenderer.renderToBuffer(chartData, {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: `Kills - Last 7 days`,\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n    },\n  });\n\n  // Send chart\n  await interaction.editReply({\n    content: 'Here is your kill chart (consider using /charts kills for enhanced charts):',\n    files: [{ attachment: buffer, name: 'kill-chart.png' }],\n  });\n}\n\n// Helper function for legacy map command\nasync function handleLegacyMapCommand(interaction: CommandInteraction, displayType: string) {\n  await interaction.deferReply();\n\n  // Get tracked characters\n  const characterIds = await getTrackedCharacters();\n\n  if (characterIds.length === 0) {\n    await interaction.editReply({\n      content: 'No characters are currently being tracked. Please add characters first.',\n    });\n    return;\n  }\n\n  // Generate time range (default to 7 days for legacy commands)\n  const endDate = new Date();\n  const startDate = new Date();\n  startDate.setDate(endDate.getDate() - 7);\n\n  // Generate chart using legacy chart service\n  const chartData = await chartService.generateChart({\n    type: 'map_activity',\n    characterIds,\n    period: '7d',\n    displayType: displayType as any,\n  });\n\n  // Render chart\n  const buffer = await chartRenderer.renderToBuffer(chartData, {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: `Map Activity - Last 7 days`,\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n    },\n  });\n\n  // Send chart\n  await interaction.editReply({\n    content: 'Here is your map activity chart (consider using /charts map for enhanced charts):',\n    files: [{ attachment: buffer, name: 'map-chart.png' }],\n  });\n}\n\n// Helper function for getting character data\nasync function getTrackedCharacters(): Promise<bigint[]> {\n  const characters = await chartService.getTrackedCharacters();\n  return characters.map(c => BigInt(c.eveId));\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/client.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'setupEventHandlers' has too many lines (142). Maximum allowed is 50.","line":19,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":186,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1546,1549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1546,1549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async arrow function has too many lines (91). Maximum allowed is 50.","line":58,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":156,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Async arrow function has a complexity of 13. Maximum allowed is 10.","line":58,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":156,"endColumn":6},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":177,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":177,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":77},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":192,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":192,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7182,7185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7182,7185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7305,7308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7305,7308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Client, GatewayIntentBits, Events, Partials, MessageFlags } from 'discord.js';\nimport { logger } from '../logger';\nimport { handleKillsCommand, handleMapCommand } from './handlers';\nimport { handleChartsCommand } from './chartHandlers';\nimport { handleValidatedChartsCommand } from './validatedChartHandlers';\n\nexport class DiscordClient {\n  public client: Client;\n\n  constructor() {\n    this.client = new Client({\n      intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages],\n      partials: [Partials.Channel, Partials.Message, Partials.User],\n    });\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers() {\n    // Debug logging for all Discord events\n    this.client.on(Events.ClientReady, () => {\n      logger.info(`Bot logged in as ${this.client.user?.tag}`);\n      logger.info(`Bot is in ${this.client.guilds.cache.size} guilds`);\n      this.client.guilds.cache.forEach(guild => {\n        logger.info(`Guild: ${guild.name} (${guild.id})`);\n        // Log guild channels\n        guild.channels.cache.forEach(channel => {\n          logger.info(`Channel in ${guild.name}: ${channel.name} (${channel.id})`);\n        });\n      });\n    });\n\n    this.client.on(Events.Error, error => {\n      // Log the raw error first\n      logger.error('Raw Discord error:', error);\n\n      // Then log the formatted error\n      if (error instanceof Error) {\n        logger.error('Discord error details:', {\n          message: error.message,\n          name: error.name,\n          stack: error.stack,\n          code: (error as any).code,\n        });\n      } else {\n        logger.error('Unknown error type:', error);\n      }\n    });\n\n    this.client.on(Events.Debug, info => {\n      logger.debug(`Discord debug: ${info}`);\n    });\n\n    this.client.on(Events.Warn, info => {\n      logger.warn('Discord warning:', info);\n    });\n\n    this.client.on(Events.InteractionCreate, async interaction => {\n      logger.info('Received interaction:', {\n        type: interaction.type,\n        isCommand: interaction.isCommand(),\n        commandName: interaction.isCommand() ? interaction.commandName : undefined,\n        user: interaction.user.tag,\n        guild: interaction.guild?.name,\n        channel: interaction.channel?.id,\n        options: interaction.isCommand() ? interaction.options.data : undefined,\n        interactionId: interaction.id,\n        applicationId: interaction.applicationId,\n        token: interaction.token,\n      });\n\n      if (!interaction.isCommand()) {\n        logger.debug('Received non-command interaction:', {\n          type: interaction.type,\n          user: interaction.user.tag,\n        });\n        return;\n      }\n\n      try {\n        logger.info(`Processing command: ${interaction.commandName}`);\n\n        // Add more detailed logging to help debug why charts command isn't recognized\n        logger.info(`Command type: ${typeof interaction.commandName}`);\n        logger.info(`Command handlers available:`, {\n          killsHandler: typeof handleKillsCommand === 'function',\n          mapHandler: typeof handleMapCommand === 'function',\n          chartsHandler: typeof handleChartsCommand === 'function',\n        });\n\n        // Debug log all available commands\n        logger.info(`Available commands in switch:`, ['kills', 'map', 'charts']);\n\n        switch (interaction.commandName) {\n          case 'kills':\n            logger.info('Handling kills command');\n            await handleKillsCommand(interaction);\n            break;\n          case 'map':\n            logger.info('Handling map command');\n            await handleMapCommand(interaction);\n            break;\n          case 'charts':\n            logger.info('Handling charts command with validation');\n            await handleValidatedChartsCommand(interaction);\n            break;\n          default:\n            logger.warn(`Unknown command: ${interaction.commandName}`);\n            await interaction.reply({\n              content: 'Unknown command',\n              flags: MessageFlags.Ephemeral,\n            });\n        }\n      } catch (error) {\n        logger.error('Error handling command:', {\n          error:\n            error instanceof Error\n              ? {\n                  message: error.message,\n                  name: error.name,\n                  stack: error.stack,\n                }\n              : error,\n          commandName: interaction.commandName,\n          user: interaction.user.tag,\n        });\n        const errorMessage = 'Sorry, there was an error processing your command.';\n\n        try {\n          if (interaction.replied || interaction.deferred) {\n            await interaction.followUp({\n              content: errorMessage,\n              flags: MessageFlags.Ephemeral,\n            });\n          } else {\n            await interaction.reply({\n              content: errorMessage,\n              flags: MessageFlags.Ephemeral,\n            });\n          }\n        } catch (followupError) {\n          logger.error('Error sending error response:', {\n            error:\n              followupError instanceof Error\n                ? {\n                    message: followupError.message,\n                    name: followupError.name,\n                    stack: followupError.stack,\n                  }\n                : followupError,\n            commandName: interaction.commandName,\n            user: interaction.user.tag,\n          });\n        }\n      }\n    });\n\n    // Add logging for guild events\n    this.client.on(Events.GuildCreate, guild => {\n      logger.info(`Joined guild: ${guild.name} (${guild.id})`);\n    });\n\n    this.client.on(Events.GuildDelete, guild => {\n      logger.info(`Left guild: ${guild.name} (${guild.id})`);\n    });\n\n    // Add logging for message events\n    this.client.on(Events.MessageCreate, message => {\n      // Only log messages that might be commands (starting with !) or are from bot mentions\n      // Or are direct messages to the bot\n      const isBotMentioned = message.mentions.users.has(this.client.user?.id ?? '');\n      const isDirectMessage = !message.guild;\n      const isPotentialCommand = message.content.startsWith('!');\n\n      if (isBotMentioned || isDirectMessage || isPotentialCommand) {\n        const truncatedContent =\n          message.content.length > 100 ? `${message.content.substring(0, 100)}...` : message.content;\n\n        logger.debug(\n          `Discord message received: \"${truncatedContent}\" from ${\n            message.author.tag\n          } in ${message.guild?.name ?? 'DM'} (${message.channel.id})`\n        );\n      }\n    });\n  }\n\n  async login(token: string) {\n    try {\n      logger.debug('Discord login attempt', {\n        tokenLength: token.length,\n        tokenPrefix: token.substring(0, 10),\n      });\n\n      await this.client.login(token);\n      logger.info('Successfully logged in to Discord');\n    } catch (error) {\n      logger.error('Failed to login to Discord', {\n        errorType: typeof error,\n        errorProperties: Object.getOwnPropertyNames(error),\n        error:\n          error instanceof Error\n            ? {\n                message: error.message,\n                name: error.name,\n                stack: error.stack,\n                code: (error as any).code,\n              }\n            : error,\n      });\n      throw error;\n    }\n  }\n\n  async registerCommands(commands: any[]) {\n    try {\n      // Wait for client to be ready before registering commands\n      if (!this.client.isReady()) {\n        logger.info('Waiting for client to be ready before registering commands');\n        await new Promise<void>(resolve => {\n          this.client.once(Events.ClientReady, () => resolve());\n        });\n      }\n\n      const application = this.client.application;\n      if (!application) {\n        throw new Error('Application not available');\n      }\n\n      // Convert commands to JSON format\n      const jsonCommands = commands.map(cmd => cmd.toJSON());\n      logger.info(\n        'Registering commands:',\n        jsonCommands.map(cmd => cmd.name)\n      );\n      await application.commands.set(jsonCommands);\n      logger.info('Successfully registered application commands');\n    } catch (error) {\n      logger.error('Failed to register commands:', {\n        error:\n          error instanceof Error\n            ? {\n                message: error.message,\n                name: error.name,\n                stack: error.stack,\n              }\n            : error,\n      });\n      throw error;\n    }\n  }\n\n  // Helper methods to expose client state\n  isReady(): boolean {\n    return this.client.isReady();\n  }\n\n  getGuildsCount(): number {\n    return this.client.guilds.cache.size;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/commands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'handleKillsCommand' has too many lines (96). Maximum allowed is 50.","line":12,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":129,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":56,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":40},{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'handleMapCommand' has too many lines (96). Maximum allowed is 50.","line":131,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":248,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":175,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":175,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { PrismaClient } from '@prisma/client';\nimport { logger } from '../logger';\nimport { ChartService } from '../../services/ChartService';\nimport { ChartRenderer } from '../../services/ChartRenderer';\nimport { ChartOptions } from '../../types/chart';\n\nconst prisma = new PrismaClient();\nconst chartService = new ChartService();\nconst chartRenderer = new ChartRenderer();\n\nexport async function handleKillsCommand(interaction: CommandInteraction) {\n  try {\n    logger.info('Handling kills command with default values');\n\n    // Get chart type option if provided\n    const chartType = (interaction.options.get('type')?.value as string) ?? 'line';\n    logger.info(`Using chart type: ${chartType}`);\n\n    // Defer reply since chart generation might take a while\n    logger.info('Deferring kill command reply');\n    await interaction.deferReply();\n    logger.info('Successfully deferred reply');\n\n    // Get all tracked characters\n    logger.info('Fetching all tracked characters');\n    const groups = await prisma.characterGroup.findMany({\n      where: {\n        mainCharacterId: { not: null },\n      },\n      include: {\n        mainCharacter: true,\n      },\n    });\n\n    // Extract main characters from groups\n    const characters = groups\n      .map(group => group.mainCharacter)\n      .filter((char): char is NonNullable<typeof char> => char !== null);\n\n    logger.info('Found tracked characters:', {\n      characterCount: characters.length,\n      characters: characters.map(c => ({ id: c.eveId, name: c.name })),\n    });\n\n    if (characters.length === 0) {\n      await interaction.editReply({\n        content: 'No characters found to generate chart for. Please add some characters first.',\n      });\n      return;\n    }\n\n    // Calculate time range (default to 7 days)\n    const now = new Date();\n    const startTime = new Date(now);\n    startTime.setDate(now.getDate() - 7);\n\n    logger.info('Calculated time range:', {\n      startTime,\n      endTime: now,\n    });\n\n    // Generate chart data\n    const chartData = await chartService.generateChart({\n      type: 'kills',\n      characterIds: characters.map(c => BigInt(c.eveId)),\n      period: '7d',\n      groupBy: 'day',\n      displayType: chartType as 'line' | 'bar',\n    });\n\n    // Create chart options\n    const options: ChartOptions = {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Kills - Last 7 Days',\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n    };\n\n    // Render chart to buffer\n    const buffer = await chartRenderer.renderToBuffer(chartData, options);\n\n    // Send the chart\n    await interaction.editReply({\n      files: [\n        {\n          attachment: buffer,\n          name: 'kills-chart.png',\n        },\n      ],\n    });\n    logger.info('Successfully sent kill chart');\n  } catch (error) {\n    logger.error('Error handling kills command:', {\n      error:\n        error instanceof Error\n          ? {\n              message: error.message,\n              name: error.name,\n              stack: error.stack,\n            }\n          : error,\n      interaction: {\n        id: interaction.id,\n        commandName: interaction.commandName,\n        user: interaction.user.tag,\n      },\n    });\n    // Don't throw the error, handle it gracefully\n    if (!interaction.replied && !interaction.deferred) {\n      await interaction.reply({\n        content: 'An error occurred while processing your command.',\n        ephemeral: true,\n      });\n    } else {\n      await interaction.editReply({\n        content: 'An error occurred while processing your command.',\n      });\n    }\n  }\n}\n\nexport async function handleMapCommand(interaction: CommandInteraction) {\n  try {\n    logger.info('Handling map command with default values');\n\n    // Get chart type option if provided\n    const chartType = (interaction.options.get('type')?.value as string) ?? 'line';\n    logger.info(`Using chart type: ${chartType}`);\n\n    // Defer reply since chart generation might take a while\n    logger.info('Deferring map command reply');\n    await interaction.deferReply();\n    logger.info('Successfully deferred reply');\n\n    // Get all tracked characters\n    logger.info('Fetching all tracked characters');\n    const groups = await prisma.characterGroup.findMany({\n      where: {\n        mainCharacterId: { not: null },\n      },\n      include: {\n        mainCharacter: true,\n      },\n    });\n\n    // Extract main characters from groups\n    const characters = groups\n      .map(group => group.mainCharacter)\n      .filter((char): char is NonNullable<typeof char> => char !== null);\n\n    logger.info('Found tracked characters:', {\n      characterCount: characters.length,\n      characters: characters.map(c => ({ id: c.eveId, name: c.name })),\n    });\n\n    if (characters.length === 0) {\n      await interaction.editReply({\n        content: 'No characters found to generate chart for. Please add some characters first.',\n      });\n      return;\n    }\n\n    // Calculate time range (default to 24 hours)\n    const now = new Date();\n    const startTime = new Date(now);\n    startTime.setHours(now.getHours() - 24);\n\n    logger.info('Calculated time range:', {\n      startTime,\n      endTime: now,\n    });\n\n    // Generate chart data\n    const chartData = await chartService.generateChart({\n      type: 'map_activity',\n      characterIds: characters.map(c => BigInt(c.eveId)),\n      period: '24h',\n      groupBy: 'hour',\n      displayType: chartType as 'line' | 'bar',\n    });\n\n    // Create chart options\n    const options: ChartOptions = {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Map Activity - Last 24 Hours',\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n    };\n\n    // Render chart to buffer\n    const buffer = await chartRenderer.renderToBuffer(chartData, options);\n\n    // Send the chart\n    await interaction.editReply({\n      files: [\n        {\n          attachment: buffer,\n          name: 'map-activity-chart.png',\n        },\n      ],\n    });\n    logger.info('Successfully sent map activity chart');\n  } catch (error) {\n    logger.error('Error handling map command:', {\n      error:\n        error instanceof Error\n          ? {\n              message: error.message,\n              name: error.name,\n              stack: error.stack,\n            }\n          : error,\n      interaction: {\n        id: interaction.id,\n        commandName: interaction.commandName,\n        user: interaction.user.tag,\n      },\n    });\n    // Don't throw the error, handle it gracefully\n    if (!interaction.replied && !interaction.deferred) {\n      await interaction.reply({\n        content: 'An error occurred while processing your command.',\n        ephemeral: true,\n      });\n    } else {\n      await interaction.editReply({\n        content: 'An error occurred while processing your command.',\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/ChartsCommandHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/SecurityMonitorHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0x00aa00.","line":55,"column":83,"nodeType":"Literal","messageId":"noMagic","endLine":55,"endColumn":91},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":84,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":84,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -10.","line":85,"column":50,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":85,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0xffaa00.","line":108,"column":86,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":94},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3581,3584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3581,3584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":114,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":114,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -5.","line":116,"column":50,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":116,"endColumn":52},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":134,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":55},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0xff0000.","line":155,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":155,"endColumn":81},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":162,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":173,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":173,"endColumn":84}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction, MessageFlags, EmbedBuilder } from 'discord.js';\nimport { logger } from '../../logger';\nimport { redis } from '../../../infrastructure/cache/redis-client';\n\n/**\n * Handler for security monitoring commands (admin only)\n */\nexport class SecurityMonitorHandler {\n  private readonly ADMIN_USER_IDS = process.env.ADMIN_USER_IDS?.split(',') ?? [];\n\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    // Check if user is admin\n    if (!this.isAdmin(interaction.user.id)) {\n      await interaction.reply({\n        content: 'You do not have permission to use this command.',\n        flags: MessageFlags.Ephemeral,\n      });\n      return;\n    }\n\n    const subcommand = interaction.options.getSubcommand();\n\n    try {\n      await interaction.deferReply({ flags: MessageFlags.Ephemeral });\n\n      switch (subcommand) {\n        case 'status':\n          await this.handleStatus(interaction);\n          break;\n        case 'suspicious':\n          await this.handleSuspicious(interaction);\n          break;\n        case 'blocked':\n          await this.handleBlocked(interaction);\n          break;\n        case 'unblock':\n          await this.handleUnblock(interaction);\n          break;\n        default:\n          await interaction.editReply('Unknown security subcommand');\n      }\n    } catch (error) {\n      logger.error('Error in security monitor handler:', error);\n      await interaction.editReply('An error occurred while processing the command.');\n    }\n  }\n\n  private isAdmin(userId: string): boolean {\n    return this.ADMIN_USER_IDS.includes(userId);\n  }\n\n  private async handleStatus(interaction: CommandInteraction): Promise<void> {\n    const embed = new EmbedBuilder().setTitle('Security Monitor Status').setColor(0x00aa00).setTimestamp();\n\n    // Get rate limit stats\n    const userLimitKeys = await redis.keys('ratelimit:*');\n    const guildLimitKeys = await redis.keys('guild:*');\n    const suspiciousKeys = await redis.keys('suspicious:*');\n\n    embed.addFields([\n      {\n        name: 'Rate Limits',\n        value: `Active user limits: ${userLimitKeys.length}\\nActive guild limits: ${guildLimitKeys.length}\\nSuspicious users: ${suspiciousKeys.length}`,\n        inline: true,\n      },\n    ]);\n\n    // Get blocked users count\n    const blockedKeys = await redis.keys('security:abuse:blocked:*');\n    embed.addFields([\n      {\n        name: 'Blocked Users',\n        value: `Currently blocked: ${blockedKeys.length}`,\n        inline: true,\n      },\n    ]);\n\n    // Get recent suspicious activity count\n    const recentSuspicious = await redis.keys('security:suspicious:*');\n    let highSeverityCount = 0;\n\n    for (const key of recentSuspicious.slice(0, 10)) {\n      const activities = await redis.zrange(key, -10, -1);\n      for (const activity of activities) {\n        try {\n          const parsed = JSON.parse(activity);\n          if (parsed.severity === 'high') highSeverityCount++;\n        } catch (e) {\n          // Ignore parse errors\n        }\n      }\n    }\n\n    embed.addFields([\n      {\n        name: 'Recent Activity',\n        value: `High severity incidents: ${highSeverityCount}`,\n        inline: true,\n      },\n    ]);\n\n    await interaction.editReply({ embeds: [embed] });\n  }\n\n  private async handleSuspicious(interaction: CommandInteraction): Promise<void> {\n    const embed = new EmbedBuilder().setTitle('Recent Suspicious Activity').setColor(0xffaa00).setTimestamp();\n\n    const suspiciousKeys = await redis.keys('security:suspicious:*');\n    const recentActivities: any[] = [];\n\n    // Get recent suspicious activities\n    for (const key of suspiciousKeys.slice(0, 5)) {\n      const userId = key.split(':').pop();\n      const activities = await redis.zrange(key, -5, -1);\n\n      for (const activity of activities) {\n        try {\n          const parsed = JSON.parse(activity);\n          recentActivities.push({\n            ...parsed,\n            userId,\n          });\n        } catch (e) {\n          // Ignore parse errors\n        }\n      }\n    }\n\n    // Sort by timestamp and take most recent\n    recentActivities.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n    const topActivities = recentActivities.slice(0, 10);\n\n    if (topActivities.length === 0) {\n      embed.setDescription('No recent suspicious activity detected.');\n    } else {\n      for (const activity of topActivities) {\n        const timestamp = new Date(activity.timestamp).toLocaleTimeString();\n        embed.addFields([\n          {\n            name: `${activity.username} (${activity.userId})`,\n            value: `Pattern: ${activity.pattern}\\nSeverity: ${activity.severity}\\nTime: ${timestamp}`,\n            inline: false,\n          },\n        ]);\n      }\n    }\n\n    await interaction.editReply({ embeds: [embed] });\n  }\n\n  private async handleBlocked(interaction: CommandInteraction): Promise<void> {\n    const embed = new EmbedBuilder().setTitle('Blocked Users').setColor(0xff0000).setTimestamp();\n\n    const blockedKeys = await redis.keys('security:abuse:blocked:*');\n\n    if (blockedKeys.length === 0) {\n      embed.setDescription('No users are currently blocked.');\n    } else {\n      for (const key of blockedKeys.slice(0, 10)) {\n        const userId = key.split(':').pop();\n        const blockData = await redis.get(key);\n\n        if (blockData) {\n          try {\n            const parsed = JSON.parse(blockData);\n            const ttl = await redis.ttl(key);\n            embed.addFields([\n              {\n                name: `User ID: ${userId}`,\n                value: `Reason: ${parsed.reason}\\nExpires in: ${Math.floor(ttl / 60)} minutes`,\n                inline: false,\n              },\n            ]);\n          } catch (e) {\n            // Ignore parse errors\n          }\n        }\n      }\n    }\n\n    await interaction.editReply({ embeds: [embed] });\n  }\n\n  private async handleUnblock(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) {\n      await interaction.editReply('This command can only be used as a chat input command.');\n      return;\n    }\n\n    const userId = interaction.options.getString('user');\n\n    if (!userId) {\n      await interaction.editReply('Please provide a user ID to unblock.');\n      return;\n    }\n\n    const key = `security:abuse:blocked:${userId}`;\n    const existed = await redis.del(key);\n\n    if (existed) {\n      logger.info(`User ${userId} unblocked by ${interaction.user.tag}`);\n      await interaction.editReply(`Successfully unblocked user ${userId}.`);\n    } else {\n      await interaction.editReply(`User ${userId} was not blocked.`);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/ValidatedChartsCommandHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/BaseChartHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":36,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":36,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3282,3285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3282,3285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { ChartFactory } from '../../../../services/charts';\nimport { CharacterRepository } from '../../../../infrastructure/repositories/CharacterRepository';\nimport { logger } from '../../../logger';\nimport { RepositoryManager } from '../../../../infrastructure/repositories/RepositoryManager';\nimport { CharacterGroup } from '../../../../domain/character/CharacterGroup';\nimport { MessageFlags } from 'discord.js';\n\n/**\n * Base class for all chart command handlers\n */\nexport abstract class BaseChartHandler {\n  protected chartFactory: ChartFactory;\n  protected characterRepository: CharacterRepository;\n  protected repositoryManager: RepositoryManager;\n\n  constructor() {\n    this.repositoryManager = new RepositoryManager();\n    this.chartFactory = new ChartFactory();\n    this.characterRepository = this.repositoryManager.getCharacterRepository();\n  }\n\n  /**\n   * Handle a chart command interaction\n   * This method must be implemented by all chart handlers\n   */\n  abstract handle(interaction: CommandInteraction): Promise<void>;\n\n  /**\n   * Convert a time period string to date range\n   */\n  protected getTimeRange(timePeriod: string = '7'): {\n    startDate: Date;\n    endDate: Date;\n  } {\n    const days = parseInt(timePeriod, 10) || 7;\n    const endDate = new Date();\n    const startDate = new Date();\n    startDate.setDate(endDate.getDate() - days);\n\n    return { startDate, endDate };\n  }\n\n  /**\n   * Get all character groups from database and transform them into the format expected by chart generators\n   */\n  protected async getCharacterGroups(): Promise<\n    Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{\n        eveId: string;\n        name: string;\n        mainCharacterId?: string;\n      }>;\n      mainCharacterId?: string;\n    }>\n  > {\n    try {\n      logger.info('BaseChartHandler.getCharacterGroups() - calling characterRepository.getAllCharacterGroups()');\n      const groups = await this.characterRepository.getAllCharacterGroups();\n      logger.info(`BaseChartHandler.getCharacterGroups() - got ${groups.length} raw groups from repository`);\n\n      // Filter out groups with no characters and transform to expected format\n      const result = groups\n        .filter((group: CharacterGroup) => group.characters.length > 0)\n        .map((group: CharacterGroup) => ({\n          groupId: group.id,\n          name: group.name,\n          characters: group.characters.map(char => ({\n            eveId: char.eveId,\n            name: char.name,\n          })),\n          mainCharacterId: group.mainCharacterId,\n        }));\n\n      logger.info(`BaseChartHandler.getCharacterGroups() - returning ${result.length} filtered groups`);\n      return result;\n    } catch (error) {\n      logger.error('Error fetching character groups:', {\n        error:\n          error instanceof Error\n            ? {\n                name: error.name,\n                message: error.message,\n                stack: error.stack,\n              }\n            : error,\n        errorType: typeof error,\n        errorString: String(error),\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Handle any errors that occur during command execution\n   */\n  protected async handleError(interaction: CommandInteraction, error: any): Promise<void> {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Error handling chart command: ${errorMessage}`, {\n      error:\n        error instanceof Error\n          ? {\n              name: error.name,\n              message: error.message,\n              stack: error.stack,\n            }\n          : error,\n      interactionId: interaction.id,\n      commandName: interaction.commandName,\n      subcommand: interaction.isChatInputCommand() ? interaction.options.getSubcommand(false) : 'unknown',\n      replied: interaction.replied,\n      deferred: interaction.deferred,\n    });\n\n    try {\n      // Reply with error message\n      const content = `❌ Error generating chart: ${errorMessage}`;\n\n      if (interaction.deferred) {\n        await interaction.editReply({ content });\n      } else if (!interaction.replied) {\n        await interaction.reply({\n          content,\n          flags: MessageFlags.Ephemeral,\n        });\n      } else {\n        await interaction.followUp({\n          content,\n          flags: MessageFlags.Ephemeral,\n        });\n      }\n    } catch (replyError) {\n      logger.error('Error sending error response:', replyError);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/CorpsHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2400.","line":83,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":83,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2400.","line":83,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":83,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":86,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1800.","line":86,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3200.","line":89,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":89,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1600.","line":89,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":89,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts corps command\n */\nexport class CorpsHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the corps chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating enemy corporations chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const corpsGenerator = ChartFactory.createGenerator('corps');\n\n      // Check if view option is specified (horizontalBar, verticalBar, or pie)\n      const displayType = interaction.options.getString('view') ?? 'horizontalBar';\n\n      // Generate chart data\n      const chartData = await corpsGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: displayType,\n      });\n\n      // Render chart to buffer\n      logger.info(`Rendering enemy corporations chart with ${displayType} view`);\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Enemy Corporations Chart',\n        files: [{ attachment: buffer, name: 'corps-chart.png' }],\n      });\n\n      logger.info('Successfully sent enemy corporations chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    // Create options object based on chartData.options or use defaults\n    const options: ChartOptions = chartData.options ?? {\n      responsive: true,\n      maintainAspectRatio: false,\n    };\n\n    // Use different canvas sizes based on chart type\n    if (chartData.displayType === 'pie') {\n      return new ChartRenderer(2400, 2400).renderToBuffer(chartData, options);\n    } else if (chartData.displayType === 'bar') {\n      // Vertical bar chart\n      return new ChartRenderer(3000, 1800).renderToBuffer(chartData, options);\n    } else {\n      // Horizontal bar chart (default)\n      return new ChartRenderer(3200, 1600).renderToBuffer(chartData, options);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/DistributionHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2393,2396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2393,2396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts distribution command\n */\nexport class DistributionHandler extends BaseChartHandler {\n  private chartRenderer: ChartRenderer;\n\n  constructor() {\n    super();\n    this.chartRenderer = new ChartRenderer();\n  }\n\n  /**\n   * Handle a distribution chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Extract options from the command\n      const time = interaction.options.getString('time') ?? '7';\n      const displayOption = interaction.options.getString('display') ?? 'pie';\n\n      // Get the time range\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      // Get all character groups\n      const characterGroups = await this.characterRepository.getAllCharacterGroups();\n\n      if (characterGroups.length === 0) {\n        await interaction.editReply('No character groups found. Please add characters first.');\n        return;\n      }\n\n      // Transform character groups into the format expected by the chart generator\n      const transformedGroups = characterGroups.map(group => ({\n        groupId: group.id,\n        name: group.name,\n        characters: group.characters.map(char => ({\n          eveId: char.eveId,\n          name: char.name,\n        })),\n        mainCharacterId: group.mainCharacterId,\n      }));\n\n      // Get the chart generator\n      const generator = ChartFactory.createGenerator('distribution');\n\n      // Generate the chart data\n      const chartData = await generator.generateChart({\n        startDate,\n        endDate,\n        characterGroups: transformedGroups,\n        displayType: displayOption,\n      });\n\n      // Render the chart\n      const buffer = await this.chartRenderer.renderToBuffer(chartData, chartData.options as ChartOptions);\n\n      // Send the chart image\n      await interaction.editReply({\n        content: chartData.summary,\n        files: [{ attachment: buffer, name: 'distribution-chart.png' }],\n      });\n    } catch (error: any) {\n      logger.error('Error handling distribution chart command:', error);\n      await interaction.editReply(`Error generating chart: ${error.message}`);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/EfficiencyHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (63). Maximum allowed is 50.","line":69,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":136,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2852,2855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2852,2855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":134,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1600.","line":134,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts efficiency command\n * Shows efficiency metrics with gauge charts\n */\nexport class EfficiencyHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating efficiency chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const efficiencyGenerator = ChartFactory.createGenerator('efficiency');\n\n      // Generate chart data\n      const chartData = await efficiencyGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'gauge',\n      });\n\n      // Render chart to buffer\n      logger.info('Rendering efficiency chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Efficiency Chart',\n        files: [{ attachment: buffer, name: 'efficiency-chart.png' }],\n      });\n\n      logger.info('Successfully sent efficiency chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    let options: ChartOptions;\n\n    if (chartData.displayType === 'gauge') {\n      // Options for a gauge/doughnut chart\n      options = {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins: {\n          title: {\n            display: true,\n            text: chartData.title ?? 'Efficiency by Character Group',\n            font: {\n              size: 40,\n              weight: 'bold',\n            },\n          },\n          legend: {\n            display: false, // Hide legend for gauge\n            position: 'top' as const,\n          },\n        },\n        rotation: -Math.PI,\n        circumference: Math.PI,\n        cutout: '70%',\n      } as any; // Chart.js options for doughnut\n    } else {\n      // Bar chart options (existing)\n      options = {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins: {\n          title: {\n            display: true,\n            text: chartData.title ?? 'Efficiency by Character Group',\n            font: {\n              size: 40,\n              weight: 'bold',\n            },\n          },\n          legend: {\n            display: true,\n            position: 'top' as const,\n          },\n        },\n        scales: {\n          x: {\n            beginAtZero: true,\n            suggestedMax: 100,\n            title: {\n              display: true,\n              text: 'Efficiency (%)',\n            },\n          },\n          y: {\n            title: {\n              display: true,\n              text: 'Character Group',\n            },\n          },\n        },\n      };\n    }\n\n    // Use a wide canvas for better display\n    const renderer = new ChartRenderer(3000, 1600);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/HeatmapHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2871,2874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2871,2874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2400.","line":111,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":111,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2400.","line":111,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":111,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts heatmap command\n * Shows kill activity by hour and day of week\n */\nexport class HeatmapHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating heatmap chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const heatmapGenerator = ChartFactory.createGenerator('heatmap');\n\n      // Generate chart data\n      const chartData = await heatmapGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'heatmap',\n      });\n\n      // Render chart to buffer\n      logger.info('Rendering heatmap chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Activity Heatmap',\n        files: [{ attachment: buffer, name: 'heatmap-chart.png' }],\n      });\n\n      logger.info('Successfully sent heatmap chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options: ChartOptions = {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Activity by Hour and Day',\n          font: {\n            size: 40,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n      scales: {\n        x: {\n          type: 'linear',\n          suggestedMin: 0,\n          suggestedMax: 23,\n          title: {\n            display: true,\n            text: 'Hour of Day',\n          },\n        },\n        y: {\n          type: 'category',\n          ticks: {\n            callback: (value: any) => ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][value],\n          },\n          title: {\n            display: true,\n            text: 'Day of Week',\n          },\n        },\n      },\n    };\n\n    // Use a square canvas for heatmap display\n    const renderer = new ChartRenderer(2400, 2400);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/KillsHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":40,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":22},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":42,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":42,"endColumn":42},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (82). Maximum allowed is 50.","line":95,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":190,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3200.","line":164,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1280.","line":164,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts/ChartFactory';\nimport { theme } from '../../../../services/charts/config/theme';\n\n/**\n * Handler for the /charts kills command\n */\nexport class KillsHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the kills chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(\n        `Generating kills chart for ${time} days - Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`\n      );\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      logger.info(`Found ${groups.length} character groups for chart generation`);\n      logger.info(\n        `First few groups: ${groups\n          .slice(0, 3)\n          .map(g => g.name)\n          .join(', ')}${groups.length > 3 ? '...' : ''}`\n      );\n\n      // Log total character count across all groups\n      const totalCharacters = groups.reduce((sum, group) => sum + group.characters.length, 0);\n      logger.info(`Total character count across all groups: ${totalCharacters}`);\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the appropriate chart generator\n      const generator = ChartFactory.createGenerator('kills');\n\n      // Generate chart data\n      logger.info(`Generating chart data with ${groups.length} groups...`);\n      const chartData = await generator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n\n      // Log chart results\n      logger.info(`Chart data generated with ${chartData.labels?.length ?? 0} labels`);\n      if (chartData.datasets?.length > 0) {\n        logger.info(\n          `First dataset (${chartData.datasets[0].label}) has ${chartData.datasets[0].data.length} data points`\n        );\n      }\n\n      // Render chart to buffer\n      logger.info('Rendering kills chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary - make sure not to return this value\n      await interaction.editReply({\n        content: chartData.summary ?? 'Kills chart',\n        files: [{ attachment: buffer, name: 'kills-chart.png' }],\n      });\n\n      logger.info('Successfully sent kills chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    // Create a simpler options object that conforms to the ChartOptions interface\n    const options: ChartOptions = {\n      indexAxis: 'y', // Horizontal bar chart\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Kills by Character Group',\n          font: {\n            size: 40, // Extra large title\n            weight: 'bold',\n          },\n        },\n        legend: {\n          position: 'top',\n          labels: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n        tooltip: {\n          backgroundColor: theme.colors.background,\n          titleColor: theme.text.primary,\n          bodyColor: theme.text.primary,\n          borderColor: theme.colors.primary,\n          borderWidth: 1,\n          padding: 10,\n          displayColors: true,\n          callbacks: {\n            label: context => {\n              const label = context.dataset.label ?? '';\n              const parsed = context.parsed as { x?: number; y?: number } | number;\n              const value = typeof parsed === 'object' ? (parsed.x ?? parsed.y ?? 0) : parsed;\n              return `${label}: ${value}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n        y: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n      },\n    };\n\n    // Use a very wide canvas for horizontal bar chart display in Discord\n    const renderer = new ChartRenderer(3200, 1280);\n\n    // Set the data point styling\n    if (chartData.datasets.length >= 2) {\n      // Set distinct colors for total kills vs solo kills\n      // Use solid colors for better visibility in Discord\n      if (chartData.datasets[0].label === 'Total Kills') {\n        chartData.datasets[0].backgroundColor = '#3366CC'; // Blue for total kills\n      }\n\n      if (chartData.datasets[1].label === 'Solo Kills') {\n        chartData.datasets[1].backgroundColor = '#DC3912'; // Red for solo kills\n      }\n\n      // Add borders for better definition\n      chartData.datasets[0].borderColor = '#1A478F'; // Darker blue border\n      chartData.datasets[1].borderColor = '#8F1A1A'; // Darker red border\n\n      // Log the solo kill values\n      logger.debug('Solo kills dataset', {\n        data: chartData.datasets[1].data,\n      });\n    }\n\n    // Pass additional styling options to the renderer\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ListHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'handle' has too many lines (83). Maximum allowed is 50.","line":17,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":109,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction, EmbedBuilder } from 'discord.js';\nimport { logger } from '../../../logger';\n\n/**\n * Handler for the /charts list command\n * Displays a list of all available chart types\n */\nexport class ListHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the list command interaction\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    try {\n      logger.info('Handling list subcommand');\n\n      // Define available subcommands directly to avoid circular dependency\n      const subcommands = [\n        'list',\n        'kills',\n        'map',\n        'loss',\n        'ratio',\n        'shipkill',\n        'shiploss',\n        'distribution',\n        'corps',\n        'heatmap',\n        'efficiency',\n      ];\n\n      // Map subcommands to friendly names/descriptions\n      const chartDescriptions: Record<string, { name: string; value: string }> = {\n        kills: {\n          name: '📊 /charts kills [time]',\n          value: 'Show kill activity by character group with stacked horizontal bars',\n        },\n        map: {\n          name: '🗺️ /charts map [time]',\n          value: 'Show map activity by character group with stacked horizontal bars',\n        },\n        loss: {\n          name: '💥 /charts loss [time]',\n          value: 'Show ship loss activity by character group',\n        },\n        ratio: {\n          name: '📈 /charts ratio [time]',\n          value: 'Show kill-death ratio by character group',\n        },\n        shipkill: {\n          name: '🚀 /charts shipkill [time]',\n          value: 'Show top ship types destroyed by your group(s) in the selected period.',\n        },\n        shiploss: {\n          name: '💥 /charts shiploss [time]',\n          value: 'Show top ship types lost by your group(s) in the selected period.',\n        },\n        distribution: {\n          name: '🥧 /charts distribution [time]',\n          value: 'Show pie chart of solo vs. group kills',\n        },\n        corps: {\n          name: '🏢 /charts corps [time]',\n          value: 'Show kills per enemy corporation',\n        },\n        heatmap: {\n          name: '🌡️ /charts heatmap [time]',\n          value: 'Show heatmap of kill activity by hour and day of week',\n        },\n        efficiency: {\n          name: '📊 /charts efficiency [time]',\n          value: 'Show efficiency metrics with gauge charts',\n        },\n      };\n\n      // Build fields for the embed\n      const fields = subcommands\n        .filter(cmd => chartDescriptions[cmd] && cmd !== 'heatmap' && cmd !== 'trend' && cmd !== 'shiptypes')\n        .map(cmd => chartDescriptions[cmd]);\n\n      const embed = new EmbedBuilder()\n        .setTitle('Available Chart Types')\n        .setColor('#0099ff')\n        .setDescription('Here are all the available chart types:')\n        .addFields(fields)\n        .setFooter({\n          text: 'Use the specific command to generate that chart type',\n        });\n\n      await interaction.reply({ embeds: [embed] });\n      logger.info('Successfully sent list of chart types');\n    } catch (error) {\n      logger.error('Error handling list command:', error);\n\n      // Send a generic error message to the user\n      await interaction\n        .reply({\n          content: 'Sorry, there was an error processing your request. Please try again later.',\n          ephemeral: true,\n        })\n        .catch(e => {\n          logger.error('Error sending error response:', e);\n        });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/LossHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (66). Maximum allowed is 50.","line":72,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":139,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2200.","line":137,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1400.","line":137,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { TooltipItem, Scale } from 'chart.js';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts loss command\n */\nexport class LossHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the ship loss chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating loss chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const lossGenerator = ChartFactory.createGenerator('loss');\n\n      // Generate chart data\n      const chartData = await lossGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n\n      // Render chart to buffer\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Loss chart',\n        files: [{ attachment: buffer, name: 'loss-chart.png' }],\n      });\n\n      logger.info('Successfully sent loss chart');\n    } catch (error) {\n      logger.error('Error generating loss chart:', error);\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options = {\n      indexAxis: 'y' as const,\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Losses by Character Group',\n          font: {\n            size: 40,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: (context: TooltipItem<'bar'>) => {\n              const label = context.dataset.label ?? '';\n              const value = context.parsed.y;\n              if (label.includes('ISK')) {\n                return `${label}: ${value.toLocaleString()} B`;\n              }\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'ISK Lost',\n            font: {\n              size: 20,\n            },\n          },\n          ticks: {\n            callback: function (this: Scale, value: string | number) {\n              if (typeof value === 'number') {\n                return value.toLocaleString();\n              }\n              return value;\n            },\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Character',\n            font: {\n              size: 20,\n            },\n          },\n        },\n      },\n    };\n\n    // Use a much larger canvas for better display in Discord without needing to click\n    const renderer = new ChartRenderer(2200, 1400);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/MapHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'handle' has too many lines (53). Maximum allowed is 50.","line":19,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":89,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2200.","line":129,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":129,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1400.","line":129,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":129,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts map command\n */\nexport class MapHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the map activity chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    const startTime = Date.now();\n\n    try {\n      logger.info('Starting map activity chart generation');\n      logger.info(\n        `MapHandler - About to defer reply. Interaction state: replied=${interaction.replied}, deferred=${interaction.deferred}, id=${interaction.id}`\n      );\n      logger.info(`MapHandler - Interaction created at: ${interaction.createdAt}, current time: ${new Date()}`);\n      logger.info(`MapHandler - Time since interaction created: ${Date.now() - interaction.createdTimestamp}ms`);\n\n      await interaction.deferReply();\n      logger.info(`Deferred reply after ${Date.now() - startTime}ms`);\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating map activity chart for ${time} days`);\n\n      // Get character groups\n      logger.info('Fetching character groups...');\n      const groupsStartTime = Date.now();\n      const groups = await this.getCharacterGroups();\n      logger.info(`Got ${groups.length} character groups after ${Date.now() - groupsStartTime}ms`);\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      logger.info('Creating chart generator...');\n      const mapGenerator = ChartFactory.createGenerator('map');\n\n      // Generate chart data\n      logger.info('Generating chart data...');\n      const chartStartTime = Date.now();\n      const chartData = await mapGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n      logger.info(`Chart data generated after ${Date.now() - chartStartTime}ms`);\n\n      // Render chart to buffer\n      logger.info('Rendering map activity chart');\n      const renderStartTime = Date.now();\n      const buffer = await this.renderChart(chartData);\n      logger.info(`Chart rendered after ${Date.now() - renderStartTime}ms`);\n\n      // Send the chart with summary\n      logger.info('Sending chart response...');\n      const responseStartTime = Date.now();\n      await interaction.editReply({\n        content: chartData.summary ?? 'Map activity chart',\n        files: [{ attachment: buffer, name: 'map-chart.png' }],\n      });\n      logger.info(`Response sent after ${Date.now() - responseStartTime}ms`);\n\n      logger.info(`Successfully sent map activity chart - total time: ${Date.now() - startTime}ms`);\n    } catch (error) {\n      logger.error(`Error after ${Date.now() - startTime}ms:`, error);\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options = {\n      indexAxis: 'y' as const,\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Map Activity by Character Group',\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Character',\n          },\n        },\n      },\n    };\n\n    // Use a much larger canvas for better display in Discord without needing to click\n    const renderer = new ChartRenderer(2200, 1400);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/RatioHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2200.","line":105,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1400.","line":105,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts ratio command\n */\nexport class RatioHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the kill-death ratio chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating kill-death ratio chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const ratioGenerator = ChartFactory.createGenerator('ratio');\n\n      // Generate chart data\n      const chartData = await ratioGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n\n      // Render chart to buffer\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Kill/Death Ratio chart',\n        files: [{ attachment: buffer, name: 'ratio-chart.png' }],\n      });\n\n      logger.info('Successfully sent kill-death ratio chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options = {\n      indexAxis: 'y' as const,\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Kill/Loss Ratio by Character Group',\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Ratio',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Character',\n          },\n        },\n      },\n    };\n\n    // Use a much larger canvas for better display in Discord without needing to click\n    const renderer = new ChartRenderer(2200, 1400);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ShipKillHandler.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":107,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1600.","line":107,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts shipkill command\n */\nexport class ShipKillHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating ship kill chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const shipKillGenerator = ChartFactory.createGenerator('shipkill');\n\n      // Generate chart data\n      const chartData = await shipKillGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n\n      // Render chart to buffer\n      logger.info('Rendering ship kill chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Ship Kill Chart',\n        files: [{ attachment: buffer, name: 'shipkill-chart.png' }],\n      });\n\n      logger.info('Successfully sent ship kill chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options: ChartOptions = {\n      indexAxis: 'y' as const,\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Ships Destroyed by Type',\n          font: {\n            size: 40,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Ship Type',\n          },\n        },\n      },\n    };\n\n    // Use a wide canvas for better display\n    const renderer = new ChartRenderer(3000, 1600);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ShipLossHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (66). Maximum allowed is 50.","line":70,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":137,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2723,2726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2723,2726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":135,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":135,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1600.","line":135,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":135,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\nimport { Scale } from 'chart.js';\n\n/**\n * Handler for the /charts shiploss command\n */\nexport class ShipLossHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating ship loss chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const shipLossGenerator = ChartFactory.createGenerator('shiploss');\n\n      // Generate chart data\n      const chartData = await shipLossGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar',\n      });\n\n      // Render chart to buffer\n      logger.info('Rendering ship loss chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Ship Loss Chart',\n        files: [{ attachment: buffer, name: 'shiploss-chart.png' }],\n      });\n\n      logger.info('Successfully sent ship loss chart');\n    } catch (error) {\n      logger.error('Error generating ship loss chart:', error);\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options: ChartOptions = {\n      indexAxis: 'y' as const,\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Ships Lost by Type',\n          font: {\n            size: 40,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: (context: any) => {\n              const label = context.dataset.label ?? '';\n              const value = context.parsed.y;\n              if (label.includes('ISK')) {\n                return `${label}: ${value.toLocaleString()} B`;\n              }\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Count',\n            font: {\n              size: 20,\n            },\n          },\n          ticks: {\n            callback: function (this: Scale, value: string | number) {\n              if (typeof value === 'number') {\n                return value.toLocaleString();\n              }\n              return value;\n            },\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Ship Type',\n            font: {\n              size: 20,\n            },\n          },\n        },\n      },\n    };\n\n    // Use a wide canvas for better display\n    const renderer = new ChartRenderer(3000, 1600);\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ShipTypesHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (57). Maximum allowed is 50.","line":71,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":134,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2910,2913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2910,2913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3338,3341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3338,3341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":110,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":110,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":63},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":111,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":111,"endColumn":32},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":111,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":111,"endColumn":57},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3200.","line":126,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1280.","line":126,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 2800.","line":130,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":130,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1400.","line":130,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":130,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts shiptypes command\n */\nexport class ShipTypesHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the ship types chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating ship types chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const shipTypesGenerator = ChartFactory.createGenerator('shiptypes');\n\n      // Generate chart data\n      const chartData = await shipTypesGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: 'horizontalBar', // horizontal bar is the default for ship types\n      });\n\n      // Render chart to buffer\n      logger.info('Rendering ship types chart');\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Ship Types Chart',\n        files: [{ attachment: buffer, name: 'shiptypes-chart.png' }],\n      });\n\n      logger.info('Successfully sent ship types chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    // Create options object based on chartData.options or use defaults\n    const options: ChartOptions = chartData.options ?? {\n      indexAxis: 'y', // Horizontal bar chart by default\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Ship Types Destroyed',\n          font: {\n            size: 40, // Extra large title\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: false, // Don't need legend for single dataset\n          position: 'top',\n        },\n        tooltip: {\n          callbacks: {\n            label: (context: any): string => {\n              const label = context.dataset.label ?? '';\n              const value = context.parsed.x;\n              return `${label}: ${value.toLocaleString()} ships`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n          ticks: {\n            callback: (value: any): string => {\n              // Format numbers with K/M/B suffixes\n              if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n              if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n              return value.toString();\n            },\n          },\n        },\n        y: {\n          title: {\n            display: true,\n            text: 'Ship Type',\n          },\n        },\n      },\n    };\n\n    // Use a wide canvas for horizontal bar chart display in Discord\n    const renderer = new ChartRenderer(3200, 1280);\n\n    // For line charts/timelines, use a different renderer size\n    if (chartData.displayType === 'line') {\n      return new ChartRenderer(2800, 1400).renderToBuffer(chartData, options);\n    }\n\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/TrendHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (54). Maximum allowed is 50.","line":74,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":134,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3200.","line":124,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1600.","line":124,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":129,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":129,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1800.","line":129,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":129,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3000.","line":133,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":133,"endColumn":34},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1500.","line":133,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":133,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartHandler } from './BaseChartHandler';\nimport { CommandInteraction } from 'discord.js';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts';\n\n/**\n * Handler for the /charts trend command\n */\nexport class TrendHandler extends BaseChartHandler {\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the trend chart command\n   */\n  async handle(interaction: CommandInteraction): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    try {\n      await interaction.deferReply();\n\n      // Get time period from command options\n      const time = interaction.options.getString('time') ?? '7';\n      const { startDate, endDate } = this.getTimeRange(time);\n\n      logger.info(`Generating trend chart for ${time} days`);\n\n      // Get character groups\n      const groups = await this.getCharacterGroups();\n\n      if (groups.length === 0) {\n        await interaction.editReply({\n          content: 'No character groups found. Please add characters to groups first.',\n        });\n        return;\n      }\n\n      // Get the chart generator from the factory\n      const trendGenerator = ChartFactory.createGenerator('trend');\n\n      // Check if view option is specified (line, area, or dual)\n      const displayType = interaction.options.getString('view') ?? 'line';\n\n      // Generate chart data\n      const chartData = await trendGenerator.generateChart({\n        characterGroups: groups,\n        startDate,\n        endDate,\n        displayType: displayType,\n      });\n\n      // Render chart to buffer\n      logger.info(`Rendering trend chart with ${displayType} view`);\n      const buffer = await this.renderChart(chartData);\n\n      // Send the chart with summary\n      await interaction.editReply({\n        content: chartData.summary ?? 'Trend Chart',\n        files: [{ attachment: buffer, name: 'trend-chart.png' }],\n      });\n\n      logger.info('Successfully sent trend chart');\n    } catch (error) {\n      await this.handleError(interaction, error);\n    }\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    // Create options object based on chartData.options or use defaults\n    const options: ChartOptions =\n      chartData.options ??\n      ({\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins: {\n          title: {\n            display: true,\n            text: chartData.title ?? 'Kill Activity Over Time',\n            font: {\n              size: 40,\n              weight: 'bold',\n            },\n          },\n          legend: {\n            display: true,\n            position: 'top',\n          },\n        },\n        scales: {\n          y: {\n            beginAtZero: true,\n            title: {\n              display: true,\n              text: 'Kill Count',\n            },\n          },\n          x: {\n            type: 'time',\n            time: {\n              unit: 'day',\n              displayFormats: {\n                hour: 'MMM d, HH:mm',\n                day: 'MMM d',\n                week: 'MMM d, yyyy',\n                month: 'MMM yyyy',\n              },\n            },\n            title: {\n              display: true,\n              text: 'Date',\n            },\n          },\n        },\n      } as ChartOptions); // Cast to ChartOptions to ensure type compatibility\n\n    // For dual-axis charts, use wide format\n    if (chartData.options?.scales?.y2) {\n      return new ChartRenderer(3200, 1600).renderToBuffer(chartData, options);\n    }\n\n    // For area charts, use slightly taller format\n    if (chartData.datasets.some(d => d.fill === true)) {\n      return new ChartRenderer(3000, 1800).renderToBuffer(chartData, options);\n    }\n\n    // Default format for line charts\n    return new ChartRenderer(3000, 1500).renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ValidatedBaseChartHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2819,2822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2819,2822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2987,2990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2987,2990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction, MessageFlags } from 'discord.js';\nimport { BaseChartHandler } from './BaseChartHandler';\nimport { validateCommand, validateInteraction, logCommandUsage, CommandName } from '../../validation';\nimport { logger } from '../../../logger';\n\n/**\n * Enhanced base class for chart handlers with built-in validation and rate limiting\n */\nexport abstract class ValidatedBaseChartHandler extends BaseChartHandler {\n  /**\n   * The command name for validation purposes\n   */\n  protected abstract readonly commandName: CommandName;\n\n  /**\n   * Whether to use strict rate limiting for this command\n   */\n  protected readonly useStrictRateLimit: boolean = false;\n\n  /**\n   * Handle the command with validation and rate limiting\n   */\n  override async handle(interaction: CommandInteraction): Promise<void> {\n    const startTime = Date.now();\n    let success = false;\n    let error: string | undefined;\n\n    try {\n      // Perform validation and rate limiting\n      const validationResult = await validateInteraction(interaction, {\n        customRateLimitConfig: this.useStrictRateLimit\n          ? {\n              maxRequests: 3,\n              windowMs: 60000,\n            }\n          : undefined,\n      });\n\n      if (!validationResult.valid) {\n        error = validationResult.error;\n        return;\n      }\n\n      // Validate command parameters\n      const commandValidation = await validateCommand(interaction, this.commandName);\n\n      if (!commandValidation.success) {\n        error = commandValidation.error ?? 'Invalid parameters';\n\n        // Send user-friendly error message\n        const errorDetails = commandValidation.details?.errors\n          .map(err => `• ${err.path.join('.')}: ${err.message}`)\n          .join('\\n');\n\n        await interaction.reply({\n          content: `❌ Invalid command parameters:\\n${errorDetails ?? error}`,\n          flags: MessageFlags.Ephemeral,\n        });\n        return;\n      }\n\n      // Call the implementation with validated data\n      await this.handleValidated(interaction, commandValidation.data);\n      success = true;\n    } catch (err) {\n      error = err instanceof Error ? err.message : String(err);\n      await this.handleError(interaction, err);\n    } finally {\n      // Log command usage\n      logCommandUsage(interaction, success, error);\n\n      // Log performance metrics\n      const duration = Date.now() - startTime;\n      logger.info(`Command execution completed in ${duration}ms`, {\n        command: this.commandName,\n        duration,\n        success,\n        userId: interaction.user.id,\n        guildId: interaction.guildId,\n      });\n    }\n  }\n\n  /**\n   * Handle the command with validated data\n   * This method must be implemented by subclasses\n   */\n  protected abstract handleValidated(interaction: CommandInteraction, validatedData: any): Promise<void>;\n\n  /**\n   * Enhanced error handler with better error messages\n   */\n  protected override async handleError(interaction: CommandInteraction, error: any): Promise<void> {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    // Log detailed error information\n    logger.error(`Error in ${this.commandName} command:`, {\n      error:\n        error instanceof Error\n          ? {\n              name: error.name,\n              message: error.message,\n              stack: error.stack,\n            }\n          : error,\n      command: this.commandName,\n      userId: interaction.user.id,\n      guildId: interaction.guildId,\n      interactionId: interaction.id,\n    });\n\n    // Determine user-friendly error message\n    let userMessage = '❌ An error occurred while generating the chart.';\n\n    // Common error patterns\n    if (errorMessage.includes('timeout')) {\n      userMessage = '❌ The request timed out. Please try again with a smaller time range.';\n    } else if (errorMessage.includes('rate limit')) {\n      userMessage = '❌ You are being rate limited. Please try again later.';\n    } else if (errorMessage.includes('no data')) {\n      userMessage = '❌ No data found for the specified time period.';\n    } else if (errorMessage.includes('permission')) {\n      userMessage = '❌ You do not have permission to use this command.';\n    }\n\n    try {\n      const content = userMessage;\n\n      if (interaction.deferred) {\n        await interaction.editReply({ content });\n      } else if (!interaction.replied) {\n        await interaction.reply({\n          content,\n          flags: MessageFlags.Ephemeral,\n        });\n      } else {\n        await interaction.followUp({\n          content,\n          flags: MessageFlags.Ephemeral,\n        });\n      }\n    } catch (replyError) {\n      logger.error('Error sending error response:', replyError);\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/ValidatedKillsHandler.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'renderChart' has too many lines (82). Maximum allowed is 50.","line":85,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":178,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3200.","line":153,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":153,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1280.","line":153,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":153,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { ValidatedBaseChartHandler } from './ValidatedBaseChartHandler';\nimport { ChartData, ChartOptions } from '../../../../types/chart';\nimport { ChartRenderer } from '../../../../services/ChartRenderer';\nimport { logger } from '../../../logger';\nimport { ChartFactory } from '../../../../services/charts/ChartFactory';\nimport { theme } from '../../../../services/charts/config/theme';\nimport { CommandName, CommandSchema } from '../../validation/schemas';\n\n/**\n * Validated handler for the /charts kills command\n */\nexport class ValidatedKillsHandler extends ValidatedBaseChartHandler {\n  protected readonly commandName: CommandName = 'kills';\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Handle the kills chart command with validated data\n   */\n  protected async handleValidated(\n    interaction: CommandInteraction,\n    validatedData: CommandSchema<'kills'>\n  ): Promise<void> {\n    if (!interaction.isChatInputCommand()) return;\n\n    await interaction.deferReply();\n\n    // Use validated time parameter\n    const { startDate, endDate } = this.getTimeRange(validatedData.time.toString());\n\n    logger.info(\n      `Generating kills chart for ${validatedData.time} days - Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`\n    );\n\n    // Get character groups\n    const groups = await this.getCharacterGroups();\n\n    logger.info(`Found ${groups.length} character groups for chart generation`);\n\n    // Log total character count across all groups\n    const totalCharacters = groups.reduce((sum, group) => sum + group.characters.length, 0);\n    logger.info(`Total character count across all groups: ${totalCharacters}`);\n\n    if (groups.length === 0) {\n      await interaction.editReply({\n        content: 'No character groups found. Please add characters to groups first.',\n      });\n      return;\n    }\n\n    // Get the appropriate chart generator\n    const generator = ChartFactory.createGenerator('kills');\n\n    // Generate chart data\n    logger.info(`Generating chart data with ${groups.length} groups...`);\n    const chartData = await generator.generateChart({\n      characterGroups: groups,\n      startDate,\n      endDate,\n      displayType: 'horizontalBar',\n    });\n\n    // Log chart results\n    logger.info(`Chart data generated with ${chartData.labels?.length ?? 0} labels`);\n\n    // Render chart to buffer\n    logger.info('Rendering kills chart');\n    const buffer = await this.renderChart(chartData);\n\n    // Send the chart with summary\n    await interaction.editReply({\n      content: chartData.summary ?? 'Kills chart',\n      files: [{ attachment: buffer, name: 'kills-chart.png' }],\n    });\n\n    logger.info('Successfully sent kills chart');\n  }\n\n  /**\n   * Render chart to buffer using appropriate options\n   */\n  private async renderChart(chartData: ChartData): Promise<Buffer> {\n    const options: ChartOptions = {\n      indexAxis: 'y', // Horizontal bar chart\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: chartData.title ?? 'Kills by Character Group',\n          font: {\n            size: 40,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          position: 'top',\n          labels: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n        tooltip: {\n          backgroundColor: theme.colors.background,\n          titleColor: theme.text.primary,\n          bodyColor: theme.text.primary,\n          borderColor: theme.colors.primary,\n          borderWidth: 1,\n          padding: 10,\n          displayColors: true,\n          callbacks: {\n            label: context => {\n              const label = context.dataset.label ?? '';\n              const parsed = context.parsed as { x?: number; y?: number } | number;\n              const value = typeof parsed === 'object' ? (parsed.x ?? parsed.y ?? 0) : parsed;\n              return `${label}: ${value}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n        y: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n      },\n    };\n\n    // Use a very wide canvas for horizontal bar chart display in Discord\n    const renderer = new ChartRenderer(3200, 1280);\n\n    // Set the data point styling\n    if (chartData.datasets.length >= 2) {\n      // Set distinct colors for total kills vs solo kills\n      if (chartData.datasets[0].label === 'Total Kills') {\n        chartData.datasets[0].backgroundColor = '#3366CC'; // Blue for total kills\n      }\n\n      if (chartData.datasets[1].label === 'Solo Kills') {\n        chartData.datasets[1].backgroundColor = '#DC3912'; // Red for solo kills\n      }\n\n      // Add borders for better definition\n      chartData.datasets[0].borderColor = '#1A478F'; // Darker blue border\n      chartData.datasets[1].borderColor = '#8F1A1A'; // Darker red border\n\n      // Log the solo kill values\n      logger.debug('Solo kills dataset', {\n        data: chartData.datasets[1].data,\n      });\n    }\n\n    // Pass additional styling options to the renderer\n    return renderer.renderToBuffer(chartData, options);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/subcommands/createValidatedHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1065,1068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1065,1068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { BaseChartHandler } from './BaseChartHandler';\nimport { ValidatedBaseChartHandler } from './ValidatedBaseChartHandler';\nimport { CommandName } from '../../validation/schemas';\n\n/**\n * Factory function to create a validated handler from an existing handler\n * This allows gradual migration of existing handlers to use validation\n */\nexport function createValidatedHandler(\n  Handler: typeof BaseChartHandler,\n  commandName: CommandName,\n  useStrictRateLimit: boolean = false\n): new () => BaseChartHandler {\n  return class ConcreteValidatedHandler extends ValidatedBaseChartHandler {\n    protected override readonly commandName = commandName;\n    protected override readonly useStrictRateLimit = useStrictRateLimit;\n    private innerHandler: BaseChartHandler;\n\n    constructor() {\n      super();\n      // @ts-ignore - Handler might have different constructor signature\n      this.innerHandler = new Handler();\n    }\n\n    protected override async handleValidated(interaction: CommandInteraction, validatedData: any): Promise<void> {\n      // Monkey-patch the interaction to use validated data\n      if (interaction.isChatInputCommand()) {\n        const originalGetString = interaction.options.getString.bind(interaction.options);\n\n        // Override getString to return validated data\n        interaction.options.getString = (name: string) => {\n          if (name in validatedData) {\n            return validatedData[name]?.toString() || null;\n          }\n          return originalGetString(name);\n        };\n      }\n\n      // Call the original handler\n      await this.innerHandler.handle(interaction);\n    }\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/handlers/validatedRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validatedChartHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validation/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validation/middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1035,1038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1035,1038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'performSecurityChecks' has too many lines (53). Maximum allowed is 50.","line":82,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":147,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":87,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":87,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":87,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":87,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":87,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":92,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":92,"endColumn":47},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":92,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":92,"endColumn":52},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":92,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":92,"endColumn":57},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":103,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":103,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":103,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":47},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":109,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":59},{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'validateInteraction' has too many lines (85). Maximum allowed is 50.","line":152,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":255,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Async function 'validateInteraction' has a complexity of 17. Maximum allowed is 10.","line":152,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":255,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4407,4410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4407,4410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":304,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":304,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9282,9284],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x08, \\x0b, \\x0c, \\x0e, \\x1f.","line":275,"column":33,"nodeType":"Literal","messageId":"unexpected","endLine":275,"endColumn":68,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction, MessageFlags } from 'discord.js';\nimport { z } from 'zod';\nimport { logger } from '../../logger';\nimport { commandSchemas, CommandName } from './schemas';\nimport { rateLimiters, rateLimitConfigs } from './rateLimiter';\nimport { securityMonitor } from './securityMonitor';\n\nexport interface ValidationResult<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  details?: z.ZodError;\n}\n\nexport interface SecurityCheckResult {\n  passed: boolean;\n  reason?: string;\n  suspicious?: boolean;\n}\n\n/**\n * Validates command inputs using Zod schemas\n */\nexport async function validateCommand<T extends CommandName>(\n  interaction: CommandInteraction,\n  commandName: T\n): Promise<ValidationResult<z.infer<(typeof commandSchemas)[T]>>> {\n  try {\n    const schema = commandSchemas[commandName];\n    if (!schema) {\n      return {\n        success: false,\n        error: `No validation schema found for command: ${commandName}`,\n      };\n    }\n\n    // Extract options from interaction\n    const options: Record<string, any> = {};\n\n    if (interaction.isChatInputCommand()) {\n      interaction.options.data.forEach(option => {\n        options[option.name] = option.value;\n      });\n    }\n\n    // Validate with Zod\n    const result = schema.safeParse(options);\n\n    if (result.success) {\n      return {\n        success: true,\n        data: result.data,\n      };\n    } else {\n      logger.warn(`Validation failed for command ${commandName}:`, {\n        errors: result.error.errors,\n        userId: interaction.user.id,\n        guildId: interaction.guildId,\n      });\n\n      // Track failed validation\n      await securityMonitor.trackFailedValidation(interaction.user.id);\n\n      return {\n        success: false,\n        error: 'Invalid command parameters',\n        details: result.error,\n      };\n    }\n  } catch (error) {\n    logger.error(`Validation error for command ${commandName}:`, error);\n    return {\n      success: false,\n      error: 'An error occurred during validation',\n    };\n  }\n}\n\n/**\n * Performs security checks on the interaction\n */\nexport async function performSecurityChecks(interaction: CommandInteraction): Promise<SecurityCheckResult> {\n  const checks: SecurityCheckResult = { passed: true };\n\n  // Check 1: User account age\n  const accountAge = Date.now() - interaction.user.createdTimestamp;\n  const minAccountAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n  if (accountAge < minAccountAge) {\n    logger.warn('New account attempting to use commands:', {\n      userId: interaction.user.id,\n      accountAge: Math.floor(accountAge / 1000 / 60 / 60), // hours\n      username: interaction.user.username,\n    });\n    checks.suspicious = true;\n  }\n\n  // Check 2: Guild member duration (if in a guild)\n  if (interaction.inGuild() && interaction.member) {\n    const member = interaction.guild?.members.cache.get(interaction.user.id);\n    if (member?.joinedTimestamp) {\n      const memberDuration = Date.now() - member.joinedTimestamp;\n      const minMemberDuration = 10 * 60 * 1000; // 10 minutes\n\n      if (memberDuration < minMemberDuration) {\n        logger.warn('Very new guild member attempting to use commands:', {\n          userId: interaction.user.id,\n          guildId: interaction.guildId,\n          memberDuration: Math.floor(memberDuration / 1000), // seconds\n          username: interaction.user.username,\n        });\n        checks.suspicious = true;\n      }\n    }\n  }\n\n  // Check 3: Detect suspicious patterns in username\n  const suspiciousPatterns = [\n    /discord\\.gg/i,\n    /bit\\.ly/i,\n    /tinyurl/i,\n    /free.*nitro/i,\n    /steam.*gift/i,\n    /@everyone/,\n    /@here/,\n  ];\n\n  const username = interaction.user.username;\n  const hasSuspiciousUsername = suspiciousPatterns.some(pattern => pattern.test(username));\n\n  if (hasSuspiciousUsername) {\n    logger.warn('Suspicious username pattern detected:', {\n      userId: interaction.user.id,\n      username: interaction.user.username,\n      guildId: interaction.guildId,\n    });\n    checks.suspicious = true;\n  }\n\n  // Check 4: Bot detection\n  if (interaction.user.bot) {\n    checks.passed = false;\n    checks.reason = 'Bots cannot use this command';\n  }\n\n  return checks;\n}\n\n/**\n * Main validation middleware for Discord commands\n */\nexport async function validateInteraction(\n  interaction: CommandInteraction,\n  options?: {\n    skipRateLimit?: boolean;\n    skipSecurity?: boolean;\n    customRateLimitConfig?: any;\n  }\n): Promise<{ valid: boolean; error?: string }> {\n  try {\n    // Check if user is blocked\n    const blockStatus = await securityMonitor.isUserBlocked(interaction.user.id);\n    if (blockStatus.blocked) {\n      await interaction.reply({\n        content: `You have been temporarily blocked. Reason: ${blockStatus.reason ?? 'Suspicious activity detected'}`,\n        flags: MessageFlags.Ephemeral,\n      });\n      return { valid: false, error: 'User blocked' };\n    }\n\n    // Track command usage\n    await securityMonitor.trackCommandUsage(interaction);\n    // Security checks\n    if (!options?.skipSecurity) {\n      const securityCheck = await performSecurityChecks(interaction);\n\n      if (!securityCheck.passed) {\n        await interaction.reply({\n          content: securityCheck.reason ?? 'Security check failed',\n          flags: MessageFlags.Ephemeral,\n        });\n        return { valid: false, error: securityCheck.reason };\n      }\n\n      // Apply stricter rate limits for suspicious users\n      if (securityCheck.suspicious && !options?.skipRateLimit) {\n        const suspiciousLimit = await rateLimiters.user.checkLimit(interaction.user.id, {\n          ...rateLimitConfigs.suspicious,\n          keyPrefix: 'suspicious',\n        });\n\n        if (!suspiciousLimit.allowed) {\n          logger.warn('Suspicious user rate limited:', {\n            userId: interaction.user.id,\n            username: interaction.user.username,\n            retryAfter: suspiciousLimit.retryAfter,\n          });\n\n          await interaction.reply({\n            content: `You are being rate limited. Please try again in ${suspiciousLimit.retryAfter} seconds.`,\n            flags: MessageFlags.Ephemeral,\n          });\n          return { valid: false, error: 'Rate limited (suspicious activity)' };\n        }\n      }\n    }\n\n    // Check for abuse patterns\n    const abusePatterns = await securityMonitor.checkAbusePatterns(interaction);\n    if (abusePatterns.length > 0 && abusePatterns.some(p => p.severity === 'high')) {\n      logger.warn('High severity abuse pattern detected:', {\n        userId: interaction.user.id,\n        patterns: abusePatterns,\n      });\n    }\n\n    // Rate limiting\n    if (!options?.skipRateLimit) {\n      // Per-user rate limit\n      const userRateLimit = await rateLimiters.user.checkLimit(\n        interaction.user.id,\n        options?.customRateLimitConfig ?? rateLimitConfigs.charts\n      );\n\n      if (!userRateLimit.allowed) {\n        await interaction.reply({\n          content: `You are being rate limited. Please try again in ${userRateLimit.retryAfter} seconds.`,\n          flags: MessageFlags.Ephemeral,\n        });\n        return { valid: false, error: 'User rate limited' };\n      }\n\n      // Per-guild rate limit (if in a guild)\n      if (interaction.guildId) {\n        const guildRateLimit = await rateLimiters.guild.checkLimit(interaction.guildId, {\n          ...rateLimitConfigs.guild,\n          keyPrefix: 'guild',\n        });\n\n        if (!guildRateLimit.allowed) {\n          await interaction.reply({\n            content: 'This server is being rate limited. Please try again later.',\n            flags: MessageFlags.Ephemeral,\n          });\n          return { valid: false, error: 'Guild rate limited' };\n        }\n      }\n    }\n\n    return { valid: true };\n  } catch (error) {\n    logger.error('Error in validation middleware:', error);\n    return { valid: false, error: 'Validation error occurred' };\n  }\n}\n\n/**\n * Sanitizes user input to prevent injection attacks\n */\nexport function sanitizeInput(input: string, maxLength: number = 100): string {\n  // Remove null bytes\n  let sanitized = input.replace(/\\0/g, '');\n\n  // Trim whitespace\n  sanitized = sanitized.trim();\n\n  // Limit length\n  if (sanitized.length > maxLength) {\n    sanitized = sanitized.substring(0, maxLength);\n  }\n\n  // Remove control characters except newlines and tabs\n  // Remove control characters except newlines and tabs\n  // eslint-disable-next-line no-control-regex\n  sanitized = sanitized.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\n\n  return sanitized;\n}\n\n/**\n * Logs command usage for monitoring\n */\nexport function logCommandUsage(interaction: CommandInteraction, success: boolean, error?: string): void {\n  const logData = {\n    userId: interaction.user.id,\n    username: interaction.user.username,\n    command: interaction.commandName,\n    subcommand: interaction.isChatInputCommand() ? interaction.options.getSubcommand(false) : undefined,\n    guildId: interaction.guildId,\n    guildName: interaction.guild?.name,\n    channelId: interaction.channelId,\n    success,\n    error,\n    timestamp: new Date().toISOString(),\n  };\n\n  if (success) {\n    logger.info('Command executed successfully:', logData);\n  } else {\n    logger.warn('Command execution failed:', logData);\n  }\n\n  // Log suspicious patterns for analysis\n  if (error?.includes('suspicious') || error?.includes('rate limit')) {\n    logger.warn('Potential abuse detected:', {\n      ...logData,\n      userCreatedAt: interaction.user.createdAt,\n      memberJoinedAt: interaction.inGuild()\n        ? interaction.guild?.members.cache.get(interaction.user.id)?.joinedAt\n        : undefined,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validation/rateLimiter.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":54,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":65},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":85,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":85,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Redis } from 'ioredis';\nimport { logger } from '../../logger';\nimport { redis } from '../../../infrastructure/cache/redis-client';\n\nexport interface RateLimitConfig {\n  maxRequests: number;\n  windowMs: number;\n  keyPrefix?: string;\n}\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  limit: number;\n  remaining: number;\n  resetAt: Date;\n  retryAfter?: number;\n}\n\nexport class RateLimiter {\n  private redis: Redis;\n  private defaultConfig: RateLimitConfig = {\n    maxRequests: 10,\n    windowMs: 60000, // 1 minute\n    keyPrefix: 'ratelimit',\n  };\n\n  constructor(redisClient?: Redis) {\n    this.redis = redisClient ?? redis;\n  }\n\n  /**\n   * Check if a request is allowed based on rate limits\n   */\n  async checkLimit(identifier: string, config?: Partial<RateLimitConfig>): Promise<RateLimitResult> {\n    const finalConfig = { ...this.defaultConfig, ...config };\n    const key = `${finalConfig.keyPrefix}:${identifier}`;\n    const now = Date.now();\n    const windowStart = now - finalConfig.windowMs;\n\n    try {\n      // Use Redis pipeline for atomic operations\n      const pipeline = this.redis.pipeline();\n\n      // Remove old entries outside the window\n      pipeline.zremrangebyscore(key, '-inf', windowStart);\n\n      // Count current requests in window\n      pipeline.zcard(key);\n\n      // Add current request\n      pipeline.zadd(key, now, `${now}-${Math.random()}`);\n\n      // Set expiry\n      pipeline.expire(key, Math.ceil(finalConfig.windowMs / 1000));\n\n      const results = await pipeline.exec();\n\n      if (!results) {\n        throw new Error('Redis pipeline execution failed');\n      }\n\n      const count = (results[1][1] as number) + 1; // Current count + new request\n      const allowed = count <= finalConfig.maxRequests;\n\n      // If not allowed, remove the request we just added\n      if (!allowed) {\n        await this.redis.zrem(key, `${now}-${Math.random()}`);\n      }\n\n      const remaining = Math.max(0, finalConfig.maxRequests - count);\n      const oldestEntry = await this.redis.zrange(key, 0, 0, 'WITHSCORES');\n      const resetAt =\n        oldestEntry.length > 1\n          ? new Date(parseInt(oldestEntry[1]) + finalConfig.windowMs)\n          : new Date(now + finalConfig.windowMs);\n\n      const result: RateLimitResult = {\n        allowed,\n        limit: finalConfig.maxRequests,\n        remaining: allowed ? remaining : remaining + 1,\n        resetAt,\n      };\n\n      if (!allowed) {\n        result.retryAfter = Math.ceil((resetAt.getTime() - now) / 1000);\n      }\n\n      return result;\n    } catch (error) {\n      logger.error('Rate limiter error:', error);\n      // On error, allow the request but log it\n      return {\n        allowed: true,\n        limit: finalConfig.maxRequests,\n        remaining: finalConfig.maxRequests,\n        resetAt: new Date(now + finalConfig.windowMs),\n      };\n    }\n  }\n\n  /**\n   * Get current rate limit status without incrementing\n   */\n  async getStatus(identifier: string, config?: Partial<RateLimitConfig>): Promise<RateLimitResult> {\n    const finalConfig = { ...this.defaultConfig, ...config };\n    const key = `${finalConfig.keyPrefix}:${identifier}`;\n    const now = Date.now();\n    const windowStart = now - finalConfig.windowMs;\n\n    try {\n      // Remove old entries and count current\n      await this.redis.zremrangebyscore(key, '-inf', windowStart);\n      const count = await this.redis.zcard(key);\n\n      const remaining = Math.max(0, finalConfig.maxRequests - count);\n      const oldestEntry = await this.redis.zrange(key, 0, 0, 'WITHSCORES');\n      const resetAt =\n        oldestEntry.length > 1\n          ? new Date(parseInt(oldestEntry[1]) + finalConfig.windowMs)\n          : new Date(now + finalConfig.windowMs);\n\n      return {\n        allowed: count < finalConfig.maxRequests,\n        limit: finalConfig.maxRequests,\n        remaining,\n        resetAt,\n      };\n    } catch (error) {\n      logger.error('Rate limiter status error:', error);\n      return {\n        allowed: true,\n        limit: finalConfig.maxRequests,\n        remaining: finalConfig.maxRequests,\n        resetAt: new Date(now + finalConfig.windowMs),\n      };\n    }\n  }\n\n  /**\n   * Reset rate limit for an identifier\n   */\n  async reset(identifier: string, keyPrefix?: string): Promise<void> {\n    const prefix = keyPrefix ?? this.defaultConfig.keyPrefix;\n    const key = `${prefix}:${identifier}`;\n\n    try {\n      await this.redis.del(key);\n      logger.info(`Rate limit reset for ${identifier}`);\n    } catch (error) {\n      logger.error('Rate limiter reset error:', error);\n    }\n  }\n}\n\n// Pre-configured rate limiters for different scenarios\nexport const rateLimiters = {\n  // Per-user rate limits\n  user: new RateLimiter(),\n\n  // Per-guild rate limits (more lenient)\n  guild: new RateLimiter(),\n\n  // Strict rate limit for potentially expensive operations\n  expensive: new RateLimiter(),\n};\n\n// Rate limit configurations for different command types\nexport const rateLimitConfigs = {\n  // Default for most commands\n  default: {\n    maxRequests: 10,\n    windowMs: 60000, // 10 requests per minute\n  },\n\n  // For chart generation commands (more expensive)\n  charts: {\n    maxRequests: 5,\n    windowMs: 60000, // 5 requests per minute\n  },\n\n  // For list/info commands (cheaper)\n  info: {\n    maxRequests: 20,\n    windowMs: 60000, // 20 requests per minute\n  },\n\n  // Guild-wide limits (shared across all users in a guild)\n  guild: {\n    maxRequests: 30,\n    windowMs: 60000, // 30 requests per minute per guild\n  },\n\n  // Suspicious activity (very strict)\n  suspicious: {\n    maxRequests: 1,\n    windowMs: 300000, // 1 request per 5 minutes\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validation/schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/discord/validation/securityMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[357,360],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[357,360],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3600000.","line":18,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":18,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 86400.","line":31,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":31,"endColumn":36},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'checkAbusePatterns' has too many lines (66). Maximum allowed is 50.","line":49,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":125,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":57,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":57,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 50.","line":74,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":74,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":91,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":91,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5137,5140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5137,5140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":195,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":195,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":214,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":214,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":214,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":214,"endColumn":59},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.5.","line":220,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":220,"endColumn":59},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":254,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":254,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":269,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":269,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 86400.","line":292,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":292,"endColumn":14},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3600.","line":335,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":335,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3600.","line":341,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":341,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3600.","line":346,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":346,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3600.","line":360,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":360,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CommandInteraction } from 'discord.js';\nimport { logger } from '../../logger';\nimport { redis } from '../../../infrastructure/cache/redis-client';\n\nexport interface SuspiciousActivity {\n  userId: string;\n  username: string;\n  guildId?: string;\n  pattern: string;\n  severity: 'low' | 'medium' | 'high';\n  timestamp: Date;\n  details?: Record<string, any>;\n}\n\nexport class SecurityMonitor {\n  private readonly SUSPICIOUS_KEY_PREFIX = 'security:suspicious';\n  private readonly ABUSE_KEY_PREFIX = 'security:abuse';\n  private readonly MONITOR_WINDOW = 3600000; // 1 hour\n\n  /**\n   * Log suspicious activity\n   */\n  async logSuspiciousActivity(activity: SuspiciousActivity): Promise<void> {\n    const key = `${this.SUSPICIOUS_KEY_PREFIX}:${activity.userId}`;\n\n    try {\n      // Store in Redis for tracking\n      await redis.zadd(key, Date.now(), JSON.stringify(activity));\n\n      // Set expiry\n      await redis.expire(key, 86400); // 24 hours\n\n      // Log to application logs\n      logger.warn('Suspicious activity detected:', {\n        ...activity,\n        timestamp: activity.timestamp.toISOString(),\n      });\n\n      // Check if user should be auto-blocked\n      await this.checkAutoBlock(activity.userId);\n    } catch (error) {\n      logger.error('Failed to log suspicious activity:', error);\n    }\n  }\n\n  /**\n   * Check for abuse patterns\n   */\n  async checkAbusePatterns(interaction: CommandInteraction): Promise<SuspiciousActivity[]> {\n    const patterns: SuspiciousActivity[] = [];\n    const userId = interaction.user.id;\n    const username = interaction.user.username;\n    const guildId = interaction.guildId ?? undefined;\n\n    // Pattern 1: Rapid command usage across multiple guilds\n    const recentGuilds = await this.getRecentGuilds(userId);\n    if (recentGuilds.size > 5) {\n      patterns.push({\n        userId,\n        username,\n        guildId,\n        pattern: 'rapid_multi_guild_usage',\n        severity: 'medium',\n        timestamp: new Date(),\n        details: {\n          guildCount: recentGuilds.size,\n          guilds: Array.from(recentGuilds),\n        },\n      });\n    }\n\n    // Pattern 2: Command flooding\n    const commandCount = await this.getRecentCommandCount(userId);\n    if (commandCount > 50) {\n      patterns.push({\n        userId,\n        username,\n        guildId,\n        pattern: 'command_flooding',\n        severity: 'high',\n        timestamp: new Date(),\n        details: {\n          commandCount,\n          timeWindow: '1 hour',\n        },\n      });\n    }\n\n    // Pattern 3: Failed validation attempts\n    const failedAttempts = await this.getFailedValidationCount(userId);\n    if (failedAttempts > 10) {\n      patterns.push({\n        userId,\n        username,\n        guildId,\n        pattern: 'excessive_failed_validations',\n        severity: 'medium',\n        timestamp: new Date(),\n        details: {\n          failedAttempts,\n        },\n      });\n    }\n\n    // Pattern 4: Suspicious timing patterns (e.g., exact intervals)\n    const timingPattern = await this.checkTimingPatterns(userId);\n    if (timingPattern.suspicious) {\n      patterns.push({\n        userId,\n        username,\n        guildId,\n        pattern: 'suspicious_timing',\n        severity: 'low',\n        timestamp: new Date(),\n        details: timingPattern.details,\n      });\n    }\n\n    // Log all detected patterns\n    for (const pattern of patterns) {\n      await this.logSuspiciousActivity(pattern);\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Get recent guilds a user has used commands in\n   */\n  private async getRecentGuilds(userId: string): Promise<Set<string>> {\n    const key = `${this.ABUSE_KEY_PREFIX}:guilds:${userId}`;\n    const guilds = new Set<string>();\n\n    try {\n      const recentActivity = await redis.zrangebyscore(key, Date.now() - this.MONITOR_WINDOW, Date.now());\n\n      recentActivity.forEach(entry => {\n        try {\n          const data = JSON.parse(entry);\n          if (data.guildId) guilds.add(data.guildId);\n        } catch (e) {\n          // Ignore parse errors\n        }\n      });\n    } catch (error) {\n      logger.error('Failed to get recent guilds:', error);\n    }\n\n    return guilds;\n  }\n\n  /**\n   * Get recent command count for a user\n   */\n  private async getRecentCommandCount(userId: string): Promise<number> {\n    const key = `${this.ABUSE_KEY_PREFIX}:commands:${userId}`;\n\n    try {\n      const count = await redis.zcount(key, Date.now() - this.MONITOR_WINDOW, Date.now());\n      return count;\n    } catch (error) {\n      logger.error('Failed to get command count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get failed validation count for a user\n   */\n  private async getFailedValidationCount(userId: string): Promise<number> {\n    const key = `${this.ABUSE_KEY_PREFIX}:failed:${userId}`;\n\n    try {\n      const count = await redis.get(key);\n      return parseInt(count ?? '0', 10);\n    } catch (error) {\n      logger.error('Failed to get failed validation count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Check for suspicious timing patterns\n   */\n  private async checkTimingPatterns(userId: string): Promise<{\n    suspicious: boolean;\n    details?: Record<string, any>;\n  }> {\n    const key = `${this.ABUSE_KEY_PREFIX}:timing:${userId}`;\n\n    try {\n      // Get recent command timestamps\n      const timestamps = await redis.zrangebyscore(key, Date.now() - this.MONITOR_WINDOW, Date.now(), 'WITHSCORES');\n\n      if (timestamps.length < 10) {\n        return { suspicious: false };\n      }\n\n      // Extract just the scores (timestamps)\n      const times: number[] = [];\n      for (let i = 1; i < timestamps.length; i += 2) {\n        times.push(parseFloat(timestamps[i]));\n      }\n\n      // Calculate intervals\n      const intervals: number[] = [];\n      for (let i = 1; i < times.length; i++) {\n        intervals.push(times[i] - times[i - 1]);\n      }\n\n      // Check for exact intervals (bot-like behavior)\n      const intervalCounts = new Map<number, number>();\n      intervals.forEach(interval => {\n        const rounded = Math.round(interval / 1000) * 1000; // Round to nearest second\n        intervalCounts.set(rounded, (intervalCounts.get(rounded) ?? 0) + 1);\n      });\n\n      // If more than 50% of intervals are the same, it's suspicious\n      const maxCount = Math.max(...intervalCounts.values());\n      const suspicious = maxCount > intervals.length * 0.5;\n\n      return {\n        suspicious,\n        details: suspicious\n          ? {\n              totalCommands: times.length,\n              commonInterval: Array.from(intervalCounts.entries()).find(([, count]) => count === maxCount)?.[0],\n              intervalDistribution: Object.fromEntries(intervalCounts),\n            }\n          : undefined,\n      };\n    } catch (error) {\n      logger.error('Failed to check timing patterns:', error);\n      return { suspicious: false };\n    }\n  }\n\n  /**\n   * Check if user should be auto-blocked based on suspicious activity\n   */\n  private async checkAutoBlock(userId: string): Promise<void> {\n    const key = `${this.SUSPICIOUS_KEY_PREFIX}:${userId}`;\n\n    try {\n      // Get recent suspicious activities\n      const activities = await redis.zrangebyscore(key, Date.now() - this.MONITOR_WINDOW, Date.now());\n\n      let severityScore = 0;\n      activities.forEach(activityStr => {\n        try {\n          const activity: SuspiciousActivity = JSON.parse(activityStr);\n          switch (activity.severity) {\n            case 'high':\n              severityScore += 3;\n              break;\n            case 'medium':\n              severityScore += 2;\n              break;\n            case 'low':\n              severityScore += 1;\n              break;\n          }\n        } catch (e) {\n          // Ignore parse errors\n        }\n      });\n\n      // Auto-block if severity score is too high\n      if (severityScore >= 10) {\n        await this.blockUser(userId, 'Automatic block due to suspicious activity');\n      }\n    } catch (error) {\n      logger.error('Failed to check auto-block:', error);\n    }\n  }\n\n  /**\n   * Block a user from using commands\n   */\n  async blockUser(userId: string, reason: string): Promise<void> {\n    const key = `${this.ABUSE_KEY_PREFIX}:blocked:${userId}`;\n\n    try {\n      await redis.set(\n        key,\n        JSON.stringify({\n          reason,\n          timestamp: new Date().toISOString(),\n          blockedBy: 'system',\n        }),\n        'EX',\n        86400\n      ); // 24 hour block\n\n      logger.warn('User blocked:', {\n        userId,\n        reason,\n      });\n    } catch (error) {\n      logger.error('Failed to block user:', error);\n    }\n  }\n\n  /**\n   * Check if a user is blocked\n   */\n  async isUserBlocked(userId: string): Promise<{ blocked: boolean; reason?: string }> {\n    const key = `${this.ABUSE_KEY_PREFIX}:blocked:${userId}`;\n\n    try {\n      const blockData = await redis.get(key);\n      if (blockData) {\n        const parsed = JSON.parse(blockData);\n        return { blocked: true, reason: parsed.reason };\n      }\n      return { blocked: false };\n    } catch (error) {\n      logger.error('Failed to check user block status:', error);\n      return { blocked: false };\n    }\n  }\n\n  /**\n   * Track command usage for monitoring\n   */\n  async trackCommandUsage(interaction: CommandInteraction): Promise<void> {\n    const userId = interaction.user.id;\n    const guildId = interaction.guildId;\n\n    try {\n      // Track guilds\n      if (guildId) {\n        const guildKey = `${this.ABUSE_KEY_PREFIX}:guilds:${userId}`;\n        await redis.zadd(guildKey, Date.now(), JSON.stringify({ guildId }));\n        await redis.expire(guildKey, 3600); // 1 hour\n      }\n\n      // Track command count\n      const commandKey = `${this.ABUSE_KEY_PREFIX}:commands:${userId}`;\n      await redis.zadd(commandKey, Date.now(), interaction.id);\n      await redis.expire(commandKey, 3600); // 1 hour\n\n      // Track timing\n      const timingKey = `${this.ABUSE_KEY_PREFIX}:timing:${userId}`;\n      await redis.zadd(timingKey, Date.now(), interaction.id);\n      await redis.expire(timingKey, 3600); // 1 hour\n    } catch (error) {\n      logger.error('Failed to track command usage:', error);\n    }\n  }\n\n  /**\n   * Track failed validation\n   */\n  async trackFailedValidation(userId: string): Promise<void> {\n    const key = `${this.ABUSE_KEY_PREFIX}:failed:${userId}`;\n\n    try {\n      await redis.incr(key);\n      await redis.expire(key, 3600); // 1 hour\n    } catch (error) {\n      logger.error('Failed to track failed validation:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const securityMonitor = new SecurityMonitor();\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/errors/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[183,186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[183,186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[401,404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[401,404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 400.","line":16,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":16,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[590,593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[590,593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 401.","line":22,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":22,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[773,776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[773,776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 403.","line":28,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":28,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[954,957],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[954,957],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 404.","line":34,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":34,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1127,1130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1127,1130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 429.","line":40,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1319,1322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1319,1322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1532,1535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1532,1535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":52,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1714,1717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1714,1717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":58,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":58,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class AppError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_SERVER_ERROR',\n    public details?: any\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, details?: any) {\n    super(message, 400, 'VALIDATION_ERROR', details);\n  }\n}\n\nexport class AuthenticationError extends AppError {\n  constructor(message: string = 'Authentication required', details?: any) {\n    super(message, 401, 'AUTHENTICATION_ERROR', details);\n  }\n}\n\nexport class AuthorizationError extends AppError {\n  constructor(message: string = 'Not authorized', details?: any) {\n    super(message, 403, 'AUTHORIZATION_ERROR', details);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found', details?: any) {\n    super(message, 404, 'NOT_FOUND', details);\n  }\n}\n\nexport class RateLimitError extends AppError {\n  constructor(message: string = 'Rate limit exceeded', details?: any) {\n    super(message, 429, 'RATE_LIMIT_EXCEEDED', details);\n  }\n}\n\nexport class ExternalServiceError extends AppError {\n  constructor(message: string = 'External service error', details?: any, statusCode: number = 502) {\n    super(message, statusCode, 'EXTERNAL_SERVICE_ERROR', details);\n  }\n}\n\nexport class DatabaseError extends AppError {\n  constructor(message: string = 'Database error', details?: any) {\n    super(message, 500, 'DATABASE_ERROR', details);\n  }\n}\n\nexport class ConfigurationError extends AppError {\n  constructor(message: string = 'Configuration error', details?: any) {\n    super(message, 500, 'CONFIGURATION_ERROR', details);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/esi.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'fetchESIKillmail' has too many lines (63). Maximum allowed is 50.","line":78,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":145,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { logger } from './logger';\n\ninterface ESIKillmail {\n  killmail_id: number;\n  killmail_time: string;\n  solar_system_id: number;\n  victim: {\n    character_id?: number;\n    corporation_id?: number;\n    alliance_id?: number;\n    ship_type_id: number;\n    damage_taken: number;\n    position: { x: number; y: number; z: number };\n    items: Array<{\n      type_id: number;\n      flag: number;\n      quantity_destroyed?: number;\n      quantity_dropped?: number;\n      singleton: number;\n    }>;\n  };\n  attackers: Array<{\n    character_id?: number;\n    corporation_id?: number;\n    alliance_id?: number;\n    damage_done: number;\n    final_blow: boolean;\n    security_status: number;\n    ship_type_id: number;\n    weapon_type_id: number;\n  }>;\n}\n\nconst MAX_RETRIES = 3;\nconst INITIAL_RETRY_DELAY = 1000; // 1 second\n\nasync function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function fetchWithRetry<T>(url: string, retryCount = 0, delay = INITIAL_RETRY_DELAY): Promise<T> {\n  try {\n    const response = await axios.get<T>(url);\n    return response.data;\n  } catch (error) {\n    if (retryCount >= MAX_RETRIES) {\n      throw error;\n    }\n\n    // Check if we should retry based on error type\n    const shouldRetry =\n      error instanceof Error &&\n      (error.message.includes('429') || // Rate limit\n        error.message.includes('503') || // Service unavailable\n        error.message.includes('504') || // Gateway timeout\n        error.message.includes('ECONNRESET') || // Connection reset\n        error.message.includes('ETIMEDOUT')); // Connection timeout\n\n    if (!shouldRetry) {\n      throw error;\n    }\n\n    // Calculate exponential backoff delay\n    const nextDelay = delay * Math.pow(2, retryCount);\n    logger.warn('ESI request failed, retrying...', {\n      url,\n      retryCount: retryCount + 1,\n      nextDelay,\n      error: error instanceof Error ? error.message : error,\n    });\n\n    await sleep(nextDelay);\n    return fetchWithRetry<T>(url, retryCount + 1, nextDelay);\n  }\n}\n\nexport async function fetchESIKillmail(killId: number, hash: string, retryCount = 0): Promise<ESIKillmail> {\n  try {\n    // In test environment, return mock data\n    if (process.env.NODE_ENV === 'test') {\n      return {\n        killmail_id: killId,\n        killmail_time: new Date().toISOString(),\n        solar_system_id: 30000142,\n        victim: {\n          character_id: 123456,\n          corporation_id: 98765,\n          alliance_id: 54321,\n          ship_type_id: 670,\n          damage_taken: 100,\n          position: { x: 0, y: 0, z: 0 },\n          items: [],\n        },\n        attackers: [\n          {\n            character_id: 987654,\n            corporation_id: 56789,\n            alliance_id: 12345,\n            damage_done: 100,\n            final_blow: true,\n            security_status: 0,\n            ship_type_id: 603,\n            weapon_type_id: 587,\n          },\n        ],\n      };\n    }\n\n    const url = `https://esi.evetech.net/latest/killmails/${killId}/${hash}/?datasource=tranquility`;\n    return await fetchWithRetry<ESIKillmail>(url);\n  } catch (error) {\n    if (retryCount >= MAX_RETRIES) {\n      logger.error(\n        {\n          error,\n          killId,\n          hash,\n          retryCount,\n          errorMessage: error instanceof Error ? error.message : error,\n          errorStack: error instanceof Error ? error.stack : undefined,\n        },\n        'Max retries reached for ESI fetch'\n      );\n      throw error;\n    }\n\n    // Calculate exponential backoff delay\n    const delay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);\n    logger.warn(\n      {\n        error,\n        killId,\n        hash,\n        retryCount: retryCount + 1,\n        delay,\n        errorMessage: error instanceof Error ? error.message : error,\n      },\n      'Error fetching ESI data, retrying...'\n    );\n\n    await sleep(delay);\n    return fetchESIKillmail(killId, hash, retryCount + 1);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/logger.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":15,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[419,489],"text":""},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const pino = require('pino');\nimport { config } from 'dotenv';\n\n// Load environment variables\nconfig();\n\n// Define log levels\nconst LOG_LEVELS = {\n  error: 50,\n  warn: 40,\n  info: 30,\n  debug: 20,\n  trace: 10,\n} as const;\n\n// Get log level from environment or default to info\nconst logLevel = (process.env.LOG_LEVEL ?? 'debug').toLowerCase();\n\n// Validate log level\nif (!Object.keys(LOG_LEVELS).includes(logLevel)) {\n  console.warn(`Invalid LOG_LEVEL \"${logLevel}\", defaulting to \"info\"`);\n}\n\n// Create base logger configuration\nconst baseConfig = {\n  level: logLevel,\n  formatters: {\n    level: (label: string) => {\n      return { level: label };\n    },\n  },\n};\n\n// Development configuration with pretty printing\nconst devConfig = {\n  ...baseConfig,\n  transport: {\n    target: 'pino-pretty',\n    options: {\n      colorize: true,\n      translateTime: 'HH:MM:ss',\n      ignore: 'pid,hostname',\n      messageFormat: '{msg}',\n      singleLine: true,\n    },\n  },\n};\n\n// Production configuration (JSON format)\nconst prodConfig = {\n  ...baseConfig,\n  timestamp: () => `,\"time\":\"${new Date().toISOString()}\"`,\n};\n\n// Create logger instance based on environment\nconst logger = pino(process.env.NODE_ENV === 'production' ? prodConfig : devConfig);\n\n// Create child logger with context\nexport function createLogger(context: string) {\n  return logger.child({ context });\n}\n\n// Export log levels for type safety\nexport const logLevels = LOG_LEVELS;\nexport { logger };\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/lib/sentry.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.1.","line":28,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":28,"endColumn":59},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[925,928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[925,928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":112,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":115,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1369,1372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1369,1372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as Sentry from '@sentry/node';\nimport { httpIntegration } from '@sentry/node';\nimport { logger } from './logger';\n\n/**\n * Initialize Sentry error monitoring\n */\nexport function initSentry() {\n  const dsn = process.env.SENTRY_DSN;\n  const environment = process.env.NODE_ENV ?? 'development';\n\n  if (!dsn) {\n    logger.debug('SENTRY_DSN not set, error monitoring disabled');\n    return;\n  }\n\n  try {\n    Sentry.init({\n      dsn,\n      environment,\n      integrations: [\n        httpIntegration({\n          breadcrumbs: true,\n          spans: true,\n        }),\n      ],\n      // Performance Monitoring\n      tracesSampleRate: environment === 'production' ? 0.1 : 1.0,\n    });\n\n    logger.info('Sentry initialized successfully');\n  } catch (error) {\n    logger.error('Failed to initialize Sentry:', error);\n  }\n}\n\n/**\n * Capture an error in Sentry\n */\nexport function captureError(error: Error, context?: Record<string, any>) {\n  if (error instanceof Error) {\n    Sentry.withScope(scope => {\n      if (context) {\n        scope.setExtras(context);\n      }\n      Sentry.captureException(error);\n    });\n  } else {\n    Sentry.captureMessage(String(error), {\n      level: 'error',\n      extra: context,\n    });\n  }\n}\n\n/**\n * Capture a message in Sentry\n */\nexport function captureMessage(message: string, level: Sentry.SeverityLevel = 'info', context?: Record<string, any>) {\n  Sentry.withScope(scope => {\n    if (context) {\n      scope.setExtras(context);\n    }\n    Sentry.captureMessage(message, level);\n  });\n}\n\nexport { Sentry };\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/server.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 15.","line":52,"column":15,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":17},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":52,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":22},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":52,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":29},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":132,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":132,"endColumn":19},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":147,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":19},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 400.","line":198,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":198,"endColumn":21},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":201,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":201,"endColumn":21},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":208,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":208,"endColumn":63},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":238,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":238,"endColumn":19},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 500.","line":259,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":259,"endColumn":19},{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'startServer' has too many lines (76). Maximum allowed is 50.","line":264,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":374,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":291,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":291,"endColumn":98},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":293,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":293,"endColumn":75},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":303,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":303,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":311,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":311,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5000.","line":318,"column":10,"nodeType":"Literal","messageId":"noMagic","endLine":318,"endColumn":14},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":329,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":59},{"ruleId":"no-process-exit","severity":2,"message":"Don't use process.exit(); throw an error instead.","line":366,"column":7,"nodeType":"CallExpression","messageId":"noProcessExit","endLine":366,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'reflect-metadata';\nimport express, { RequestHandler } from 'express';\nimport { logger } from './lib/logger';\nimport { WebSocketIngestionService } from './services/ingestion/WebSocketIngestionService';\nimport { config as dotenvConfig } from 'dotenv';\nimport cors from 'cors';\nimport bodyParser from 'body-parser';\nimport rateLimit from 'express-rate-limit';\nimport { DiscordClient } from './lib/discord/client';\nimport { commands } from './lib/discord/commands';\nimport { ChartService } from './services/ChartService';\nimport { ChartRenderer } from './services/ChartRenderer';\nimport { ChartConfigInput } from './types/chart';\nimport { z } from 'zod';\nimport { initSentry } from './lib/sentry';\nimport { MapActivityService } from './services/ingestion/MapActivityService';\nimport { CharacterSyncService } from './services/ingestion/CharacterSyncService';\nimport { CharacterRepository } from './infrastructure/repositories/CharacterRepository';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { Configuration } from './config';\nimport { PrismaClient } from '@prisma/client';\nimport { timerManager } from './utils/timerManager';\nimport { rateLimiterManager } from './utils/RateLimiterManager';\n\nconst execAsync = promisify(exec);\n\n// Load environment variables\ndotenvConfig();\n\n// Initialize Sentry\ninitSentry();\n\n// Initialize Prisma\nconst prisma = new PrismaClient();\n\n// Constants\nconst appStartTime = Date.now();\nconst port =\n  Configuration.server.nodeEnv === 'test'\n    ? 0 // Use random port for tests\n    : Configuration.server.port;\n\n// Create Express app\nconst app = express();\n\n// Middleware\napp.use(cors());\napp.use(bodyParser.json());\napp.use(\n  rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // limit each IP to 100 requests per windowMs\n  })\n);\n\n// Initialize services\nconst websocketService = new WebSocketIngestionService(\n  {\n    url: Configuration.websocket.url,\n    reconnectIntervalMs: Configuration.websocket.reconnectIntervalMs,\n    maxReconnectAttempts: Configuration.websocket.maxReconnectAttempts,\n    timeout: Configuration.websocket.timeout,\n    preload: Configuration.websocket.preload,\n  },\n  prisma\n);\n\nconst mapService = new MapActivityService(\n  Configuration.apis.map.url,\n  Configuration.apis.map.key,\n  Configuration.redis.url,\n  Configuration.redis.cacheTtl,\n  Configuration.http.maxRetries,\n  Configuration.http.initialRetryDelay\n);\n\nconst characterService = new CharacterSyncService(\n  Configuration.apis.map.url,\n  Configuration.apis.map.key,\n  Configuration.http.maxRetries,\n  Configuration.http.initialRetryDelay\n);\n\nconst chartService = new ChartService();\nconst chartRenderer = new ChartRenderer();\n\n// Initialize repositories\nconst characterRepository = new CharacterRepository(prisma);\n\n// Initialize Discord client\nconst discordClient = new DiscordClient();\n\n// Validation schemas\nconst chartConfigSchema = z.object({\n  type: z.enum(['kills', 'map_activity']),\n  characterIds: z.array(z.bigint()),\n  period: z.enum(['24h', '7d', '30d', '90d']),\n  groupBy: z.enum(['hour', 'day', 'week']).optional(),\n});\n\n// Health check endpoint\napp.get('/health', (_req, res) => {\n  res.json({ status: 'ok' });\n});\n\n// WebSocket service status endpoint\napp.get('/api/websocket/status', (_req, res) => {\n  const status = websocketService.getStatus();\n  res.json(status);\n});\n\n// Character management endpoints\napp.post('/api/characters/:characterId', async (req, res) => {\n  try {\n    const characterId = BigInt(req.params.characterId);\n    const character = await characterRepository.upsertCharacter({\n      eveId: characterId,\n      name: req.body.name,\n      corporationId: req.body.corporationId,\n      corporationTicker: req.body.corporationTicker,\n      allianceId: req.body.allianceId,\n      allianceTicker: req.body.allianceTicker,\n    });\n\n    // Update WebSocket subscriptions\n    await websocketService.updateCharacterSubscriptions([Number(characterId)]);\n\n    res.json({ success: true, character });\n  } catch (error) {\n    logger.error('Failed to add character', error);\n    res.status(500).json({ error: 'Failed to add character' });\n  }\n});\n\napp.delete('/api/characters/:characterId', async (req, res) => {\n  try {\n    const characterId = BigInt(req.params.characterId);\n    await characterRepository.deleteCharacter(characterId);\n\n    // Update WebSocket subscriptions\n    await websocketService.updateCharacterSubscriptions(undefined, [Number(characterId)]);\n\n    res.json({ success: true });\n  } catch (error) {\n    logger.error('Failed to remove character', error);\n    res.status(500).json({ error: 'Failed to remove character' });\n  }\n});\n\n// Get available chart types\napp.get('/v1/charts/types', (_req, res) => {\n  res.json({\n    types: [\n      {\n        id: 'kills',\n        name: 'Kill Chart',\n        description: 'Generate a chart showing kill activity',\n        periods: ['24h', '7d', '30d', '90d'],\n        groupBy: ['hour', 'day', 'week'],\n      },\n      {\n        id: 'map_activity',\n        name: 'Map Activity Chart',\n        description: 'Generate a chart showing map activity',\n        periods: ['24h', '7d', '30d'],\n        groupBy: ['hour', 'day'],\n      },\n    ],\n  });\n});\n\n// Generate chart endpoint\napp.post('/v1/charts/generate', (async (req, res) => {\n  try {\n    // Validate request\n    const config = chartConfigSchema.parse(req.body);\n\n    // Convert config to ChartConfigInput\n    const chartConfig: ChartConfigInput = {\n      type: config.type,\n      characterIds: config.characterIds,\n      period: config.period,\n      groupBy: config.groupBy,\n    };\n\n    // Generate chart data\n    const chartData = await chartService.generateChart(chartConfig);\n\n    // Render chart to buffer\n    const buffer = await chartRenderer.renderToBuffer(chartData);\n\n    // Send image\n    res.contentType('image/png');\n    res.send(buffer);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      res.status(400).json({ error: 'Invalid request', details: error.errors });\n    } else {\n      logger.error('Error generating chart:', error);\n      res.status(500).json({ error: 'Failed to generate chart' });\n    }\n  }\n}) as RequestHandler);\n\n// Status endpoint\napp.get('/status', (_req, res) => {\n  const uptime = Math.floor((Date.now() - appStartTime) / 1000);\n  const status = {\n    uptime,\n    services: {\n      websocket: websocketService.getStatus(),\n      discord: {\n        connected: discordClient.isReady(),\n        guilds: discordClient.getGuildsCount(),\n      },\n    },\n    version: process.env.npm_package_version ?? 'unknown',\n  };\n  res.json(status);\n});\n\n// Diagnostics endpoints\napp.get('/api/diagnostics/tracked-characters', async (_req, res) => {\n  try {\n    const characters = await characterRepository.getAllCharacters();\n    res.json({\n      count: characters.length,\n      characters: characters.map(char => ({\n        id: char.eveId.toString(),\n        name: char.name,\n        corporationId: char.corporationId,\n        allianceId: char.allianceId,\n      })),\n    });\n  } catch (error) {\n    logger.error('Failed to get tracked characters', error);\n    res.status(500).json({ error: 'Failed to get tracked characters' });\n  }\n});\n\napp.get('/api/diagnostics/character-groups', async (_req, res) => {\n  try {\n    const groups = await characterRepository.getAllCharacterGroups();\n    res.json({\n      count: groups.length,\n      groups: groups.map(group => ({\n        id: group.id,\n        mainCharacterId: group.mainCharacterId?.toString(),\n        characterCount: group.characters.length,\n        characters: group.characters.map(char => ({\n          id: char.eveId.toString(),\n          name: char.name,\n        })),\n      })),\n    });\n  } catch (error) {\n    logger.error('Failed to get character groups', error);\n    res.status(500).json({ error: 'Failed to get character groups' });\n  }\n});\n\n// Start the server\nasync function startServer() {\n  logger.info('Starting EVE Chart Bot server...');\n\n  // Run database migrations\n  logger.info('Running database migrations...');\n  try {\n    const { stderr } = await execAsync('npx prisma migrate deploy');\n    if (stderr) {\n      logger.warn('Migration warnings:', stderr);\n    }\n  } catch (error) {\n    logger.error('Error running migrations:', error);\n    throw error;\n  }\n\n  // Start services\n  await characterService.start();\n  await mapService.start();\n\n  // Initialize WebSocket service\n  await websocketService.start();\n\n  // Initialize Discord if token is available\n  const discordToken = Configuration.discord.token;\n  if (discordToken) {\n    try {\n      const discordStartTime = Date.now();\n      logger.info(`Discord initialization starting... (${(discordStartTime - appStartTime) / 1000}s after app start)`);\n\n      logger.debug('Found Discord token:', `${discordToken.substring(0, 10)}...`);\n\n      // Login to Discord\n      logger.info('Logging in to Discord...');\n      await discordClient.login(discordToken);\n      await discordClient.registerCommands(commands);\n      const loginTime = Date.now();\n      logger.info(\n        `Discord login successful - Client ready state: ${\n          discordClient.isReady() ? 'Ready' : 'Not Ready'\n        } (${(loginTime - discordStartTime) / 1000}s)`\n      );\n\n      // Add specific Discord readiness log\n      timerManager.setTimeout(() => {\n        const readyCheckTime = Date.now();\n        logger.info(\n          `Discord client status check after 5 seconds: (Total time since app start: ${\n            (readyCheckTime - appStartTime) / 1000\n          }s)`,\n          {\n            ready: discordClient.isReady() ? 'Yes' : 'No',\n            guilds: discordClient.getGuildsCount(),\n          }\n        );\n      }, 5000);\n    } catch (error) {\n      logger.error('Failed to initialize Discord:', error);\n      // Don't throw - allow server to continue without Discord\n    }\n  } else {\n    logger.warn('Discord token not found, Discord integration will be disabled');\n  }\n\n  // Start Express server\n  const server = app.listen(port, () => {\n    const startupTime = (Date.now() - appStartTime) / 1000;\n    logger.info(`Server is running on port ${port} (startup took ${startupTime}s)`);\n  });\n\n  // Graceful shutdown\n  const shutdown = async (signal: string) => {\n    logger.info(`${signal} received, shutting down gracefully...`);\n\n    // Get timer stats before shutdown\n    const timerStats = timerManager.getStats();\n    logger.info('Timer statistics before shutdown:', timerStats);\n\n    // Stop accepting new connections\n    server.close(() => {\n      logger.info('HTTP server closed');\n    });\n\n    // Stop services\n    await websocketService.stop();\n    await mapService.close();\n    await characterService.close();\n\n    // Disconnect Discord\n    if (discordClient.isReady()) {\n      // Discord.js Client doesn't have destroy, just disconnect\n      await discordClient.client.destroy();\n    }\n\n    // Clean up rate limiters\n    rateLimiterManager.cleanup();\n\n    // Close database connection\n    await prisma.$disconnect();\n\n    logger.info('Shutdown complete');\n    // Note: In production, process.exit should be called by process manager\n    if (Configuration.server.nodeEnv !== 'production') {\n      process.exit(0);\n    }\n  };\n\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n\n  return server;\n}\n\n// Export for testing\nexport { app, startServer };\n\n// Start server if not in test mode\nif (Configuration.server.nodeEnv !== 'test') {\n  startServer().catch(error => {\n    logger.error('Failed to start server:', {\n      error,\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n    throw error;\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/CharacterService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5147,5150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5147,5150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Character } from '../domain/character/Character';\nimport { CharacterGroup } from '../domain/character/CharacterGroup';\nimport { CharacterRepository } from '../infrastructure/repositories/CharacterRepository';\nimport { logger } from '../lib/logger';\nimport { ESIService } from './ESIService';\nimport { PrismaClient } from '@prisma/client';\n\n/**\n * Service for handling character-related business logic\n */\nexport class CharacterService {\n  private characterRepository: CharacterRepository;\n  private esiService: ESIService;\n\n  constructor() {\n    const prisma = new PrismaClient();\n    this.characterRepository = new CharacterRepository(prisma);\n    this.esiService = new ESIService();\n  }\n\n  /**\n   * Get a character by ID\n   */\n  async getCharacter(characterId: string): Promise<Character | null> {\n    return this.characterRepository.getCharacter(BigInt(characterId));\n  }\n\n  /**\n   * Get all characters\n   */\n  async getAllCharacters(): Promise<Character[]> {\n    return this.characterRepository.getAllCharacters();\n  }\n\n  /**\n   * Get characters by group ID\n   */\n  async getCharactersByGroup(groupId: string): Promise<Character[]> {\n    return this.characterRepository.getCharactersByGroup(groupId);\n  }\n\n  /**\n   * Get a character group by ID\n   */\n  async getCharacterGroup(groupId: string): Promise<CharacterGroup | null> {\n    return this.characterRepository.getCharacterGroup(groupId);\n  }\n\n  /**\n   * Get all character groups\n   */\n  async getAllCharacterGroups(): Promise<CharacterGroup[]> {\n    return this.characterRepository.getAllCharacterGroups();\n  }\n\n  /**\n   * Save a character\n   */\n  async saveCharacter(character: Character): Promise<Character> {\n    return this.characterRepository.upsertCharacter({\n      eveId: BigInt(character.eveId),\n      name: character.name,\n      corporationId: character.corporationId,\n      corporationTicker: character.corporationTicker,\n      allianceId: character.allianceId,\n      allianceTicker: character.allianceTicker,\n      characterGroupId: character.characterGroupId,\n    });\n  }\n\n  /**\n   * Save a character group\n   */\n  async saveCharacterGroup(group: CharacterGroup): Promise<CharacterGroup> {\n    return this.characterRepository.createCharacterGroup({\n      map_name: group.map_name,\n      mainCharacterId: group.mainCharacterId ? BigInt(group.mainCharacterId) : null,\n    });\n  }\n\n  /**\n   * Delete a character\n   */\n  async deleteCharacter(characterId: string): Promise<void> {\n    await this.characterRepository.deleteCharacter(BigInt(characterId));\n  }\n\n  /**\n   * Delete a character group\n   */\n  async deleteCharacterGroup(groupId: string): Promise<void> {\n    // This method needs to be implemented in CharacterRepository\n    // TODO: Implement using groupId parameter\n    void groupId; // Suppress unused variable warning\n    throw new Error('deleteCharacterGroup not implemented');\n  }\n\n  /**\n   * Set a character as the main character in a group\n   */\n  async setMainCharacter(characterId: string): Promise<CharacterGroup> {\n    // This method needs to be implemented in CharacterRepository\n    // TODO: Implement using characterId parameter\n    void characterId; // Suppress unused variable warning\n    throw new Error('setMainCharacter not implemented');\n  }\n\n  /**\n   * Remove a character from a group\n   */\n  async removeFromGroup(characterId: string): Promise<Character> {\n    // This method needs to be implemented in CharacterRepository\n    // TODO: Implement using characterId parameter\n    void characterId; // Suppress unused variable warning\n    throw new Error('removeFromGroup not implemented');\n  }\n\n  /**\n   * Sync character information from Map API data\n   */\n  async syncCharacter(\n    characterId: string,\n    mapData: {\n      corporationTicker: string;\n      allianceTicker?: string | null;\n      corporationId: number;\n    }\n  ): Promise<Character> {\n    try {\n      logger.info(`Syncing character ${characterId} from Map API data...`);\n\n      // Create or update character using only map data\n      const character = new Character({\n        eveId: characterId,\n        name: characterId, // We don't need the name since it can't change\n        allianceTicker: mapData.allianceTicker ?? undefined,\n        corporationTicker: mapData.corporationTicker,\n        corporationId: mapData.corporationId,\n      });\n\n      logger.debug(`Created character object:`, character);\n\n      const saved = await this.saveCharacter(character);\n      logger.info(`Successfully synced character ${characterId}`);\n      return saved;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n\n      logger.error(\n        {\n          error,\n          characterId,\n          errorMessage,\n          errorStack,\n        },\n        `Failed to sync character ${characterId}: ${errorMessage}`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Sync multiple characters from ESI\n   */\n  async syncCharacters(characterIds: string[]): Promise<Character[]> {\n    const results: Character[] = [];\n    const errors: Array<{ characterId: string; error: any }> = [];\n\n    for (const characterId of characterIds) {\n      try {\n        // Get character data from ESI\n        const esiData = await this.esiService.getCharacter(parseInt(characterId, 10));\n        if (!esiData) {\n          throw new Error(`No ESI data found for character ${characterId}`);\n        }\n\n        const character = await this.syncCharacter(characterId, {\n          corporationTicker: esiData.corporation_ticker,\n          allianceTicker: esiData.alliance_ticker,\n          corporationId: esiData.corporation_id,\n        });\n        results.push(character);\n      } catch (error) {\n        errors.push({ characterId, error });\n        logger.error(`Failed to sync character ${characterId}:`, error);\n      }\n    }\n\n    if (errors.length > 0) {\n      logger.warn(`Completed character sync with ${errors.length} errors out of ${characterIds.length} characters`);\n    } else {\n      logger.info(`Successfully synced all ${characterIds.length} characters`);\n    }\n\n    return results;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ChartRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[974,977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[974,977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'convertToChartJSData' has too many lines (51). Maximum allowed is 50.","line":37,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":90,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1219,1222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1219,1222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 11. Maximum allowed is 10.","line":38,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":84,"endColumn":6},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.8.","line":44,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":110},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.4.","line":54,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'_type' is defined but never used.","line":116,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":116,"endColumn":59},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":126,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":127,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":127,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":128,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":128,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":128,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":128,"endColumn":42},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'createChartConfig' has too many lines (66). Maximum allowed is 50.","line":137,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":205,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4034,4037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4034,4037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4119,4122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4119,4122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4773,4776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4773,4776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 800.","line":213,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":213,"endColumn":55},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 400.","line":213,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":213,"endColumn":78}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Use require() for CommonJS modules with ESM dependencies\n// @ts-ignore - Ignoring type checking for Chart.js imports\nconst chartJS = require('chart.js');\nconst { Chart, registerables } = chartJS;\n\nimport { createCanvas } from 'canvas';\nimport { logger } from '../lib/logger';\nimport { theme, chartPalette } from './charts/config/theme';\nimport { ChartData as CustomChartData, ChartOptions as CustomChartOptions } from '../types/chart';\n\n// Register Chart.js components in non-test environments\nif (process.env.NODE_ENV !== 'test') {\n  try {\n    Chart.register(...registerables);\n  } catch (e) {\n    logger.warn('Failed to register Chart.js components', e);\n  }\n}\n\nexport class ChartRenderer {\n  // These dimensions are used by the constructor but not referenced elsewhere\n  // @ts-expect-error - Used in constructor\n  private width: number;\n  // @ts-expect-error - Used in constructor\n  private height: number;\n  private colors: string[] = chartPalette;\n  private chart: any = null;\n\n  constructor(width: number = 1200, height: number = 800) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Convert custom chart data to Chart.js format\n   */\n  private convertToChartJSData(data: CustomChartData): any {\n    const datasets = data.datasets.map((dataset, index) => {\n      const type = this.getChartType(dataset.displayType ?? dataset.type);\n      const baseDataset = {\n        ...dataset,\n        type,\n        backgroundColor: dataset.backgroundColor ?? this.getBackgroundColor(index, type),\n        borderColor: dataset.borderColor ?? this.adjustColorOpacity(this.getBackgroundColor(index, type), 0.8),\n        borderWidth: dataset.borderWidth ?? 1,\n      };\n\n      // Add type-specific properties\n      switch (type) {\n        case 'line':\n          return {\n            ...baseDataset,\n            fill: dataset.fill ?? false,\n            tension: dataset.tension ?? 0.4,\n            pointBackgroundColor: this.getBackgroundColor(index, type),\n            pointBorderColor: '#fff',\n            pointBorderWidth: 1,\n            pointRadius: 3,\n            pointHoverRadius: 5,\n            pointHoverBackgroundColor: this.getBackgroundColor(index, type),\n            pointHoverBorderColor: '#fff',\n            pointHoverBorderWidth: 2,\n          };\n        case 'bar':\n          return {\n            ...baseDataset,\n            barPercentage: 0.8,\n            categoryPercentage: 0.9,\n            stack: 'stack0',\n          };\n        case 'pie':\n          return {\n            ...baseDataset,\n            hoverOffset: 4,\n          };\n        case 'doughnut':\n          return {\n            ...baseDataset,\n            hoverOffset: 4,\n          };\n        default:\n          return baseDataset;\n      }\n    });\n\n    return {\n      labels: data.labels,\n      datasets,\n    };\n  }\n\n  /**\n   * Get the appropriate Chart.js type for a custom chart type\n   */\n  private getChartType(type?: string): string {\n    // First handle our internal source types\n    if (type === 'kills' || type === 'map_activity') {\n      return 'line'; // Default to line chart for these data sources\n    }\n\n    // Then handle display types\n    switch (type) {\n      case 'boxplot':\n      case 'violin':\n      case 'heatmap':\n      case 'calendar':\n        return 'bar';\n      default:\n        return type ?? 'bar';\n    }\n  }\n\n  /**\n   * Get background color for a dataset\n   */\n  private getBackgroundColor(index: number, _type?: string): string {\n    const colorIndex = index % this.colors.length;\n    return this.colors[colorIndex];\n  }\n\n  /**\n   * Adjust color opacity\n   */\n  private adjustColorOpacity(color: string, opacity: number): string {\n    if (color.startsWith('#')) {\n      const r = parseInt(color.slice(1, 3), 16);\n      const g = parseInt(color.slice(3, 5), 16);\n      const b = parseInt(color.slice(5, 7), 16);\n      return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n    return color;\n  }\n\n  /**\n   * Create chart configuration\n   */\n  private createChartConfig(data: CustomChartData, options: CustomChartOptions = {}): any {\n    const chartData = this.convertToChartJSData(data);\n    const chartOptions: any = {\n      responsive: options.responsive ?? true,\n      maintainAspectRatio: options.maintainAspectRatio ?? false,\n      plugins: {\n        legend: {\n          position: 'top',\n          labels: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n        },\n        tooltip: {\n          backgroundColor: theme.colors.background,\n          titleColor: theme.text.primary,\n          bodyColor: theme.text.primary,\n          borderColor: theme.colors.primary,\n          borderWidth: 1,\n          padding: 10,\n          displayColors: true,\n          callbacks: {\n            label: (context: any) => {\n              const label = context.dataset.label ?? '';\n              const value = context.parsed.y;\n              return `${label}: ${value}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n          stacked: true,\n        },\n        y: {\n          grid: {\n            color: theme.grid.color,\n          },\n          ticks: {\n            color: theme.text.primary,\n            font: {\n              size: 12,\n            },\n          },\n          stacked: true,\n        },\n      },\n    };\n\n    // Use the chart type but assign to a variable that will be used\n    const chartType = this.getChartType(data.displayType);\n\n    return {\n      type: chartType,\n      data: chartData,\n      options: chartOptions,\n    };\n  }\n\n  /**\n   * Render chart to buffer\n   */\n  async renderToBuffer(data: CustomChartData, options: CustomChartOptions = {}): Promise<Buffer> {\n    try {\n      const config = this.createChartConfig(data, options);\n      const canvas = createCanvas(options.width ?? 800, options.height ?? 400);\n\n      // Set background color\n      const ctx = canvas.getContext('2d');\n      ctx.fillStyle = theme.colors.background;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Create and render the chart\n      this.chart = new Chart(canvas as unknown as HTMLCanvasElement, config);\n      await this.chart.render();\n\n      // Use the correct toBuffer call\n      return canvas.toBuffer();\n    } catch (error) {\n      logger.error('Error rendering chart to buffer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Render chart to base64 string\n   */\n  async renderToBase64(data: CustomChartData, options: CustomChartOptions = {}): Promise<string> {\n    try {\n      const buffer = await this.renderToBuffer(data, options);\n      return buffer.toString('base64');\n    } catch (error) {\n      logger.error('Error rendering chart to base64:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ChartService.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (53). Maximum allowed is 50.","line":62,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":124,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateChart' has a complexity of 14. Maximum allowed is 10.","line":62,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":124,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":77,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":77,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":80,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":80,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":83,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":83,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 90.","line":86,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":51},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateKillsChart' has too many lines (207). Maximum allowed is 50.","line":126,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":391,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateKillsChart' has a complexity of 11. Maximum allowed is 10.","line":126,"column":35,"nodeType":"FunctionExpression","messageId":"complex","endLine":391,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":194,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":78},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":194,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":82},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7498,7501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7498,7501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async arrow function has too many lines (52). Maximum allowed is 50.","line":301,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":369,"endColumn":10},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (1058). Maximum allowed is 300.","line":375,"column":1,"nodeType":null,"messageId":"exceed","endLine":1389,"endColumn":1},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":395,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":395,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":396,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":396,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":397,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":397,"endColumn":34},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":398,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":398,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":399,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":399,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":400,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":400,"endColumn":31},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateMapActivityChart' has too many lines (105). Maximum allowed is 50.","line":410,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":549,"endColumn":4},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":572,"column":23,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":572,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 6.","line":609,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":609,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 16.","line":610,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":610,"endColumn":53},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateGroupedKillsChart' has too many lines (143). Maximum allowed is 50.","line":618,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":813,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateGroupedKillsChart' has a complexity of 15. Maximum allowed is 10.","line":618,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":813,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":775,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":775,"endColumn":32},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":806,"column":87,"nodeType":"Literal","messageId":"noMagic","endLine":806,"endColumn":90},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateGroupedMapActivityChart' has too many lines (195). Maximum allowed is 50.","line":818,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":1059,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateGroupedMapActivityChart' has a complexity of 13. Maximum allowed is 10.","line":818,"column":40,"nodeType":"FunctionExpression","messageId":"complex","endLine":1059,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'getCharacterGroups' has too many lines (130). Maximum allowed is 50.","line":1086,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":1260,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'getCharacterGroups' has a complexity of 20. Maximum allowed is 10.","line":1086,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":1260,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":1101,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":1101,"endColumn":29},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 8.","line":1132,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":1132,"endColumn":69},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 8.","line":1190,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":1190,"endColumn":65},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":1233,"column":13,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":1233,"endColumn":49,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[45001,45002],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 8.","line":1244,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":1244,"endColumn":63}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CharacterRepository } from '../infrastructure/repositories/CharacterRepository';\nimport { KillRepository } from '../infrastructure/repositories/KillRepository';\nimport { MapActivityRepository } from '../infrastructure/repositories/MapActivityRepository';\nimport { RepositoryManager } from '../infrastructure/repositories/RepositoryManager';\nimport { logger } from '../lib/logger';\nimport { Character } from '../domain/character/Character';\nimport { CharacterGroup } from '../domain/character/CharacterGroup';\nimport { Killmail } from '../domain/killmail/Killmail';\nimport { MapActivity } from '../domain/activity/MapActivity';\nimport { ChartConfigInput, ChartData, ChartDisplayType, ChartMetric } from '../types/chart';\nimport { format } from 'date-fns';\nimport { BaseRepository } from '../infrastructure/repositories/BaseRepository';\nimport { PrismaClient } from '@prisma/client';\n\ninterface KillData {\n  killTime: Date;\n  totalValue: bigint;\n  points: number;\n  attackerCount: number;\n  characters: Array<{ characterId: bigint }>;\n}\n\ninterface ActivityData {\n  timestamp: Date;\n  signatures: number;\n  characterId: bigint;\n}\n\nexport class ChartService extends BaseRepository {\n  private readonly characterRepository: CharacterRepository;\n  private readonly killRepository: KillRepository;\n  private readonly mapActivityRepository: MapActivityRepository;\n  private colors: string[] = [\n    '#3366CC', // deep blue\n    '#DC3912', // red\n    '#FF9900', // orange\n    '#109618', // green\n    '#990099', // purple\n    '#0099C6', // teal\n    '#DD4477', // pink\n    '#66AA00', // lime\n    '#B82E2E', // dark red\n    '#316395', // navy\n    '#994499', // violet\n    '#22AA99', // seafoam\n    '#AAAA11', // olive\n    '#6633CC', // indigo\n    '#E67300', // amber\n    '#8B0707', // maroon\n  ];\n  protected override prisma: PrismaClient;\n\n  constructor() {\n    super('Chart');\n    const repositoryManager = new RepositoryManager();\n    this.characterRepository = repositoryManager.getCharacterRepository();\n    this.killRepository = repositoryManager.getKillRepository();\n    this.mapActivityRepository = repositoryManager.getMapActivityRepository();\n    this.prisma = new PrismaClient();\n  }\n\n  async generateChart(config: ChartConfigInput): Promise<ChartData> {\n    const {\n      type,\n      characterIds,\n      period,\n      groupBy = 'hour',\n      displayType = 'line',\n      displayMetric = 'value', // Default to value, but can be \"kills\", \"value\", \"points\", \"attackers\"\n      limit = 10, // Limit number of characters to display\n    } = config;\n\n    // Calculate start date based on period\n    const startDate = new Date();\n    switch (period) {\n      case '24h':\n        startDate.setHours(startDate.getHours() - 24);\n        break;\n      case '7d':\n        startDate.setDate(startDate.getDate() - 7);\n        break;\n      case '30d':\n        startDate.setDate(startDate.getDate() - 30);\n        break;\n      case '90d':\n        startDate.setDate(startDate.getDate() - 90);\n        break;\n      default:\n        throw new Error(`Invalid period: ${period}`);\n    }\n\n    // Generate chart title\n    const metricLabel =\n      displayMetric === 'value'\n        ? 'ISK Value'\n        : displayMetric === 'kills'\n          ? 'Kill Count'\n          : displayMetric === 'points'\n            ? 'Points'\n            : 'Attacker Count';\n\n    const chartTitle = `${type === 'kills' ? 'Kills' : 'Map Activity'} - ${metricLabel} - Last ${\n      period === '24h' ? '24 Hours' : period === '7d' ? '7 Days' : period === '30d' ? '30 Days' : '90 Days'\n    }`;\n\n    // Generate chart based on type\n    let chartData;\n    switch (type) {\n      case 'kills':\n        chartData = await this.generateKillsChart(characterIds, startDate, groupBy, displayMetric, limit);\n        break;\n      case 'map_activity':\n        chartData = await this.generateMapActivityChart(characterIds, startDate, groupBy);\n        break;\n      default:\n        throw new Error(`Invalid chart type: ${type}`);\n    }\n\n    // Add title and displayType to chart data\n    chartData.title = chartTitle;\n    chartData.displayType = displayType;\n\n    return chartData;\n  }\n\n  private async generateKillsChart(\n    characterIds: bigint[],\n    startDate: Date,\n    groupBy: 'hour' | 'day' | 'week',\n    displayMetric: ChartMetric = 'value',\n    limit: number = 10\n  ): Promise<ChartData> {\n    // Convert character IDs to strings for query\n    const characterIdStrings = characterIds.map(id => id.toString());\n\n    logger.info(`Generating kills chart for ${characterIds.length} characters from ${startDate.toISOString()}`);\n    logger.info(`Character IDs: ${characterIdStrings.join(', ')}`);\n\n    try {\n      // Find all related characters via character groups\n      const allCharactersNested = await Promise.all(\n        characterIdStrings.map(async (id: string) => {\n          const character = await this.characterRepository.getCharacter(BigInt(id));\n          if (character?.characterGroupId) {\n            return this.characterRepository.getCharactersByGroup(character.characterGroupId);\n          }\n          return character ? [character] : [];\n        })\n      );\n      const allCharacters = allCharactersNested.flat();\n      const allCharacterIdStrings = allCharacters.map((c: Character) => c.eveId);\n      logger.info(`Including all characters in same groups: ${allCharacters.length} characters total`);\n\n      // Get kills for each character using the updated schema\n      logger.info('Querying killFact table with expanded character list...');\n      const killsQuery = await this.killRepository.getKillsForCharacters(\n        allCharacterIdStrings.map(id => BigInt(id)),\n        startDate,\n        new Date()\n      );\n\n      logger.info(`Found ${killsQuery.length} kill records in database`);\n\n      if (killsQuery.length === 0) {\n        logger.warn('No kills found for the specified characters and time period');\n        // Return empty chart data but with datasets for the requested characters\n        const emptyDatasets = await Promise.all(\n          characterIds.slice(0, limit).map(async (characterId, index) => {\n            // Try to get character name\n            try {\n              const character = await this.characterRepository.getCharacter(characterId);\n\n              return {\n                label: character?.name ?? `Character ${characterId}`,\n                data: [],\n                borderColor: this.getColorForIndex(index),\n                fill: false,\n              };\n            } catch (err) {\n              return {\n                label: `Character ${characterId}`,\n                data: [],\n                borderColor: this.getColorForIndex(index),\n                fill: false,\n              };\n            }\n          })\n        );\n\n        // Generate at least some dummy time labels for the empty chart\n        const labels = [];\n        const today = new Date();\n        // Determine appropriate number of days based on the groupBy parameter\n        const daysToGenerate = groupBy === 'hour' ? 1 : groupBy === 'day' ? 7 : 4; // 1 day for hourly, 7 for daily, 4 weeks for weekly\n        for (let i = daysToGenerate - 1; i >= 0; i--) {\n          const date = new Date(today);\n          date.setDate(date.getDate() - i);\n          labels.push(format(date, this.getDateFormat(groupBy)));\n        }\n\n        return {\n          labels,\n          datasets: emptyDatasets,\n          title: '',\n          displayType: 'line' as ChartDisplayType,\n        };\n      }\n\n      const kills = killsQuery.map((kill: any) => {\n        logger.debug(`Processing kill: ID ${kill.killmail_id}, time ${kill.kill_time}, character ${kill.character_id}`);\n        return {\n          killTime: kill.kill_time,\n          totalValue: kill.total_value,\n          points: kill.points ?? 0,\n          attackerCount: kill.attacker_count ?? 1,\n          characters: [{ characterId: BigInt(kill.character_id) }],\n        };\n      }) as KillData[];\n\n      // Group kills by time period\n      logger.info(`Grouping ${kills.length} kills by ${groupBy}`);\n      const groupedData = this.groupDataByTime(kills, groupBy, (kill: KillData) => ({\n        timestamp: kill.killTime,\n        value:\n          displayMetric === 'value'\n            ? Number(kill.totalValue)\n            : displayMetric === 'kills'\n              ? 1\n              : displayMetric === 'points'\n                ? kill.points\n                : kill.attackerCount,\n      }));\n\n      logger.info(`Created ${groupedData.length} time groups`);\n\n      // Sort character IDs by activity (total value, kill count, etc.) to show the most active characters\n      const characterActivity: { id: bigint; activity: number; name: string }[] = [];\n\n      for (const characterId of characterIds) {\n        const character = await this.characterRepository.getCharacter(characterId);\n\n        if (!character) {\n          logger.warn(`Character ${characterId} not found in database`);\n          continue;\n        }\n\n        // Find all alts for this character\n        const alts = character.characterGroupId\n          ? await this.characterRepository.getCharactersByGroup(character.characterGroupId)\n          : [];\n\n        // Get all character IDs (main + alts)\n        const allIds = [BigInt(character.eveId), ...alts.map(alt => BigInt(alt.eveId))];\n\n        // Calculate activity based on displayMetric\n        const characterKills = kills.filter((kill: KillData) =>\n          kill.characters.some(kc => allIds.includes(BigInt(kc.characterId)))\n        );\n\n        const activity = characterKills.reduce((total, kill) => {\n          if (displayMetric === 'value') return total + Number(kill.totalValue);\n          if (displayMetric === 'kills') return total + 1;\n          if (displayMetric === 'points') return total + kill.points;\n          if (displayMetric === 'attackers') return total + kill.attackerCount;\n          return total;\n        }, 0);\n\n        // Only include characters with some activity\n        if (activity > 0) {\n          characterActivity.push({\n            id: characterId,\n            activity,\n            name: character.name,\n          });\n        }\n      }\n\n      // Sort by activity descending and take the top 'limit' characters\n      characterActivity.sort((a, b) => b.activity - a.activity);\n      const topCharacterIds = characterActivity.slice(0, limit);\n\n      logger.info(\n        `Selected top ${topCharacterIds.length} most active characters for display: ${topCharacterIds\n          .map(c => c.name)\n          .join(', ')}`\n      );\n\n      // If no characters have activity, return empty chart\n      if (topCharacterIds.length === 0) {\n        return {\n          labels: [],\n          datasets: [],\n          title: '',\n          displayType: 'line' as ChartDisplayType,\n        };\n      }\n\n      // Create datasets for each character - now include all alts for each main character\n      logger.info('Creating datasets for each main character including their alts');\n      const datasets = await Promise.all(\n        topCharacterIds.map(async (charItem, index) => {\n          const characterId = charItem.id;\n          const character = await this.characterRepository.getCharacter(characterId);\n\n          if (!character) {\n            logger.warn(`Character ${characterId} not found in database`);\n            return {\n              label: `Character ${characterId}`,\n              data: [],\n              borderColor: this.getColorForIndex(index),\n              fill: false,\n            };\n          }\n\n          logger.info(`Processing main character ${character.name} (${character.eveId})`);\n\n          // Find all alts for this character\n          const alts = character.characterGroupId\n            ? await this.characterRepository.getCharactersByGroup(character.characterGroupId)\n            : [];\n\n          logger.info(`Found ${alts.length} alts for ${character.name}`);\n\n          // Get all character IDs (main + alts)\n          const allIds = [BigInt(character.eveId), ...alts.map(alt => BigInt(alt.eveId))];\n\n          // Filter kills for this character and all its alts\n          const characterKills = kills.filter((kill: KillData) =>\n            kill.characters.some(kc => allIds.includes(BigInt(kc.characterId)))\n          );\n\n          logger.info(`Found ${characterKills.length} kills for character ${character.name} and alts`);\n\n          // Create a display name that shows activity level\n          const activityText =\n            displayMetric === 'value' ? this.formatValue(charItem.activity) : charItem.activity.toLocaleString();\n\n          const metricLabel =\n            displayMetric === 'value'\n              ? 'ISK'\n              : displayMetric === 'kills'\n                ? 'kills'\n                : displayMetric === 'points'\n                  ? 'pts'\n                  : 'attackers';\n\n          const displayName = `${character.name} (${activityText} ${metricLabel})`;\n\n          const characterData = this.groupDataByTime(characterKills, groupBy, (kill: KillData) => ({\n            timestamp: kill.killTime,\n            value:\n              displayMetric === 'value'\n                ? Number(kill.totalValue)\n                : displayMetric === 'kills'\n                  ? 1\n                  : displayMetric === 'points'\n                    ? kill.points\n                    : kill.attackerCount,\n          }));\n\n          logger.info(`Created ${characterData.length} data points for character ${character.name}`);\n\n          return {\n            label: displayName,\n            data: characterData.map(d => d.value),\n            borderColor: this.getColorForIndex(index),\n            fill: false,\n          };\n        })\n      );\n\n      logger.info(`Created ${datasets.length} datasets with labels: ${datasets.map(d => d.label).join(', ')}`);\n      logger.info(`Chart will have ${groupedData.length} labels and ${datasets.length} datasets`);\n\n      return {\n        labels: groupedData.map(d => format(d.timestamp, this.getDateFormat(groupBy))),\n        datasets,\n        title: '',\n        displayType: 'line' as ChartDisplayType,\n      };\n    } catch (error) {\n      logger.error('Error generating kills chart:', error);\n      // Return empty chart on error\n      return {\n        labels: [],\n        datasets: [],\n        title: '',\n        displayType: 'line' as ChartDisplayType,\n      };\n    }\n  }\n\n  // Helper function to format values with K/M/B suffixes\n  private formatValue(value: number): string {\n    if (value >= 1_000_000_000) {\n      return `${(value / 1_000_000_000).toFixed(1)}B`;\n    } else if (value >= 1_000_000) {\n      return `${(value / 1_000_000).toFixed(1)}M`;\n    } else if (value >= 1_000) {\n      return `${(value / 1_000).toFixed(1)}K`;\n    }\n    return value.toString();\n  }\n\n  // Helper method to get a color from the color array\n  private getColorForIndex(index: number): string {\n    return this.colors[index % this.colors.length];\n  }\n\n  private async generateMapActivityChart(\n    characterIds: bigint[],\n    startDate: Date,\n    groupBy: 'hour' | 'day' | 'week'\n  ): Promise<ChartData> {\n    // Convert character IDs to strings for query\n    const characterIdStrings = characterIds.map(id => id.toString());\n\n    logger.info(`Generating map activity chart for ${characterIds.length} characters from ${startDate.toISOString()}`);\n    logger.info(`Character IDs: ${characterIdStrings.join(', ')}`);\n\n    try {\n      // First, get all characters including alts for the requested main characters\n      const allCharacters = await Promise.all(\n        characterIdStrings.map(async id => {\n          const character = await this.characterRepository.getCharacter(BigInt(id));\n          if (character?.characterGroupId) {\n            return this.characterRepository.getCharactersByGroup(character.characterGroupId);\n          }\n          return character ? [character] : [];\n        })\n      ).then(results => results.flat());\n\n      const allCharacterIdStrings = allCharacters.flat().map((c: Character) => c.eveId);\n      logger.info(`Including all characters and alts: ${allCharacters.length} characters total`);\n\n      // Get map activity for each character\n      logger.info('Querying mapActivity table with expanded character list...');\n      const rawActivities = await this.mapActivityRepository.getActivityForGroup(\n        allCharacterIdStrings.join(','),\n        startDate,\n        new Date()\n      );\n\n      logger.info(`Found ${rawActivities.length} map activity records in database`);\n\n      if (rawActivities.length === 0) {\n        logger.warn('No map activity found for the specified characters and time period');\n        // Let's check if there are any activity records at all in the database\n        const totalActivityCount = await this.mapActivityRepository.getActivityForGroup(\n          characterIdStrings[0],\n          startDate,\n          new Date()\n        );\n        logger.info(`Total map activities in database: ${totalActivityCount.length}`);\n\n        // Sample a few records to understand the data structure\n        if (totalActivityCount.length > 0) {\n          const sampleRecords = totalActivityCount;\n          logger.info(`Sample map activity records: ${JSON.stringify(sampleRecords)}`);\n        }\n      }\n\n      // Convert to ActivityData\n      const activities: ActivityData[] = rawActivities.map(activity => ({\n        timestamp: activity.timestamp,\n        signatures: activity.signatures,\n        characterId: BigInt(activity.characterId),\n      }));\n\n      // Group activities by time period\n      logger.info(`Grouping ${activities.length} activities by ${groupBy}`);\n      const groupedData = this.groupDataByTime(activities, groupBy, (activity: ActivityData) => ({\n        timestamp: activity.timestamp,\n        value: activity.signatures,\n      }));\n\n      logger.info(`Created ${groupedData.length} time groups`);\n\n      // Create datasets for each main character\n      logger.info('Creating datasets for each main character including their alts');\n      const datasets = await Promise.all(\n        characterIds.map(async characterId => {\n          const character = await this.characterRepository.getCharacter(characterId);\n\n          if (!character) {\n            logger.warn(`Character ${characterId} not found in database`);\n            return {\n              label: `Character ${characterId}`,\n              data: [],\n              borderColor: this.getRandomColor(),\n              fill: false,\n            };\n          }\n\n          logger.info(`Processing main character ${character.name} (${character.eveId})`);\n\n          // Find all alts for this character\n          const alts = character.characterGroupId\n            ? await this.characterRepository.getCharactersByGroup(character.characterGroupId)\n            : [];\n\n          logger.info(`Found ${alts.length} alts for ${character.name}`);\n\n          // Get all character IDs (main + alts)\n          const allIds = [BigInt(character.eveId), ...alts.map(alt => BigInt(alt.eveId))];\n\n          // Filter activities for this character and all its alts\n          const characterActivities = activities.filter((activity: ActivityData) =>\n            allIds.includes(activity.characterId)\n          );\n\n          logger.info(`Found ${characterActivities.length} activities for character ${character.name} and alts`);\n\n          const characterData = this.groupDataByTime(characterActivities, groupBy, (activity: ActivityData) => ({\n            timestamp: activity.timestamp,\n            value: activity.signatures,\n          }));\n\n          logger.info(`Created ${characterData.length} data points for character ${character.name}`);\n\n          return {\n            label: character.name,\n            data: characterData.map(d => d.value),\n            borderColor: this.getRandomColor(),\n            fill: false,\n          };\n        })\n      );\n\n      logger.info(`Created ${datasets.length} datasets with labels: ${datasets.map(d => d.label).join(', ')}`);\n      logger.info(`Chart will have ${groupedData.length} labels and ${datasets.length} datasets`);\n\n      return {\n        labels: groupedData.map(d => format(d.timestamp, this.getDateFormat(groupBy))),\n        datasets,\n        title: '',\n        displayType: 'line' as ChartDisplayType,\n      };\n    } catch (error) {\n      logger.error('Error generating map activity chart:', error);\n      // Return empty chart on error\n      return {\n        labels: [],\n        datasets: [],\n        title: '',\n        displayType: 'line' as ChartDisplayType,\n      };\n    }\n  }\n\n  private groupDataByTime<T>(\n    data: T[],\n    groupBy: 'hour' | 'day' | 'week',\n    getTimestampAndValue: (item: T) => { timestamp: Date; value: number }\n  ): { timestamp: Date; value: number }[] {\n    const grouped = new Map<string, { timestamp: Date; value: number }>();\n\n    // If no data, return an empty array\n    if (data.length === 0) {\n      return [];\n    }\n\n    // Create a dictionary for quick lookup when grouping data\n    for (const item of data) {\n      const { timestamp, value } = getTimestampAndValue(item);\n      const key = format(timestamp, this.getGroupByFormat(groupBy));\n\n      if (!grouped.has(key)) {\n        grouped.set(key, { timestamp, value: 0 });\n      }\n\n      const current = grouped.get(key)!;\n      current.value += value;\n    }\n\n    // Sort by timestamp\n    return Array.from(grouped.values()).sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n  }\n\n  private getGroupByFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    switch (groupBy) {\n      case 'hour':\n        return 'yyyy-MM-dd HH:00';\n      case 'day':\n        return 'yyyy-MM-dd';\n      case 'week':\n        return \"yyyy-'W'ww\";\n      default:\n        throw new Error(`Invalid groupBy: ${groupBy}`);\n    }\n  }\n\n  private getDateFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    switch (groupBy) {\n      case 'hour':\n        return 'MMM d, HH:mm';\n      case 'day':\n        return 'MMM d';\n      case 'week':\n        return \"'Week' w\";\n      default:\n        throw new Error(`Invalid groupBy: ${groupBy}`);\n    }\n  }\n\n  private getRandomColor(): string {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n\n  /**\n   * Generates a grouped kills chart by character group for kills data\n   */\n  async generateGroupedKillsChart(config: {\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    startDate: Date;\n    endDate: Date;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { characterGroups, startDate, endDate } = config;\n\n    logger.info(`Generating grouped kills chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n    logger.info(`Received ${characterGroups.length} total character groups to process`);\n\n    // Enhanced group data with main character information\n    const enhancedGroups = await Promise.all(\n      characterGroups.map(async group => {\n        // Try to find main character in the group\n        let mainCharacter = null;\n\n        // First, check if any character in the group is set as a main character\n        // Get all characters in this group using the group ID\n        const groupCharacters = await this.characterRepository.getCharactersByGroup(group.groupId);\n        const hasCharacters = groupCharacters.length > 0;\n        if (hasCharacters && group.characters.length > 0) {\n          mainCharacter = group.characters[0];\n        }\n\n        // If still no main was found, just use the first character\n        if (!mainCharacter && group.characters.length > 0) {\n          mainCharacter = group.characters[0];\n        }\n\n        // Use just the character name as the display name\n        const displayName = mainCharacter\n          ? mainCharacter.name\n          : group.characters.length > 0\n            ? group.characters[0].name\n            : group.name;\n\n        return {\n          ...group,\n          mainCharacter,\n          displayName,\n        };\n      })\n    );\n\n    // Get displayable groups with at least one character\n    const displayGroups = enhancedGroups.filter(group => group.characters.length > 0);\n\n    // Print the detailed group information for debugging\n    if (displayGroups.length > 0) {\n      logger.info(`Found ${displayGroups.length} valid character groups with at least one character`);\n      displayGroups.forEach((group, index) => {\n        logger.info(\n          `Group ${index + 1}: \"${group.displayName}\" (Main: ${\n            group.mainCharacter?.name\n          }) - ${group.characters.length} characters`\n        );\n      });\n    } else {\n      logger.warn('No valid character groups found with characters');\n    }\n\n    // First, collect all groups with their kill data and filter out those without kills\n    const groupsWithData = [];\n    const groupsWithoutKills = [];\n    let totalGroupsProcessed = 0;\n\n    try {\n      logger.info(`Processing ${displayGroups.length} groups to fetch kill data...`);\n\n      // For each group, get the kill statistics using enhanced stats\n      for (const group of displayGroups) {\n        totalGroupsProcessed++;\n\n        // Get all character IDs in this group\n        const characterIds = group.characters.map(c => BigInt(c.eveId));\n\n        if (characterIds.length === 0) {\n          logger.info(`No characters in group ${group.displayName}, skipping`);\n          continue;\n        }\n\n        // Count kills for these characters (faster than fetching all data)\n        const kills = await this.killRepository.getKillsForCharacters(characterIds, startDate, endDate);\n        const killCount = kills.length;\n\n        if (killCount === 0) {\n          logger.info(`No kills found for group ${group.displayName}, skipping`);\n          groupsWithoutKills.push(group.displayName);\n          continue;\n        }\n\n        // Calculate solo kills (where all attackers are from this group)\n        let soloKills = 0;\n        for (const kill of kills) {\n          // Skip kills with no attackers\n          if (!kill.attackers || kill.attackers.length === 0) continue;\n\n          // Get all player attackers (those with character IDs)\n          const playerAttackers = kill.attackers.filter((a: { character_id?: string }) => a.character_id);\n          if (playerAttackers.length === 0) continue;\n\n          // Check if all attackers are from this group\n          const allFromGroup = playerAttackers.every((attacker: { character_id?: string }) => {\n            if (!attacker.character_id) return false;\n            return characterIds.includes(BigInt(attacker.character_id));\n          });\n\n          if (allFromGroup) {\n            soloKills++;\n          }\n        }\n\n        // Only add to our results if there are actually kills\n        if (kills.length > 0) {\n          // Always use the main character's name as the display name\n          const displayName = group.mainCharacter ? group.mainCharacter.name : group.displayName;\n\n          groupsWithData.push({\n            group: {\n              ...group,\n              displayName,\n            },\n            totalKills: kills.length,\n            soloKills: soloKills,\n          });\n\n          logger.info(`Group ${displayName}: ${kills.length} total kills, ${soloKills} solo kills`);\n        }\n      }\n\n      // Log stats about our filtering\n      logger.info(`Processed ${totalGroupsProcessed}/${displayGroups.length} groups`);\n      logger.info(\n        `Found ${groupsWithData.length} groups with kills and ${groupsWithoutKills.length} groups without kills`\n      );\n\n      // If no groups have kills, return empty chart\n      if (groupsWithData.length === 0) {\n        logger.info('No groups with kills found, returning empty chart');\n        return {\n          labels: [],\n          datasets: [],\n          displayType: 'horizontalBar' as ChartDisplayType,\n          summary: 'No kills found in the specified time period',\n        };\n      }\n\n      // Sort groups by total kills in descending order\n      groupsWithData.sort((a, b) => b.totalKills - a.totalKills);\n\n      logger.info(`After sorting, top 3 groups by kill count:`);\n      groupsWithData.slice(0, 3).forEach((item, i) => {\n        logger.info(`${i + 1}. ${item.group.displayName}: ${item.totalKills} kills`);\n      });\n\n      // Create chart data structure from our filtered and sorted groups\n      const groupLabels = groupsWithData.map(item => item.group.displayName);\n      const totalKillsData = groupsWithData.map(item => item.totalKills);\n      const soloKillsData = groupsWithData.map(item => item.soloKills);\n\n      // Calculate overall statistics\n      const overallTotalKills = totalKillsData.reduce((a, b) => a + b, 0);\n      const overallSoloKills = soloKillsData.reduce((a, b) => a + b, 0);\n\n      logger.info(`Final chart will include ${groupLabels.length} groups`);\n\n      return {\n        labels: groupLabels,\n        datasets: [\n          {\n            label: 'Total Kills',\n            data: totalKillsData,\n            backgroundColor: '#3366CC',\n          },\n          {\n            label: 'Solo Kills',\n            data: soloKillsData,\n            backgroundColor: '#DC3912',\n          },\n        ],\n        displayType: 'horizontalBar' as ChartDisplayType,\n        summary: `Total kills: ${overallTotalKills.toLocaleString()}\\nSolo kills: ${overallSoloKills.toLocaleString()} (${\n          overallTotalKills > 0 ? Math.round((overallSoloKills / overallTotalKills) * 100) : 0\n        }%)`,\n      };\n    } catch (error) {\n      logger.error('Error generating kills chart:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generates a grouped map activity chart by character group\n   */\n  async generateGroupedMapActivityChart(config: {\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    startDate: Date;\n    endDate: Date;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { characterGroups, startDate, endDate, displayType } = config;\n\n    logger.info(`Generating grouped map activity chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n\n    // If no character groups provided, get all characters\n    if (!characterGroups || characterGroups.length === 0) {\n      logger.info('No character groups provided, creating default group with all characters');\n      try {\n        const allCharacters = await this.characterRepository.getAllCharacters();\n\n        if (allCharacters.length === 0) {\n          logger.warn('No characters found in database');\n          return {\n            labels: ['No Characters'],\n            datasets: [\n              {\n                label: 'Signatures',\n                data: [0],\n                backgroundColor: '#3366CC',\n              },\n              {\n                label: 'Cosmic Anomalies',\n                data: [0],\n                backgroundColor: '#DC3912',\n              },\n              {\n                label: 'Wormholes',\n                data: [0],\n                backgroundColor: '#FF9900',\n              },\n            ],\n            displayType: 'horizontalBar' as ChartDisplayType,\n          };\n        }\n\n        // Continue with default group\n        return this.generateGroupedMapActivityChart({\n          characterGroups: [\n            {\n              groupId: 'default',\n              name: 'All Characters',\n              characters: allCharacters,\n            },\n          ],\n          startDate,\n          endDate,\n          displayType,\n        });\n      } catch (error) {\n        logger.error('Error creating default character group:', error);\n        throw new Error('No character groups available and could not create default group');\n      }\n    }\n\n    // Enhanced group data with main character information\n    const enhancedGroups = await Promise.all(\n      characterGroups.map(async group => {\n        // Try to find main character in the group\n        let mainCharacter = null;\n\n        // First, check if any character in the group is set as a main character\n        // Get all characters in this group using the group ID\n        const groupCharacters = await this.characterRepository.getCharactersByGroup(group.groupId);\n        const hasCharacters = groupCharacters.length > 0;\n        if (hasCharacters && group.characters.length > 0) {\n          mainCharacter = group.characters[0];\n        }\n\n        // If no main was found, just use the first character\n        if (!mainCharacter && group.characters.length > 0) {\n          mainCharacter = group.characters[0];\n        }\n\n        // Use just the character name as the display name\n        const displayName = mainCharacter\n          ? mainCharacter.name\n          : group.characters.length > 0\n            ? group.characters[0].name\n            : group.name;\n\n        return {\n          ...group,\n          mainCharacter,\n          displayName,\n        };\n      })\n    );\n\n    // Get displayable groups with at least one character\n    const displayGroups = enhancedGroups.filter(group => group.characters.length > 0);\n\n    // Print the detailed group information for debugging\n    if (displayGroups.length > 0) {\n      logger.info(`Found ${displayGroups.length} valid character groups with at least one character`);\n      displayGroups.forEach((group, index) => {\n        logger.info(`Group ${index + 1}: \"${group.displayName}\" - ${group.characters.length} characters`);\n      });\n    } else {\n      logger.warn('No valid character groups found with characters');\n    }\n\n    // Collect all groups with their activity data first, so we can filter out empty ones\n    const groupsWithData = [];\n\n    try {\n      // For each group, get the map activity statistics\n      for (const group of displayGroups) {\n        // Debug log all characters in this group\n        logger.info(`Processing group ${group.displayName}:`);\n        group.characters.forEach((char, i) => {\n          logger.info(`  Character ${i}: eveId=${char.eveId}, name=${char.name}, eveIdType=${typeof char.eveId}`);\n        });\n\n        // Filter out characters with undefined eveId and convert valid ones to BigInt\n        const validCharacters = group.characters.filter(c => {\n          if (!c.eveId || c.eveId === undefined) {\n            logger.warn(`Skipping character with undefined eveId: ${JSON.stringify(c)}`);\n            return false;\n          }\n          return true;\n        });\n\n        logger.info(\n          `After filtering, group ${group.displayName} has ${validCharacters.length} valid characters out of ${group.characters.length} total`\n        );\n\n        if (validCharacters.length === 0) {\n          logger.info(`No valid characters in group ${group.displayName}, skipping`);\n          continue;\n        }\n\n        const characterIds = validCharacters.map(c => BigInt(c.eveId));\n\n        logger.info(\n          `Valid character IDs for group ${group.displayName}: ${characterIds.map(id => id.toString()).join(', ')}`\n        );\n\n        // Get all map activities for these characters\n        const activities = await this.mapActivityRepository.getActivityForCharacters(\n          characterIds.map(id => id.toString()),\n          startDate,\n          endDate\n        );\n\n        if (activities.length === 0) {\n          logger.info(`No map activities found for group ${group.displayName}`);\n          continue;\n        }\n\n        // Sum up activity values\n        const signatures = activities.reduce((sum, act) => sum + act.signatures, 0);\n        const connections = activities.reduce((sum, act) => sum + act.connections, 0);\n        const passages = activities.reduce((sum, act) => sum + act.passages, 0);\n\n        // Only add to our results if there is actually activity\n        const totalActivity = signatures + connections + passages;\n        if (totalActivity > 0) {\n          groupsWithData.push({\n            group,\n            signatures,\n            connections,\n            passages,\n            totalActivity,\n          });\n        } else {\n          logger.info(`Skipping group ${group.displayName} with no activity data`);\n        }\n      }\n\n      // Exit early if no groups have data\n      if (groupsWithData.length === 0) {\n        logger.warn('No character groups have any map activity data in the specified time range');\n        return {\n          labels: ['No Data Available'],\n          datasets: [\n            {\n              label: 'Signatures',\n              data: [0],\n              backgroundColor: '#3366CC',\n            },\n            {\n              label: 'Connections',\n              data: [0],\n              backgroundColor: '#DC3912',\n            },\n            {\n              label: 'Passages',\n              data: [0],\n              backgroundColor: '#FF9900',\n            },\n          ],\n          displayType: 'horizontalBar' as ChartDisplayType,\n        };\n      }\n\n      // Sort groups by total activity (highest first)\n      groupsWithData.sort((a, b) => b.totalActivity - a.totalActivity);\n\n      // Create chart data structure from our filtered and sorted groups\n      const groupLabels = groupsWithData.map(item => item.group.displayName);\n      const signaturesData = groupsWithData.map(item => item.signatures);\n      const connectionsData = groupsWithData.map(item => item.connections);\n      const passagesData = groupsWithData.map(item => item.passages);\n\n      // Return the final chart data\n      return {\n        labels: groupLabels,\n        datasets: [\n          {\n            label: 'Signatures',\n            data: signaturesData,\n            backgroundColor: '#3366CC',\n          },\n          {\n            label: 'Cosmic Anomalies',\n            data: connectionsData,\n            backgroundColor: '#DC3912',\n          },\n          {\n            label: 'Wormholes',\n            data: passagesData,\n            backgroundColor: '#FF9900',\n          },\n        ],\n        displayType: 'horizontalBar' as ChartDisplayType,\n      };\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('Error generating grouped map activity chart:', error);\n      throw new Error(`Failed to generate grouped map activity chart: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Gets all tracked characters\n   */\n  async getTrackedCharacters(): Promise<Array<{ eveId: string; name: string }>> {\n    try {\n      // Find main characters (where they are referenced by CharacterGroup.mainCharacterId)\n      const groups = await this.characterRepository.getAllCharacterGroups();\n\n      // Extract characters from groups\n      const characters = groups\n        .map(g => (g.mainCharacterId ? g.characters.find((c: Character) => c.eveId === g.mainCharacterId) : null))\n        .filter((c): c is Character => c !== null);\n\n      logger.info(`Found ${characters.length} tracked characters (main characters)`);\n      return characters;\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('Error fetching tracked characters:', errorMessage);\n      return [];\n    }\n  }\n\n  /**\n   * Gets all character groups with their members\n   */\n  async getCharacterGroups(): Promise<\n    Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>\n  > {\n    try {\n      // First, count the total number of character groups\n      const totalGroups = (await this.characterRepository.getAllCharacterGroups()).length;\n\n      logger.info(`Found ${totalGroups} character groups in database`);\n\n      // If we have a suspiciously large number of groups, use a different approach\n      if (totalGroups > 1000) {\n        logger.warn(`Unusually high number of character groups (${totalGroups}). Using optimized approach.`);\n\n        // Get only groups that have at least one character (using a JOIN)\n        const groupsWithCharacters = (await this.characterRepository.getAllCharacterGroups()).filter(\n          g => g.characters.length > 0\n        );\n\n        logger.info(`Found ${groupsWithCharacters.length} groups with at least one character`);\n\n        // Process these groups in batches to avoid memory issues\n        const result = [];\n        const batchSize = 50;\n\n        for (let i = 0; i < groupsWithCharacters.length; i += batchSize) {\n          const batch = groupsWithCharacters.slice(i, i + batchSize);\n          logger.info(`Processing batch ${i / batchSize + 1} of ${Math.ceil(groupsWithCharacters.length / batchSize)}`);\n\n          for (const group of batch) {\n            // For each group, get its characters\n            const characters = await Promise.all(\n              group.characters.map((c: Character) =>\n                c.characterGroupId\n                  ? this.characterRepository.getCharactersByGroup(c.characterGroupId)\n                  : Promise.resolve([])\n              )\n            ).then(results => results.flat());\n\n            if (characters.length > 0) {\n              result.push({\n                groupId: group.id,\n                name: group.name ?? `Group ${group.id.substring(0, 8)}`,\n                characters,\n              });\n            }\n          }\n        }\n\n        logger.info(`Successfully processed ${result.length} valid character groups`);\n        return result;\n      }\n\n      // Standard approach for a reasonable number of groups\n      const groups = await this.characterRepository.getAllCharacterGroups();\n\n      logger.info(`Found ${groups.length} character groups`);\n\n      // Filter out groups with no characters\n      const validGroups = groups.filter(group => group.characters.length > 0);\n      logger.info(`${validGroups.length} groups have at least one character`);\n\n      return validGroups\n        .map(group => {\n          // Debug log the raw group data\n          logger.debug(`Processing group ${group.id}:`, {\n            groupId: group.id,\n            name: group.name,\n            characterCount: group.characters?.length ?? 0,\n            firstCharacter: group.characters?.[0]\n              ? {\n                  eveId: group.characters[0].eveId,\n                  eveIdType: typeof group.characters[0].eveId,\n                  name: group.characters[0].name,\n                }\n              : null,\n          });\n\n          // Filter and transform characters, ensuring eveId is a valid string\n          const validCharacters = group.characters\n            .map(char => {\n              // Ensure eveId is properly converted to string\n              const eveId = char.eveId?.toString?.() ?? String(char.eveId ?? '');\n              const name = char.name ?? `Character ${eveId}`;\n\n              return { eveId, name };\n            })\n            .filter(char => {\n              // Filter out characters with invalid eveId\n              if (!char.eveId || char.eveId === '' || char.eveId === 'undefined' || char.eveId === 'null') {\n                logger.warn(`Skipping character with invalid eveId:`, char);\n                return false;\n              }\n              return true;\n            });\n\n          logger.debug(`Group ${group.id} has ${validCharacters.length} valid characters`);\n\n          return {\n            groupId: group.id,\n            name: group.name ?? `Group ${group.id.substring(0, 8)}`,\n            characters: validCharacters,\n            mainCharacterId: group.mainCharacterId?.toString?.() ?? String(group.mainCharacterId ?? ''),\n          };\n        })\n        .filter(group => group.characters.length > 0); // Filter out groups with no valid characters\n    } catch (error: unknown) {\n      logger.error('Error fetching character groups:', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n\n      // If we encounter an error, try a different approach to get at least some valid groups\n      try {\n        logger.info('Attempting alternative approach to fetch character groups');\n\n        // Get characters that belong to a group\n        const allCharacters = await this.characterRepository.getAllCharacters();\n        const characters = allCharacters.filter(c => c.characterGroupId !== null);\n\n        // Manually group them\n        const groupMap = new Map<\n          string,\n          {\n            characters: Array<{ eveId: string; name: string }>;\n            name?: string;\n            mainCharacterId?: string;\n          }\n        >();\n\n        for (const char of characters) {\n          if (!char.characterGroupId) continue;\n\n          if (!groupMap.has(char.characterGroupId)) {\n            groupMap.set(char.characterGroupId, { characters: [] });\n          }\n\n          // Ensure eveId is properly converted to string\n          const eveId = char.eveId?.toString?.() ?? String(char.eveId ?? '');\n          const name = char.name ?? `Character ${eveId}`;\n\n          // Only add if eveId is valid\n          if (eveId && eveId !== '' && eveId !== 'undefined' && eveId !== 'null') {\n            groupMap.get(char.characterGroupId)!.characters.push({\n              eveId,\n              name,\n            });\n          }\n        }\n\n        // Convert to the expected format\n        const result = Array.from(groupMap.entries())\n          .map(([groupId, data]) => ({\n            groupId,\n            name: data.name ?? `Group ${groupId.substring(0, 8)}`,\n            characters: data.characters,\n            mainCharacterId: data.mainCharacterId?.toString?.() ?? String(data.mainCharacterId ?? ''),\n          }))\n          .filter(group => group.characters.length > 0); // Filter out groups with no valid characters\n\n        logger.info(`Alternative approach found ${result.length} character groups`);\n        return result;\n      } catch (fallbackError) {\n        logger.error('Error with alternative character group approach:', fallbackError);\n\n        // Last resort: return an empty array instead of a default group\n        logger.info('No valid character groups found, returning empty array');\n        return [];\n      }\n    }\n  }\n\n  /**\n   * Get kills for a character group within a date range\n   */\n  async getKillsForGroup(groupId: string, startDate: Date, endDate: Date): Promise<Killmail[]> {\n    const kills = await this.killRepository.getKillsForGroup(groupId, startDate, endDate);\n    return kills.map(kill => new Killmail(kill));\n  }\n\n  /**\n   * Get map activity for a character group within a date range\n   */\n  async getMapActivityForGroup(groupId: string, startDate: Date, endDate: Date): Promise<MapActivity[]> {\n    const activities = await this.mapActivityRepository.getActivityForGroup(groupId, startDate, endDate);\n    return activities.map(\n      activity =>\n        new MapActivity({\n          ...activity,\n          characterId: BigInt(activity.characterId),\n        })\n    );\n  }\n\n  /**\n   * Get all character groups\n   */\n  async getAllCharacterGroups(): Promise<CharacterGroup[]> {\n    return this.characterRepository.getAllCharacterGroups();\n  }\n\n  /**\n   * Get a character group by ID\n   */\n  async getCharacterGroup(groupId: string): Promise<CharacterGroup | null> {\n    return this.characterRepository.getCharacterGroup(groupId);\n  }\n\n  /**\n   * Get all characters\n   */\n  async getAllCharacters(): Promise<Character[]> {\n    return this.characterRepository.getAllCharacters();\n  }\n\n  /**\n   * Get characters by group ID\n   */\n  async getCharactersByGroup(groupId: string): Promise<Character[]> {\n    return this.characterRepository.getCharactersByGroup(groupId);\n  }\n\n  /**\n   * Get map activity statistics for a character group\n   */\n  async getGroupActivityStats(\n    groupId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<{\n    totalSystems: number;\n    totalSignatures: number;\n    averageSignaturesPerSystem: number;\n  }> {\n    return this.mapActivityRepository.getGroupActivityStats(groupId, startDate, endDate);\n  }\n\n  /**\n   * Get kill statistics for a character group\n   */\n  async getGroupKillStats(\n    groupId: string,\n    startDate: Date,\n    endDate: Date\n  ): Promise<{\n    totalKills: number;\n    totalValue: bigint;\n    averageValue: number;\n    soloKills: number;\n  }> {\n    const kills = await this.killRepository.getKillsForGroup(groupId, startDate, endDate);\n\n    const totalKills = kills.length;\n    const totalValue = kills.reduce((sum, kill) => sum + BigInt(kill.total_value ?? 0), BigInt(0));\n    const averageValue = totalKills > 0 ? Number(totalValue) / totalKills : 0;\n\n    // Count solo kills (simplified - just check if solo flag is true)\n    const soloKills = kills.filter(kill => kill.solo).length;\n\n    return {\n      totalKills,\n      totalValue,\n      averageValue,\n      soloKills,\n    };\n  }\n\n  async getActivityData(characterIds: string[], startDate: Date, endDate: Date): Promise<ActivityData[]> {\n    return this.executeQuery(async () => {\n      const activity = await this.prisma.mapActivity.findMany({\n        where: {\n          characterId: {\n            in: characterIds.map(id => BigInt(id)),\n          },\n          timestamp: {\n            gte: startDate,\n            lte: endDate,\n          },\n        },\n        select: {\n          timestamp: true,\n          signatures: true,\n          characterId: true,\n        },\n        orderBy: {\n          timestamp: 'asc',\n        },\n      });\n\n      return activity.map(\n        (item: { timestamp: Date; signatures: number; characterId: bigint }): ActivityData => ({\n          timestamp: item.timestamp,\n          signatures: item.signatures,\n          characterId: item.characterId,\n        })\n      );\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ESIService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[826,829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[826,829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1140,1143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1140,1143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1458,1461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1458,1461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1775,1778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1775,1778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2077,2080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2077,2080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2371,2374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2371,2374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":134,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":134,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":134,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":58},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":184,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":184,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":184,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":184,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":184,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":184,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { UnifiedESIClient } from '../infrastructure/http/UnifiedESIClient';\nimport { CacheRedisAdapter } from '../cache/CacheRedisAdapter';\nimport { logger } from '../lib/logger';\nimport { Configuration } from '../config';\n\n/**\n * Service for interacting with EVE Online's ESI API\n * Provides caching and error handling around ESI data\n */\nexport class ESIService {\n  private esiClient: UnifiedESIClient;\n  private cache: CacheRedisAdapter;\n\n  /**\n   * Create a new ESI service\n   */\n  constructor() {\n    // Initialize the ESI client with Redis caching\n    this.cache = new CacheRedisAdapter(Configuration.redis.url, Configuration.redis.cacheTtl);\n    this.esiClient = new UnifiedESIClient({}, this.cache);\n  }\n\n  /**\n   * Fetch killmail data with caching\n   */\n  async getKillmail(killmailId: number, hash: string): Promise<any> {\n    try {\n      return await this.esiClient.fetchKillmail(killmailId, hash);\n    } catch (error) {\n      logger.error(`Error fetching killmail ${killmailId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch character information with caching\n   */\n  async getCharacter(characterId: number): Promise<any> {\n    try {\n      return await this.esiClient.fetchCharacter(characterId);\n    } catch (error) {\n      logger.error(`Error fetching character ${characterId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch corporation information with caching\n   */\n  async getCorporation(corporationId: number): Promise<any> {\n    try {\n      return await this.esiClient.fetchCorporation(corporationId);\n    } catch (error) {\n      logger.error(`Error fetching corporation ${corporationId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch alliance information with caching\n   */\n  async getAlliance(allianceId: number): Promise<any> {\n    try {\n      return await this.esiClient.fetchAlliance(allianceId);\n    } catch (error) {\n      logger.error(`Error fetching alliance ${allianceId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch ship type information with caching\n   */\n  async getShipType(typeId: number): Promise<any> {\n    try {\n      return await this.esiClient.fetchType(typeId);\n    } catch (error) {\n      logger.error(`Error fetching type ${typeId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch solar system information with caching\n   */\n  async getSolarSystem(systemId: number): Promise<any> {\n    try {\n      return await this.esiClient.fetchSolarSystem(systemId);\n    } catch (error) {\n      logger.error(`Error fetching system ${systemId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Map a list of ship type IDs to their names\n   * Uses batched requests and caching to optimize performance\n   */\n  async getShipTypeNames(typeIds: number[]): Promise<Record<number, string>> {\n    try {\n      // Deduplicate type IDs\n      const uniqueTypeIds = Array.from(new Set(typeIds));\n\n      // Create caching key for this list\n      const cacheKey = `ship-types-${uniqueTypeIds.sort().join('-')}`;\n\n      // Try to get from cache\n      const cached = await this.cache.get<Record<number, string>>(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      // Not in cache, need to fetch from ESI\n      const result: Record<number, string> = {};\n\n      // Process in batches of 20 to avoid rate limits\n      const batchSize = 20;\n      for (let i = 0; i < uniqueTypeIds.length; i += batchSize) {\n        const batch = uniqueTypeIds.slice(i, i + batchSize);\n\n        // Fetch each type in parallel\n        const promises = batch.map(typeId => this.getShipType(typeId));\n        const types = await Promise.all(promises);\n\n        // Map type IDs to names\n        for (let j = 0; j < batch.length; j++) {\n          const typeId = batch[j];\n          const type = types[j];\n          result[typeId] = type?.name || `Unknown Type ${typeId}`;\n        }\n      }\n\n      // Cache the result for future use\n      await this.cache.set(cacheKey, result, 60 * 60 * 24); // 24 hour cache for ship types\n\n      return result;\n    } catch (error) {\n      logger.error('Error mapping ship type IDs to names:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Map a list of corporation IDs to their names and tickers\n   */\n  async getCorporationDetails(corpIds: number[]): Promise<Record<number, { name: string; ticker: string }>> {\n    try {\n      // Deduplicate corp IDs\n      const uniqueCorpIds = Array.from(new Set(corpIds));\n\n      // Create caching key for this list\n      const cacheKey = `corp-details-${uniqueCorpIds.sort().join('-')}`;\n\n      // Try to get from cache\n      const cached = await this.cache.get<Record<number, { name: string; ticker: string }>>(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      // Not in cache, need to fetch from ESI\n      const result: Record<number, { name: string; ticker: string }> = {};\n\n      // Process in batches of 20 to avoid rate limits\n      const batchSize = 20;\n      for (let i = 0; i < uniqueCorpIds.length; i += batchSize) {\n        const batch = uniqueCorpIds.slice(i, i + batchSize);\n\n        // Fetch each corporation in parallel\n        const promises = batch.map(corpId => this.getCorporation(corpId));\n        const corps = await Promise.all(promises);\n\n        // Map corporation IDs to names and tickers\n        for (let j = 0; j < batch.length; j++) {\n          const corpId = batch[j];\n          const corp = corps[j];\n          result[corpId] = {\n            name: corp?.name || `Unknown Corp ${corpId}`,\n            ticker: corp?.ticker || '????',\n          };\n        }\n      }\n\n      // Cache the result for future use\n      await this.cache.set(cacheKey, result, 60 * 60 * 24); // 24 hour cache for corporation details\n\n      return result;\n    } catch (error) {\n      logger.error('Error mapping corporation IDs to details:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/BaseChartGenerator.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":71,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":72,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 6.","line":72,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":75,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":55},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 255.","line":76,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":76,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 16.","line":79,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":79,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 16.","line":80,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":80,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 16.","line":81,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":81,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 6.","line":131,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":131,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 16.","line":132,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":132,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":143,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":143,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":144,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":144,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":144,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":144,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":145,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":145,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":145,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":145,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":225,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":225,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 20.","line":226,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7191,7194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7191,7194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartData, ChartOptions } from '../../types/chart';\nimport { RepositoryManager } from '../../infrastructure/repositories/RepositoryManager';\nimport { FormatUtils } from './utils/FormatUtils';\nimport { TimeUtils } from './utils/TimeUtils';\nimport { logger } from '../../lib/logger';\n\n/**\n * Base class for all chart generators\n * Provides common functionality for generating charts\n */\nexport abstract class BaseChartGenerator {\n  protected colors: string[];\n  protected repoManager: RepositoryManager;\n\n  /**\n   * Create a new chart generator with dependencies injected\n   * @param repoManager Repository manager for data access\n   * @param colors Color palette for charts\n   */\n  constructor(repoManager: RepositoryManager, colors?: string[]) {\n    this.repoManager = repoManager;\n    this.colors = colors ?? [\n      '#3366CC',\n      '#DC3912',\n      '#FF9900',\n      '#109618',\n      '#990099',\n      '#0099C6',\n      '#DD4477',\n      '#66AA00',\n      '#B82E2E',\n      '#316395',\n    ];\n  }\n\n  /**\n   * Generate chart data based on input options\n   * This method must be implemented by all chart generators\n   */\n  abstract generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{\n        eveId: string;\n        name: string;\n        mainCharacterId?: string;\n      }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData>;\n\n  /**\n   * Get color for a specific index (cycles through the color array)\n   */\n  protected getColorForIndex(index: number): string {\n    return this.colors[index % this.colors.length];\n  }\n\n  /**\n   * Adjust the brightness of a color by a percentage\n   * @param hexColor Hex color string (e.g., \"#FFFFFF\")\n   * @param percent Percentage to adjust (-100 to 100)\n   */\n  protected adjustColorBrightness(hexColor: string, percent: number): string {\n    const hex = hexColor.replace('#', '');\n    const r = parseInt(hex.substring(0, 2), 16);\n    const g = parseInt(hex.substring(2, 4), 16);\n    const b = parseInt(hex.substring(4, 6), 16);\n\n    const adjustValue = (value: number): number => {\n      const adjustedValue = value * (1 + percent / 100);\n      return Math.min(255, Math.max(0, Math.round(adjustedValue)));\n    };\n\n    const rr = adjustValue(r).toString(16).padStart(2, '0');\n    const gg = adjustValue(g).toString(16).padStart(2, '0');\n    const bb = adjustValue(b).toString(16).padStart(2, '0');\n\n    return `#${rr}${gg}${bb}`;\n  }\n\n  /**\n   * Format value for readability (e.g., 1000 -> 1K)\n   * @deprecated Use FormatUtils.formatValue instead\n   */\n  protected formatValue(value: number): string {\n    return FormatUtils.formatValue(value);\n  }\n\n  /**\n   * Format BigInt value for readability\n   * @deprecated Use FormatUtils.formatBigIntValue instead\n   */\n  protected formatBigIntValue(value: bigint): string {\n    return FormatUtils.formatBigIntValue(value);\n  }\n\n  /**\n   * Get format string for a time group (hour, day, week)\n   * @deprecated Use TimeUtils.getGroupByFormat instead\n   */\n  protected getGroupByFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    return TimeUtils.getGroupByFormat(groupBy);\n  }\n\n  /**\n   * Get a date format based on the group by setting\n   */\n  protected getDateFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    switch (groupBy) {\n      case 'hour':\n        return 'yyyy-MM-dd HH:mm';\n      case 'week':\n        return \"yyyy-MM-dd 'week'\";\n      case 'day':\n      default:\n        return 'yyyy-MM-dd';\n    }\n  }\n\n  /**\n   * Generate a random color\n   */\n  protected getRandomColor(): string {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n\n  // Add additional utility functions for consistent color handling\n  protected getStandardColor(index: number, opacity: number = 1): string {\n    const hexColor = this.colors[index % this.colors.length];\n    if (opacity === 1) return hexColor;\n\n    // Convert hex to rgba for opacity\n    const r = parseInt(hexColor.slice(1, 3), 16);\n    const g = parseInt(hexColor.slice(3, 5), 16);\n    const b = parseInt(hexColor.slice(5, 7), 16);\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  }\n\n  /**\n   * Get display name for a character group\n   * Prioritizes main character name if available\n   */\n  protected getGroupDisplayName(group: {\n    name: string;\n    characters: Array<{ eveId: string; name: string }>;\n    mainCharacterId?: string;\n  }): string {\n    // Debug log: print group info\n    const charList = group.characters.map(c => `${c.eveId}:${c.name}`).join(', ');\n    logger.debug('getGroupDisplayName called', {\n      groupName: group.name,\n      mainCharacterId: group.mainCharacterId,\n      characters: charList,\n    });\n    if (group.mainCharacterId) {\n      const main = group.characters.find(c => c.eveId === group.mainCharacterId);\n      if (main) {\n        logger.debug('Returning main character name', {\n          mainCharacterName: main.name,\n        });\n        return main.name;\n      } else {\n        logger.debug('Main character ID not found in characters', {\n          mainCharacterId: group.mainCharacterId,\n        });\n      }\n    }\n    if (group.characters.length > 0) {\n      logger.debug('Returning first character name', {\n        firstCharacterName: group.characters[0].name,\n      });\n      return group.characters[0].name;\n    }\n    logger.debug('Returning group name', {\n      groupName: group.name,\n    });\n    return group.name;\n  }\n\n  /**\n   * Get dataset colors for a specific chart type\n   */\n  protected getDatasetColors(type: string): {\n    primary: string;\n    secondary: string;\n  } {\n    switch (type) {\n      case 'kills':\n        return {\n          primary: this.colors[0],\n          secondary: this.colors[1],\n        };\n      case 'loss':\n        return {\n          primary: this.colors[2],\n          secondary: this.colors[3],\n        };\n      case 'map':\n        return {\n          primary: this.colors[4],\n          secondary: this.colors[5],\n        };\n      default:\n        return {\n          primary: this.colors[0],\n          secondary: this.colors[1],\n        };\n    }\n  }\n\n  // Helper to make lower-value bars more visible by ensuring brightness\n  protected getVisibleColors(values: number[], colorSet: string[]): string[] {\n    return values.map((value, i) => {\n      // For low values, increase brightness to ensure visibility\n      if (value > 0 && value < 5) {\n        return this.adjustColorBrightness(colorSet[i % colorSet.length], 20);\n      }\n      return colorSet[i % colorSet.length];\n    });\n  }\n\n  /**\n   * Create default chart options\n   */\n  protected getDefaultOptions(title: string): ChartOptions {\n    return {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        title: {\n          display: true,\n          text: title,\n          font: {\n            size: 16,\n            weight: 'bold',\n          },\n        },\n        legend: {\n          display: true,\n          position: 'top',\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label ?? '';\n              const value = context.parsed.y !== undefined ? context.parsed.y : context.parsed;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Time',\n          },\n        },\n        y: {\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Value',\n          },\n        },\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/BaseChartService.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":48,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":53},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":51,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":51,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":54,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 90.","line":57,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":57,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseRepository } from '../../infrastructure/repositories/BaseRepository';\nimport { CharacterRepository } from '../../infrastructure/repositories/CharacterRepository';\nimport { KillRepository } from '../../infrastructure/repositories/KillRepository';\nimport { MapActivityRepository } from '../../infrastructure/repositories/MapActivityRepository';\nimport { Character } from '../../domain/character/Character';\nimport { CharacterGroup } from '../../domain/character/CharacterGroup';\nimport { PrismaClient } from '@prisma/client';\n\nexport abstract class BaseChartService extends BaseRepository {\n  protected readonly characterRepository: CharacterRepository;\n  protected readonly killRepository: KillRepository;\n  protected readonly mapActivityRepository: MapActivityRepository;\n\n  protected colors: string[] = [\n    '#3366CC', // deep blue\n    '#DC3912', // red\n    '#FF9900', // orange\n    '#109618', // green\n    '#990099', // purple\n    '#0099C6', // teal\n    '#DD4477', // pink\n    '#66AA00', // lime\n    '#B82E2E', // dark red\n    '#316395', // navy\n    '#994499', // violet\n    '#22AA99', // seafoam\n    '#6633CC', // blue violet\n    '#E67300', // dark orange\n    '#8B0707', // dark red\n    '#651067', // dark purple\n    '#329262', // forest green\n    '#5574A6', // steel blue\n    '#3B3EAC', // royal blue\n    '#B77322', // brownish orange\n  ];\n\n  constructor(prisma: PrismaClient) {\n    super('ChartService'); // BaseRepository expects a model name string\n    this.characterRepository = new CharacterRepository(prisma);\n    this.killRepository = new KillRepository(prisma);\n    this.mapActivityRepository = new MapActivityRepository();\n  }\n\n  protected calculateStartDate(period: string): Date {\n    const startDate = new Date();\n    switch (period) {\n      case '24h':\n        startDate.setHours(startDate.getHours() - 24);\n        break;\n      case '7d':\n        startDate.setDate(startDate.getDate() - 7);\n        break;\n      case '30d':\n        startDate.setDate(startDate.getDate() - 30);\n        break;\n      case '90d':\n        startDate.setDate(startDate.getDate() - 90);\n        break;\n      default:\n        throw new Error(`Invalid period: ${period}`);\n    }\n    return startDate;\n  }\n\n  protected generateChartTitle(type: string, displayMetric: string, period: string): string {\n    const metricLabel =\n      displayMetric === 'value'\n        ? 'ISK Value'\n        : displayMetric === 'kills'\n          ? 'Kill Count'\n          : displayMetric === 'points'\n            ? 'Points'\n            : 'Attacker Count';\n\n    return `${type === 'kills' ? 'Kills' : 'Map Activity'} - ${metricLabel} - Last ${\n      period === '24h' ? '24 Hours' : period === '7d' ? '7 Days' : period === '30d' ? '30 Days' : '90 Days'\n    }`;\n  }\n\n  protected getColor(index: number): string {\n    return this.colors[index % this.colors.length];\n  }\n\n  async getTrackedCharacters(): Promise<Array<{ id: string; name: string; active: boolean }>> {\n    const characters = await this.characterRepository.getAllCharacters();\n    return characters.map(char => ({\n      id: char.eveId.toString(),\n      name: char.name,\n      active: true, // Assume all tracked characters are active\n    }));\n  }\n\n  async getCharacterGroups(): Promise<\n    Array<{\n      id: string;\n      name: string;\n      description: string;\n      active: boolean;\n      characters: Array<{ id: string; name: string }>;\n    }>\n  > {\n    const groups = await this.characterRepository.getAllCharacterGroups();\n    return groups.map(group => ({\n      id: group.id,\n      name: group.name,\n      description: group.name, // Use name as description since description property doesn't exist\n      active: true, // Assume all groups are active\n      characters:\n        group.characters?.map(char => ({\n          id: char.eveId.toString(),\n          name: char.name,\n        })) || [],\n    }));\n  }\n\n  async getAllCharacterGroups(): Promise<CharacterGroup[]> {\n    return this.characterRepository.getAllCharacterGroups();\n  }\n\n  async getCharacterGroup(groupId: string): Promise<CharacterGroup | null> {\n    return this.characterRepository.getCharacterGroup(groupId);\n  }\n\n  async getAllCharacters(): Promise<Character[]> {\n    return this.characterRepository.getAllCharacters();\n  }\n\n  async getCharactersByGroup(groupId: string): Promise<Character[]> {\n    return this.characterRepository.getCharactersByGroup(groupId);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/ChartFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/ChartServiceFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/CorpsChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[721,724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[721,724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1173,1176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1173,1176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":50,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":50,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":51,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":51,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":51,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":51,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2054,2057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2054,2057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2506,2509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2506,2509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":109,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":109,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":110,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":110,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3436,3439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3436,3439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":155,"column":80,"nodeType":"Literal","messageId":"noMagic","endLine":155,"endColumn":83},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":164,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":79}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Corps charts\n */\nexport const CorpsChartConfig = {\n  title: 'Top Enemy Corporations',\n  description: 'Shows horizontal bar chart of top enemy corporations',\n\n  horizontalBarOptions: {\n    indexAxis: 'y',\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 2.5,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Top Enemy Corporations',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: false, // No legend needed for single dataset\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.x;\n            return `${label}: ${value.toLocaleString()} kills`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Kill Count',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      y: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Corporation',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  verticalBarOptions: {\n    indexAxis: 'x',\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 1.5,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Top Enemy Corporations',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: false,\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            return `${label}: ${value.toLocaleString()} kills`;\n          },\n        },\n      },\n    },\n    scales: {\n      y: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Kill Count',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      x: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Corporation',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  pieOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Distribution by Enemy Corporation',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'right',\n        labels: {\n          font: {\n            size: 14,\n          },\n        },\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.label || '';\n            const value = context.raw;\n            const percentage = context.parsed;\n            return `${label}: ${value.toLocaleString()} kills (${(percentage * 100).toFixed(1)}%)`;\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Get default summary based on corp kill data\n  getDefaultSummary: (totalCorps: number, totalKills: number, topCorpName: string, topCorpKills: number): string => {\n    const topCorpPercent = totalKills > 0 ? ((topCorpKills / totalKills) * 100).toFixed(1) : '0';\n    return `Showing top ${totalCorps} enemy corporations (${totalKills.toLocaleString()} total kills). Leading corporation: ${topCorpName} (${topCorpPercent}%)`;\n  },\n\n  // Color palette for corporations\n  colors: [\n    '#3366CC', // deep blue\n    '#DC3912', // red\n    '#FF9900', // orange\n    '#109618', // green\n    '#990099', // purple\n    '#0099C6', // teal\n    '#DD4477', // pink\n    '#66AA00', // lime\n    '#B82E2E', // dark red\n    '#316395', // navy\n    '#994499', // violet\n    '#22AA99', // seafoam\n    '#AAAA11', // olive\n    '#6633CC', // indigo\n    '#E67300', // amber\n  ],\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/DistributionChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1481,1484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1481,1484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":65,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2318,2321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2318,2321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":101,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":101,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3057,3060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3057,3060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3497,3500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3497,3500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":147,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":147,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":148,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":148,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":148,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":148,"endColumn":55},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":172,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":172,"endColumn":73},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":173,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":173,"endColumn":80},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":174,"column":79,"nodeType":"Literal","messageId":"noMagic","endLine":174,"endColumn":82}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Distribution charts\n */\nexport const DistributionChartConfig = {\n  title: 'Kill Group Distribution',\n  description: 'Shows distribution of solo vs. small-group vs. large-group kills',\n\n  // Define group sizes for categorization\n  groupSizes: {\n    solo: 1,\n    smallGroup: 5, // 2-5 attackers\n    mediumGroup: 15, // 6-15 attackers\n    largeGroup: 50, // 16-50 attackers\n    blob: Number.MAX_SAFE_INTEGER, // 51+ attackers\n  },\n\n  // Display labels for each group size\n  groupLabels: {\n    solo: 'Solo',\n    smallGroup: 'Small Group (2-5)',\n    mediumGroup: 'Medium Group (6-15)',\n    largeGroup: 'Large Group (16-50)',\n    blob: 'Blob (51+)',\n  },\n\n  // Color scheme for each group size\n  groupColors: {\n    solo: '#DC3912', // red\n    smallGroup: '#3366CC', // blue\n    mediumGroup: '#FF9900', // orange\n    largeGroup: '#109618', // green\n    blob: '#990099', // purple\n  },\n\n  // Default chart options for pie chart\n  pieOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Group Size Distribution',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'right',\n        labels: {\n          font: {\n            size: 16,\n          },\n        },\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.label || '';\n            const value = context.raw;\n            const percentage = context.parsed;\n            return `${label}: ${value} kills (${(percentage * 100).toFixed(1)}%)`;\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Default chart options for doughnut chart\n  doughnutOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    cutout: '30%',\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Group Size Distribution',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'right',\n        labels: {\n          font: {\n            size: 16,\n          },\n        },\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.label || '';\n            const value = context.raw;\n            const percentage = context.parsed;\n            return `${label}: ${value} kills (${(percentage * 100).toFixed(1)}%)`;\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Default chart options for bar chart (alternative view)\n  barOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    indexAxis: 'y',\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Group Size Distribution',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: false,\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.x;\n            return `${label}: ${value} kills`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Number of Kills',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      y: {\n        title: {\n          display: true,\n          text: 'Group Size',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Get default summary based on distribution data\n  getDefaultSummary: (\n    totalKills: number,\n    soloKills: number,\n    smallGroupKills: number,\n    mediumGroupKills: number\n  ): string => {\n    const soloPercent = totalKills > 0 ? ((soloKills / totalKills) * 100).toFixed(1) : '0';\n    const smallPercent = totalKills > 0 ? ((smallGroupKills / totalKills) * 100).toFixed(1) : '0';\n    const mediumPercent = totalKills > 0 ? ((mediumGroupKills / totalKills) * 100).toFixed(1) : '0';\n\n    return `${totalKills.toLocaleString()} total kills: ${soloPercent}% solo, ${smallPercent}% small group, ${mediumPercent}% medium group`;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/EfficiencyChartConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/EfficiencyGaugeConfig.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":20,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":20,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Chart from 'chart.js/auto';\nimport { DoughnutController, ArcElement, Tooltip } from 'chart.js';\nimport type { ChartConfiguration } from 'chart.js';\nimport { chartPalette } from './theme';\n\n// Register doughnut + tooltip\nChart.register(DoughnutController, ArcElement, Tooltip);\n\n// These will be filled in by the generator\nconst characterNames: string[] = [];\nconst efficiencyPercents: number[] = [];\n\nexport const EfficiencyGaugeConfig: ChartConfiguration<'doughnut'> = {\n  type: 'doughnut',\n  data: {\n    labels: characterNames,\n    datasets: [\n      {\n        // filled portion = efficiency, empty = remainder\n        data: efficiencyPercents.map(p => [p, 100 - p]).flat(),\n        backgroundColor: efficiencyPercents.flatMap(() => [chartPalette[2], 'rgba(255,255,255,0.1)']),\n        borderWidth: 0,\n      },\n    ],\n  },\n  options: {\n    rotation: -Math.PI,\n    circumference: Math.PI,\n    cutout: '70%',\n    plugins: {\n      legend: { display: false },\n    },\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/HeatmapChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[826,829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[826,829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1005,1008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1005,1008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2310,2313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2310,2313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2419,2422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2419,2422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":126,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":54},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":139,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":139,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Heatmap charts\n */\nexport const HeatmapChartConfig = {\n  title: 'Kill Activity Heatmap',\n  description: 'Shows heatmap of kill activity by hour and day of week',\n\n  // Options for the basic heatmap view\n  heatmapOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 1.5,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Activity by Time of Day',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'right',\n        align: 'center',\n        labels: {\n          boxWidth: 20,\n          font: {\n            size: 14,\n          },\n        },\n      },\n      tooltip: {\n        callbacks: {\n          title: (ctx: any) => {\n            const dayName = ctx[0].label;\n            const hour = ctx[0].dataset.label;\n            return `${dayName} at ${hour}`;\n          },\n          label: (ctx: any) => {\n            const value = ctx.raw;\n            return `${value} kills`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        title: {\n          display: true,\n          text: 'Day of Week',\n          font: {\n            size: 16,\n            weight: 'bold',\n          },\n        },\n        grid: {\n          display: true,\n          color: 'rgba(0, 0, 0, 0.1)',\n        },\n      },\n      y: {\n        title: {\n          display: true,\n          text: 'Hour of Day',\n          font: {\n            size: 16,\n            weight: 'bold',\n          },\n        },\n        grid: {\n          display: true,\n          color: 'rgba(0, 0, 0, 0.1)',\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Options for the calendar style view\n  calendarOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 1.7,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Calendar View of Kill Activity',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'right',\n        align: 'center',\n        labels: {\n          boxWidth: 20,\n          font: {\n            size: 14,\n          },\n        },\n      },\n      tooltip: {\n        callbacks: {\n          title: (ctx: any) => {\n            return ctx[0].dataset.data[ctx[0].dataIndex].date;\n          },\n          label: (ctx: any) => {\n            return `${ctx.raw.v} kills`;\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Days of the week for labels\n  daysOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n\n  // Short days of the week for labels\n  shortDaysOfWeek: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n\n  // Hour labels (24-hour format)\n  hours: Array.from({ length: 24 }, (_, i) => (i < 10 ? `0${i}:00` : `${i}:00`)),\n\n  // Color gradient for heatmap (from low to high activity)\n  colorGradient: [\n    '#EBEDF0', // very low\n    '#9BE9A8', // low\n    '#40C463', // medium\n    '#30A14E', // high\n    '#216E39', // very high\n  ],\n\n  // Get default summary based on heatmap data\n  getDefaultSummary: (totalKills: number, peakDay: string, peakHour: string, peakKills: number): string => {\n    const peakPercent = totalKills > 0 ? ((peakKills / totalKills) * 100).toFixed(1) : '0';\n    return `${totalKills.toLocaleString()} total kills. Peak activity: ${peakDay} at ${peakHour} (${peakKills} kills, ${peakPercent}% of total)`;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/KillsChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[630,633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[630,633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1466,1469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1466,1469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2302,2305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2302,2305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":132,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":132,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Kills charts\n */\nexport const KillsChartConfig = {\n  title: 'Kills by Character Group',\n  metrics: [\n    { name: 'Total Kills', field: 'totalKills', color: '#3366CC' },\n    { name: 'Solo Kills', field: 'soloKills', color: '#DC3912' },\n  ],\n  options: {\n    horizontal: {\n      indexAxis: 'y' as 'x' | 'y',\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.x;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Character Group',\n          },\n        },\n      },\n    } as ChartOptions,\n    vertical: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.y;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Character Group',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n      },\n    } as ChartOptions,\n    timeline: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.y;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          type: 'time' as const,\n          time: {\n            unit: 'day' as const,\n            displayFormats: {\n              hour: 'HH:mm',\n              day: 'MMM dd',\n              week: 'MMM dd',\n            },\n          },\n          title: {\n            display: true,\n            text: 'Time',\n          },\n        },\n        y: {\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Kills',\n          },\n        },\n      },\n    } as ChartOptions,\n  },\n  getDefaultSummary: (totalKills: number, soloKills: number) => {\n    return `Total kills: ${totalKills.toLocaleString()}\\nSolo kills: ${soloKills.toLocaleString()} (${\n      totalKills > 0 ? Math.round((soloKills / totalKills) * 100) : 0\n    }%)`;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/LossChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[644,647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[644,647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1480,1483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1480,1483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2316,2319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2316,2319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":132,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":132,"endColumn":73}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Loss charts\n */\nexport const LossChartConfig = {\n  title: 'Losses by Character Group',\n  metrics: [\n    { name: 'Total Losses', field: 'totalLosses', color: '#DC3912' },\n    { name: 'High Value Losses', field: 'highValueLosses', color: '#FF9900' },\n  ],\n  options: {\n    horizontal: {\n      indexAxis: 'y' as 'x' | 'y',\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.x;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Character Group',\n          },\n        },\n      },\n    } as ChartOptions,\n    vertical: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.y;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          stacked: true,\n          title: {\n            display: true,\n            text: 'Character Group',\n          },\n        },\n        y: {\n          stacked: true,\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Count',\n          },\n        },\n      },\n    } as ChartOptions,\n    timeline: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: true,\n          position: 'top' as const,\n        },\n        tooltip: {\n          callbacks: {\n            label: function (context: any) {\n              const label = context.dataset.label || '';\n              const value = context.parsed.y;\n              return `${label}: ${value.toLocaleString()}`;\n            },\n          },\n        },\n      },\n      scales: {\n        x: {\n          type: 'time' as const,\n          time: {\n            unit: 'day' as const,\n            displayFormats: {\n              hour: 'HH:mm',\n              day: 'MMM dd',\n              week: 'MMM dd',\n            },\n          },\n          title: {\n            display: true,\n            text: 'Time',\n          },\n        },\n        y: {\n          beginAtZero: true,\n          title: {\n            display: true,\n            text: 'Losses',\n          },\n        },\n      },\n    } as ChartOptions,\n  },\n  getDefaultSummary: (totalLosses: number, highValueLosses: number, totalIskLost: string) => {\n    return `Total ship losses: ${totalLosses.toLocaleString()}\\nHigh-value losses: ${highValueLosses.toLocaleString()} (${\n      totalLosses > 0 ? Math.round((highValueLosses / totalLosses) * 100) : 0\n    }%)\\nTotal ISK lost: ${totalIskLost}`;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/MapChartConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/RatioChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[517,520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[517,520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Configuration for Kill-Death Ratio charts\n */\nexport const RatioChartConfig = {\n  title: 'Kill-Death Ratio by Character Group',\n  metrics: [\n    { name: 'K/D Ratio', field: 'ratio', color: '#3366CC' },\n    { name: 'Efficiency %', field: 'efficiency', color: '#109618' },\n  ],\n  chartOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      legend: {\n        display: true,\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n\n            if (label.includes('Ratio')) {\n              return `${label}: ${value.toFixed(2)}`;\n            } else if (label.includes('Efficiency')) {\n              return `${label}: ${value.toFixed(1)}%`;\n            }\n            return `${label}: ${value}`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        title: {\n          display: true,\n          text: 'Character Group',\n        },\n      },\n      y: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Ratio / Percentage',\n        },\n      },\n    },\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/ShipTypesChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[720,723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[720,723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1167,1170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1167,1170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":50,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":50,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":51,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":51,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":51,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":51,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2021,2024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2021,2024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":108,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":108,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":109,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":109,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3302,3305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3302,3305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3749,3752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3749,3752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":165,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":165,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":166,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":166,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\n\n/**\n * Configuration for Ship Types charts\n */\nexport const ShipTypesChartConfig = {\n  title: 'Ship Types Destroyed',\n  description: 'Shows top ship types destroyed (by count)',\n\n  horizontalBarOptions: {\n    indexAxis: 'y',\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 2.5,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Top Ship Types Destroyed',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: false, // Don't need legend for single dataset\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.x;\n            return `${label}: ${value.toLocaleString()} ships`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Count',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      y: {\n        title: {\n          display: true,\n          text: 'Ship Type',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  verticalBarOptions: {\n    indexAxis: 'x',\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 1.5,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Top Ship Types Destroyed',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: false,\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            return `${label}: ${value.toLocaleString()} ships`;\n          },\n        },\n      },\n    },\n    scales: {\n      y: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Count',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      x: {\n        title: {\n          display: true,\n          text: 'Ship Type',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  timelineOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    aspectRatio: 2,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Ship Types Destroyed Over Time',\n        font: {\n          size: 40,\n          weight: 'bold',\n        },\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n      tooltip: {\n        callbacks: {\n          label: function (context: any) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            return `${label}: ${value.toLocaleString()} ships`;\n          },\n        },\n      },\n    },\n    scales: {\n      y: {\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Count',\n          font: {\n            size: 16,\n          },\n        },\n        ticks: {\n          callback: function (value: any) {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      x: {\n        title: {\n          display: true,\n          text: 'Date',\n          font: {\n            size: 16,\n          },\n        },\n      },\n    },\n  } as ChartOptions,\n\n  // Get default summary based on ship type data\n  getDefaultSummary: (totalShipTypes: number, totalDestroyed: number): string => {\n    return `Showing top ${totalShipTypes} ship types destroyed (${totalDestroyed.toLocaleString()} total kills)`;\n  },\n\n  // Color palette for ship types\n  colors: [\n    '#3366CC', // deep blue\n    '#DC3912', // red\n    '#FF9900', // orange\n    '#109618', // green\n    '#990099', // purple\n    '#0099C6', // teal\n    '#DD4477', // pink\n    '#66AA00', // lime\n    '#B82E2E', // dark red\n    '#316395', // navy\n  ],\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/TrendChartConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1301,1304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1301,1304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2199,2202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2199,2202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":95,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":95,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":95,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":95,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":96,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":96,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":96,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":96,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2921,2924],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2921,2924],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3825,3828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3825,3828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":165,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":165,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":166,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":166,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4550,4553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4550,4553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5564,5567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5564,5567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":238,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":238,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":238,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":238,"endColumn":61},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":239,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":239,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":239,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":239,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":261,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6217,6220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6217,6220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChartOptions } from '../../../types/chart';\nimport { theme } from './theme';\n\ninterface TrendChartConfigType extends ChartOptions {\n  colors: string[];\n  title: string;\n  timelineOptions: ChartOptions;\n  areaOptions: ChartOptions;\n  dualAxisOptions: ChartOptions;\n  getDefaultSummary: (\n    totalKills: number,\n    averageKillsPerDay: number,\n    trend: 'increasing' | 'stable' | 'decreasing'\n  ) => string;\n}\n\nexport const TrendChartConfig: TrendChartConfigType = {\n  responsive: true,\n  maintainAspectRatio: false,\n  colors: [\n    '#3366CC', // deep blue\n    '#DC3912', // red\n    '#FF9900', // orange\n    '#109618', // green\n    '#990099', // purple\n    '#0099C6', // teal\n    '#DD4477', // pink\n    '#66AA00', // lime\n    '#B82E2E', // dark red\n    '#316395', // navy\n  ],\n  title: 'Kill Trends Over Time',\n  timelineOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kill Trends Over Time',\n        font: {\n          size: theme.text.font.size.large,\n          weight: theme.text.font.weight.bold,\n        },\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n      tooltip: {\n        mode: 'index',\n        intersect: false,\n        callbacks: {\n          label: (context: any) => {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            return `${label}: ${value.toLocaleString()}`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        type: 'time',\n        time: {\n          unit: 'day',\n          displayFormats: {\n            day: 'MMM d',\n          },\n        },\n        title: {\n          display: true,\n          text: 'Date',\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n      },\n      y: {\n        type: 'linear',\n        display: true,\n        position: 'left',\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Kill Count',\n          font: {\n            size: theme.text.font.size.medium,\n          },\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n        ticks: {\n          callback: (value: any) => {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n    },\n  },\n  areaOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Cumulative Kills Over Time',\n        font: {\n          size: theme.text.font.size.large,\n          weight: theme.text.font.weight.bold,\n        },\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n      tooltip: {\n        mode: 'index',\n        intersect: false,\n        callbacks: {\n          label: (context: any) => {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            return `${label}: ${value.toLocaleString()}`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        type: 'time',\n        time: {\n          unit: 'day',\n          displayFormats: {\n            day: 'MMM d',\n          },\n        },\n        title: {\n          display: true,\n          text: 'Date',\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n      },\n      y: {\n        type: 'linear',\n        display: true,\n        position: 'left',\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Cumulative Kills',\n          font: {\n            size: theme.text.font.size.medium,\n          },\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n        ticks: {\n          callback: (value: any) => {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n    },\n  },\n  dualAxisOptions: {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      title: {\n        display: true,\n        text: 'Kills vs. Value Over Time',\n        font: {\n          size: theme.text.font.size.large,\n          weight: theme.text.font.weight.bold,\n        },\n      },\n      legend: {\n        display: true,\n        position: 'top',\n      },\n      tooltip: {\n        mode: 'index',\n        intersect: false,\n        callbacks: {\n          label: (context: any) => {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y;\n            if (label.includes('Value')) {\n              return `${label}: ${value.toFixed(1)}B ISK`;\n            }\n            return `${label}: ${value.toLocaleString()}`;\n          },\n        },\n      },\n    },\n    scales: {\n      x: {\n        type: 'time',\n        time: {\n          unit: 'day',\n          displayFormats: {\n            day: 'MMM d',\n          },\n        },\n        title: {\n          display: true,\n          text: 'Date',\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n      },\n      y: {\n        type: 'linear',\n        display: true,\n        position: 'left',\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'Kill Count',\n          font: {\n            size: theme.text.font.size.medium,\n          },\n        },\n        grid: {\n          color: theme.grid.color,\n        },\n        ticks: {\n          callback: (value: any) => {\n            if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;\n            if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;\n            return value.toString();\n          },\n        },\n      },\n      y2: {\n        type: 'linear',\n        display: true,\n        position: 'right',\n        beginAtZero: true,\n        title: {\n          display: true,\n          text: 'ISK Value (Billions)',\n          font: {\n            size: theme.text.font.size.medium,\n          },\n        },\n        grid: {\n          color: theme.grid.color,\n          drawOnChartArea: false,\n        },\n        ticks: {\n          callback: (value: any) => {\n            return `${value.toFixed(1)}B`;\n          },\n        },\n      },\n    },\n  },\n  getDefaultSummary: (\n    totalKills: number,\n    averageKillsPerDay: number,\n    trend: 'increasing' | 'stable' | 'decreasing'\n  ) => {\n    const trendEmoji = trend === 'increasing' ? '📈' : trend === 'decreasing' ? '📉' : '➡️';\n    const trendText = trend === 'increasing' ? 'increasing' : trend === 'decreasing' ? 'decreasing' : 'stable';\n    return `${trendEmoji} ${totalKills.toLocaleString()} total kills (${averageKillsPerDay.toFixed(\n      1\n    )} per day) with ${trendText} trend`;\n  },\n};\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/config/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/CorpsChartGenerator.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 15.","line":97,"column":7,"nodeType":"Literal","messageId":"noMagic","endLine":97,"endColumn":9},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -20.","line":126,"column":101,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":126,"endColumn":104},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generatePieChart' has too many lines (62). Maximum allowed is 50.","line":165,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":252,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":186,"column":7,"nodeType":"Literal","messageId":"noMagic","endLine":186,"endColumn":9},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.01.","line":210,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":210,"endColumn":54},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -20.","line":234,"column":81,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":234,"endColumn":84}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { CorpsChartConfig } from '../config';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\nimport axios from 'axios';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\n/**\n * Generator for enemy corporation charts\n */\nexport class CorpsChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n  // Helper to fetch corp ticker from ESI and cache it\n  private corpTickerCache: Record<string, string> = {};\n\n  /**\n   * Create a new corps chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n  }\n\n  /**\n   * Generate an enemy corporation chart based on the provided options\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    try {\n      const { startDate, endDate, characterGroups, displayType } = options;\n      logger.info(`Generating enemy corps chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      logger.debug(`Chart type: ${displayType}, Groups: ${characterGroups.length}`);\n\n      // Select chart generation function based on display type\n      if (displayType === 'verticalBar') {\n        return this.generateVerticalBarChart(characterGroups, startDate, endDate);\n      } else if (displayType === 'pie') {\n        return this.generatePieChart(characterGroups, startDate, endDate);\n      } else {\n        // Default to horizontal bar chart\n        return this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n      }\n    } catch (error) {\n      logger.error('Error generating enemy corps chart:', error);\n      throw error;\n    }\n  }\n\n  // Helper to fetch corp ticker from ESI and cache it\n  private async getCorpTicker(corpId: string): Promise<string> {\n    if (this.corpTickerCache[corpId]) return this.corpTickerCache[corpId];\n    try {\n      const resp = await axios.get(`https://esi.evetech.net/latest/corporations/${corpId}/?datasource=tranquility`);\n      const ticker = resp.data.ticker || corpId;\n      this.corpTickerCache[corpId] = ticker;\n      return ticker;\n    } catch {\n      return corpId;\n    }\n  }\n\n  /**\n   * Generate a horizontal bar chart showing top enemy corporations\n   */\n  private async generateHorizontalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // Extract all character IDs from the groups\n    const characterIds = characterGroups.flatMap(group => group.characters).map(character => BigInt(character.eveId));\n\n    if (characterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n\n    // Get the top enemy corporations data\n    const corpsData = await this.killRepository.getTopEnemyCorporations(\n      characterIds,\n      startDate,\n      endDate,\n      15 // Limit to top 15 enemy corporations\n    );\n\n    if (corpsData.length === 0) {\n      throw new Error('No enemy corporation data found for the specified time period');\n    }\n\n    // Lookup tickers for all corpIds\n    const labelTickers = await Promise.all(corpsData.map(corp => this.getCorpTicker(corp.corpId)));\n\n    // Sort by kill count in descending order\n    corpsData.sort((a, b) => b.killCount - a.killCount);\n\n    // Calculate total kills\n    const totalKills = corpsData.reduce((sum, corp) => sum + corp.killCount, 0);\n\n    // Get top corporation information for summary\n    const topCorp = corpsData[0];\n    const topCorpTicker = labelTickers[0];\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: labelTickers,\n      datasets: [\n        {\n          label: 'Kills',\n          data: corpsData.map(corp => corp.killCount),\n          backgroundColor: corpsData.map((_, i) => CorpsChartConfig.colors[i % CorpsChartConfig.colors.length]),\n          borderColor: corpsData.map((_, i) =>\n            this.adjustColorBrightness(CorpsChartConfig.colors[i % CorpsChartConfig.colors.length], -20)\n          ),\n        },\n      ],\n      displayType: 'bar',\n      options: {\n        indexAxis: 'y',\n      },\n      title: `${CorpsChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      summary: CorpsChartConfig.getDefaultSummary(corpsData.length, totalKills, topCorpTicker, topCorp.killCount),\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Generate a vertical bar chart showing top enemy corporations\n   */\n  private async generateVerticalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // This is similar to horizontal bar chart but with a different orientation\n    const chartData = await this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n\n    // Override options for vertical orientation\n    chartData.options = CorpsChartConfig.verticalBarOptions;\n    chartData.displayType = 'bar';\n    return chartData;\n  }\n\n  /**\n   * Generate a pie chart showing distribution of kills among top enemy corporations\n   */\n  private async generatePieChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // Extract all character IDs from the groups\n    const characterIds = characterGroups.flatMap(group => group.characters).map(character => BigInt(character.eveId));\n\n    if (characterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n\n    // Get the top enemy corporations data - limit to a smaller number for better pie visualization\n    const corpsData = await this.killRepository.getTopEnemyCorporations(\n      characterIds,\n      startDate,\n      endDate,\n      10 // Limit to top 10 corps for pie chart\n    );\n\n    if (corpsData.length === 0) {\n      throw new Error('No enemy corporation data found for the specified time period');\n    }\n\n    // Sort by kill count in descending order\n    corpsData.sort((a, b) => b.killCount - a.killCount);\n\n    // Calculate total kills for the top corporations\n    const totalTopCorpsKills = corpsData.reduce((sum, corp) => sum + corp.killCount, 0);\n\n    // Get total kills for all corporations to calculate \"Others\" category\n    // Note: This is currently a placeholder implementation\n    await this.killRepository.getTopEnemyCorporations(characterIds, startDate, endDate);\n\n    // Since this is a placeholder, use the top corps total as the total for now\n    const totalAllCorpsKills = totalTopCorpsKills;\n\n    // Calculate \"Others\" if there's a significant difference\n    const otherCorpsKills = totalAllCorpsKills - totalTopCorpsKills;\n\n    // Only add \"Others\" category if it's more than 1% of total kills\n    const othersThreshold = totalAllCorpsKills * 0.01;\n\n    // Copy the data and add \"Others\" if needed\n    const pieLabels = corpsData.map(corp => corp.corpName || corp.corpId);\n    const pieData = corpsData.map(corp => corp.killCount);\n    const pieColors = corpsData.map((_, i) => CorpsChartConfig.colors[i % CorpsChartConfig.colors.length]);\n\n    if (otherCorpsKills > othersThreshold) {\n      pieLabels.push('Others');\n      pieData.push(otherCorpsKills);\n      pieColors.push('#999999'); // Gray for \"Others\"\n    }\n\n    // Get top corporation information for summary\n    const topCorp = corpsData[0];\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: pieLabels,\n      datasets: [\n        {\n          label: 'Kills',\n          data: pieData,\n          backgroundColor: pieColors,\n          borderColor: pieColors.map(color => this.adjustColorBrightness(color, -20)),\n        },\n      ],\n      displayType: 'pie',\n      title: `Kill Distribution by Enemy Corporation - ${format(\n        startDate,\n        'MMM d'\n      )} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: CorpsChartConfig.pieOptions,\n      summary: CorpsChartConfig.getDefaultSummary(\n        corpsData.length,\n        totalAllCorpsKills,\n        topCorp.corpName || topCorp.corpId,\n        topCorp.killCount\n      ),\n    };\n\n    return chartData;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/DistributionChartGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/EfficiencyChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (61). Maximum allowed is 50.","line":25,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":97,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":60,"column":101,"nodeType":"Literal","messageId":"noMagic","endLine":60,"endColumn":104}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData, ChartDisplayType } from '../../../types/chart';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { LossRepository } from '../../../infrastructure/repositories/LossRepository';\nimport { logger } from '../../../lib/logger';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\n/**\n * Generator for efficiency charts\n */\nexport class EfficiencyChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n  private lossRepository: LossRepository;\n\n  /**\n   * Create a new efficiency chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n    this.lossRepository = this.repoManager.getLossRepository();\n  }\n\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { startDate, endDate, characterGroups } = options;\n    logger.info('Generating efficiency chart');\n\n    // Get all character IDs from all groups\n    const characterIds = characterGroups.flatMap(group => group.characters.map(c => BigInt(c.eveId)));\n\n    // Get kills and losses for all characters\n    const [kills, losses] = await Promise.all([\n      this.killRepository.getKillsForCharacters(\n        characterIds.map(id => BigInt(id)),\n        startDate,\n        endDate\n      ),\n      this.lossRepository.getLossesByTimeRange(startDate, endDate),\n    ]);\n\n    // Group data by character group\n    const groupData = characterGroups.map(group => {\n      const groupCharacterIds = group.characters.map(c => BigInt(c.eveId));\n      const groupKills = kills.filter(kill => groupCharacterIds.includes(BigInt(kill.character_id)));\n      const groupLosses = losses.filter(loss => groupCharacterIds.includes(BigInt(loss.characterId)));\n\n      const totalKills = groupKills.length;\n      const totalLosses = groupLosses.length;\n      const efficiency = totalKills + totalLosses > 0 ? (totalKills / (totalKills + totalLosses)) * 100 : 0;\n\n      return {\n        group,\n        kills: groupKills,\n        losses: groupLosses,\n        totalKills,\n        totalLosses,\n        efficiency,\n      };\n    });\n\n    // Sort groups by efficiency\n    groupData.sort((a, b) => b.efficiency - a.efficiency);\n\n    // Create chart data\n    return {\n      labels: groupData.map(data => this.getGroupDisplayName(data.group)),\n      datasets: [\n        {\n          label: 'Efficiency (%)',\n          data: groupData.map(data => data.efficiency),\n          backgroundColor: this.getDatasetColors('kills').primary,\n        },\n        {\n          label: 'Total Kills',\n          data: groupData.map(data => data.totalKills),\n          backgroundColor: this.getDatasetColors('kills').secondary,\n        },\n        {\n          label: 'Total Losses',\n          data: groupData.map(data => data.totalLosses),\n          backgroundColor: this.getDatasetColors('loss').primary,\n        },\n      ],\n      displayType: 'horizontalBar' as ChartDisplayType,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/HeatmapChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateBasicHeatmap' has too many lines (81). Maximum allowed is 50.","line":58,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":156,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateBasicHeatmap' has a complexity of 13. Maximum allowed is 10.","line":58,"column":37,"nodeType":"FunctionExpression","messageId":"complex","endLine":156,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":101,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":101,"endColumn":33},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":103,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":32},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":113,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":113,"endColumn":33},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateCalendarHeatmap' has too many lines (61). Maximum allowed is 50.","line":161,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":236,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6837,6840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6837,6840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.25.","line":247,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":247,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.5.","line":249,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":249,"endColumn":37},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.75.","line":251,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":251,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { HeatmapChartConfig } from '../config';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\n/**\n * Generator for heatmap charts showing activity by time of day\n */\nexport class HeatmapChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n\n  /**\n   * Create a new heatmap chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n  }\n\n  /**\n   * Generate a heatmap chart based on the provided options\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    try {\n      const { startDate, endDate, characterGroups, displayType } = options;\n      logger.info(`Generating heatmap chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      logger.debug(`Chart type: ${displayType}, Groups: ${characterGroups.length}`);\n\n      // Select chart generation function based on display type\n      if (displayType === 'calendar') {\n        return this.generateCalendarHeatmap(characterGroups, startDate, endDate);\n      } else {\n        // Default to basic heatmap\n        return this.generateBasicHeatmap(characterGroups, startDate, endDate);\n      }\n    } catch (error) {\n      logger.error('Error generating heatmap chart:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a basic heatmap showing activity by hour and day of week\n   */\n  private async generateBasicHeatmap(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // Combine all character IDs from all groups\n    const allCharacterIds: bigint[] = [];\n    for (const group of characterGroups) {\n      allCharacterIds.push(...group.characters.map(c => BigInt(c.eveId)));\n    }\n\n    if (allCharacterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n\n    // Get activity data grouped by hour and day of week\n    const activityData = await this.killRepository.getKillActivityByTimeOfDay(allCharacterIds, startDate, endDate);\n\n    if (activityData.length === 0) {\n      throw new Error('No activity data found for the specified time period');\n    }\n\n    // Calculate total kills and find the peak activity\n    let totalKills = 0;\n    let peakKills = 0;\n    let peakDay = 0;\n    let peakHour = 0;\n\n    for (const data of activityData) {\n      totalKills += data.kills;\n      if (data.kills > peakKills) {\n        peakKills = data.kills;\n        peakDay = data.dayOfWeek;\n        peakHour = data.hourOfDay;\n      }\n    }\n\n    // Create a 2D matrix for the heatmap: rows = hours, columns = days\n    const matrix: number[][] = [];\n    for (let hour = 0; hour < 24; hour++) {\n      const row: number[] = [];\n      for (let day = 0; day < 7; day++) {\n        const activity = activityData.find(d => d.hourOfDay === hour && d.dayOfWeek === day);\n        row.push(activity ? activity.kills : 0);\n      }\n      matrix.push(row);\n    }\n\n    // Only include hours with activity\n    const filteredMatrix: number[][] = [];\n    const filteredHourLabels: string[] = [];\n    for (let hour = 0; hour < 24; hour++) {\n      if (matrix[hour].some(count => count > 0)) {\n        filteredMatrix.push(matrix[hour]);\n        filteredHourLabels.push(HeatmapChartConfig.hours[hour]);\n      }\n    }\n\n    // Convert the 2D matrix to ComplexDataPoint[] for heatmap plugin compatibility\n    const heatmapData = [];\n    for (let i = 0; i < filteredMatrix.length; i++) {\n      for (let j = 0; j < filteredMatrix[i].length; j++) {\n        heatmapData.push({\n          x: HeatmapChartConfig.shortDaysOfWeek[j],\n          y: filteredHourLabels[i],\n          v: filteredMatrix[i][j],\n        });\n      }\n    }\n\n    const datasets = [\n      {\n        label: 'Kill Activity',\n        data: heatmapData,\n        backgroundColor: undefined, // Let the plugin handle coloring\n      },\n    ];\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: HeatmapChartConfig.shortDaysOfWeek,\n      datasets,\n      displayType: 'heatmap', // Custom type for heatmap\n      title: `${HeatmapChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: HeatmapChartConfig.heatmapOptions,\n      summary: HeatmapChartConfig.getDefaultSummary(\n        totalKills,\n        HeatmapChartConfig.daysOfWeek[peakDay],\n        HeatmapChartConfig.hours[peakHour],\n        peakKills\n      ),\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Generate a calendar-style heatmap showing activity over time\n   */\n  private async generateCalendarHeatmap(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // Combine all character IDs from all groups\n    const allCharacterIds: bigint[] = [];\n    for (const group of characterGroups) {\n      allCharacterIds.push(...group.characters.map(c => BigInt(c.eveId)));\n    }\n\n    if (allCharacterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n\n    // For calendar view, we need kills grouped by date\n    const killData = await this.killRepository.getKillsGroupedByTime(allCharacterIds, startDate, endDate, 'day');\n\n    if (killData.length === 0) {\n      throw new Error('No activity data found for the specified time period');\n    }\n\n    // Calculate totals and find peak activity\n    let totalKills = 0;\n    let peakKills = 0;\n    let peakDate = new Date();\n\n    for (const data of killData) {\n      totalKills += data.kills;\n      if (data.kills > peakKills) {\n        peakKills = data.kills;\n        peakDate = data.timestamp;\n      }\n    }\n\n    // Format data for calendar heatmap\n    const calendarData = killData.map(data => ({\n      x: format(data.timestamp, 'yyyy-MM-dd'),\n      y: data.timestamp.getDay(), // Day of week (0-6)\n      v: data.kills, // Value (kill count)\n      date: format(data.timestamp, 'EEEE, MMMM d, yyyy'),\n    }));\n\n    // Create datasets\n    const datasets = [\n      {\n        label: 'Kill Activity',\n        data: calendarData,\n        backgroundColor: (context: any) => {\n          const value = context.dataset.data[context.dataIndex].v;\n          return this.getHeatmapColor(value, peakKills);\n        },\n      },\n    ];\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: HeatmapChartConfig.shortDaysOfWeek,\n      datasets,\n      displayType: 'calendar', // Custom type for calendar heatmap\n      title: `${HeatmapChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: HeatmapChartConfig.calendarOptions,\n      summary: HeatmapChartConfig.getDefaultSummary(\n        totalKills,\n        format(peakDate, 'EEEE'),\n        format(peakDate, 'HH:mm'),\n        peakKills\n      ),\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Get color for a heatmap cell based on value intensity\n   */\n  private getHeatmapColor(value: number, maxValue: number): string {\n    if (value === 0) return HeatmapChartConfig.colorGradient[0]; // No activity\n\n    const normalizedValue = value / maxValue; // 0 to 1\n    const gradient = HeatmapChartConfig.colorGradient;\n\n    if (normalizedValue < 0.25) {\n      return gradient[1]; // Low activity\n    } else if (normalizedValue < 0.5) {\n      return gradient[2]; // Medium activity\n    } else if (normalizedValue < 0.75) {\n      return gradient[3]; // High activity\n    } else {\n      return gradient[4]; // Very high activity\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/KillsChartGenerator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[574,577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[574,577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (215). Maximum allowed is 50.","line":39,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":320,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":68,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":68,"endColumn":23},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":84,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":84,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3481,3484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3481,3484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":95,"column":36,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":95,"endColumn":38},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":107,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":20},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (88). Maximum allowed is 50.","line":113,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":235,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 11. Maximum allowed is 10.","line":113,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":235,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 14. Maximum allowed is 10.","line":123,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":167,"endColumn":8},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":142,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":142,"endColumn":58},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":152,"column":38,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":152,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":156,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":156,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7056,7059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7056,7059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":186,"column":40,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":186,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":194,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":24},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":195,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":195,"endColumn":57},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":206,"column":86,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":206,"endColumn":88},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":255,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":255,"endColumn":62},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":256,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":256,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":277,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":277,"endColumn":20}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData, ChartDisplayType } from '../../../types/chart';\nimport { logger } from '../../../lib/logger';\nimport { KillsChartConfig } from '../config';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\ninterface Kill {\n  killmailId: bigint;\n  killTime: Date;\n  victim?: { characterId?: bigint };\n  attackers?: Array<{ characterId?: bigint }>;\n  solo: boolean;\n  [key: string]: any; // For other properties\n}\n\ninterface Attacker {\n  characterId?: bigint;\n}\n\n/**\n * Generator for kill-related charts\n */\nexport class KillsChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n\n  /**\n   * Create a new kills chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n  }\n\n  /**\n   * Generate a kills chart based on the provided options\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { startDate, endDate, characterGroups } = options;\n\n    logger.info(`KillsChartGenerator: Processing ${characterGroups.length} character groups`);\n    logger.info(`Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);\n\n    // Get all character IDs from all groups\n    const characterIds = characterGroups.flatMap(group => group.characters.map(c => BigInt(c.eveId)));\n\n    logger.info(`Total characters across all groups: ${characterIds.length}`);\n\n    // Get kills for all characters - use the new method that includes participation as attackers\n    const kills = await this.killRepository.getAllKillsForCharacters(characterIds, startDate, endDate);\n\n    logger.info(`Found ${kills.length} total kills across all characters (including as attackers)`);\n\n    // Debug: Log the first few kills to see their structure\n    if (kills.length > 0) {\n      logger.info('Sample kill data structure:');\n      kills.slice(0, 3).forEach((kill, index) => {\n        logger.info(`Kill ${index + 1}:`);\n        logger.info(`  killmailId: ${kill.killmailId} (type: ${typeof kill.killmailId})`);\n        logger.info(`  victim: ${JSON.stringify(kill.victim)} (type: ${typeof kill.victim})`);\n        logger.info(`  attackers_count: ${kill.attackers?.length ?? 0}`);\n        logger.info(`  all_keys: ${Object.keys(kill).join(', ')}`);\n        if (kill.attackers?.[0]) {\n          logger.info(`  first_attacker: ${JSON.stringify(kill.attackers[0])}`);\n          logger.info(`  first_attacker_keys: ${Object.keys(kill.attackers[0]).join(', ')}`);\n        }\n      });\n    }\n\n    // Debug: Log character IDs we're looking for\n    logger.info(\n      `Character IDs we're looking for: ${characterIds\n        .slice(0, 5)\n        .map(id => id.toString())\n        .join(', ')}`\n    );\n\n    // Log distribution of kills across characters\n    const killsByCharacter = new Map<string, number>();\n    kills.forEach(kill => {\n      // Count kills by attackers (those who participated in the kill)\n      if (kill.attackers) {\n        kill.attackers.forEach((attacker: any) => {\n          if (attacker.characterId != null) {\n            const charId = attacker.characterId.toString();\n            killsByCharacter.set(charId, (killsByCharacter.get(charId) ?? 0) + 1);\n          }\n        });\n      }\n    });\n\n    logger.info(`Kill distribution: ${killsByCharacter.size} characters have kills as main killer`);\n    logger.info(\n      `Characters with most kills as main: ${Array.from(killsByCharacter.entries())\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 5)\n        .map(([charId, count]) => `${charId}:${count}`)\n        .join(', ')}`\n    );\n\n    // Group kills by character group, but now include any kill where a group member is on the killmail\n    const groupData = characterGroups.map(group => {\n      const groupName = this.getGroupDisplayName(group);\n      const groupCharacterIds = group.characters.map(c => BigInt(c.eveId));\n\n      // Use a Set to track unique killmail IDs to avoid double-counting\n      const uniqueGroupKillIds = new Set<string>();\n\n      // A kill belongs to the group if:\n      // 1. The main character on the kill is in the group, OR\n      // 2. Any of the attackers are in the group\n      kills.forEach((kill: Kill) => {\n        const killmailIdStr = kill.killmailId?.toString();\n        if (!killmailIdStr) return;\n\n        // Skip if we've already counted this killmail\n        if (uniqueGroupKillIds.has(killmailIdStr)) {\n          return;\n        }\n\n        // Debug for first group only to avoid spam\n        const isFirstGroup = group === characterGroups[0];\n\n        // Check if any attackers are in group (kills are attributed to attackers)\n        if (kill.attackers && kill.attackers.length > 0) {\n          for (const attacker of kill.attackers) {\n            if (!attacker.characterId) continue;\n\n            const attackerCharId = BigInt(attacker.characterId);\n            if (groupCharacterIds.includes(attackerCharId)) {\n              if (isFirstGroup && kills.indexOf(kill) < 3) {\n                logger.info(`Found attacker match in kill ${killmailIdStr}: attacker=${attacker.characterId}`);\n              }\n              uniqueGroupKillIds.add(killmailIdStr);\n              return;\n            }\n          }\n        }\n\n        // Also check if victim is in group (for loss tracking)\n        if (kill.victim?.characterId != null) {\n          const victimCharId = BigInt(kill.victim.characterId);\n          const isVictimInGroup = groupCharacterIds.includes(victimCharId);\n\n          if (isFirstGroup && kills.indexOf(kill) < 3) {\n            logger.info(\n              `Checking kill ${killmailIdStr}: victim=${kill.victim.characterId}, isInGroup=${isVictimInGroup}`\n            );\n          }\n\n          if (isVictimInGroup) {\n            uniqueGroupKillIds.add(killmailIdStr);\n            return;\n          }\n        }\n      });\n\n      // Now get the actual kill objects for the unique IDs\n      const groupKills = kills.filter((kill: Kill) => {\n        const killmailIdStr = kill.killmailId?.toString();\n        return killmailIdStr && uniqueGroupKillIds.has(killmailIdStr);\n      });\n\n      // Calculate total kills using the unique count\n      const totalKills = uniqueGroupKillIds.size;\n\n      logger.info(`Group ${groupName}: ${totalKills} unique kills, ${group.characters.length} characters`);\n\n      if (groupKills.length > 0) {\n        // List the first few character IDs that have kills in this group\n        const characterIdsWithKills = new Set<string>();\n        groupKills.forEach(kill => {\n          if (kill.attackers) {\n            kill.attackers.forEach((attacker: any) => {\n              if (attacker.characterId != null) {\n                characterIdsWithKills.add(attacker.characterId.toString());\n              }\n            });\n          }\n        });\n        logger.info(\n          `Characters with kills in group ${groupName}: ${Array.from(characterIdsWithKills)\n            .slice(0, 3)\n            .join(', ')}${characterIdsWithKills.size > 3 ? '...' : ''} (${characterIdsWithKills.size} total)`\n        );\n      }\n\n      // Calculate solo kills - either true solo (1 attacker) or group solo (all attackers from same group)\n      let soloKills = 0;\n      for (const kill of groupKills) {\n        // Skip kills with no attackers\n        if (!kill.attackers || kill.attackers.length === 0) continue;\n\n        // Get all player attackers (those with character IDs)\n        const playerAttackers = kill.attackers.filter((a: Attacker) => a.characterId != null);\n        if (playerAttackers.length === 0) continue;\n\n        // Count as solo if either:\n        // 1. It's a true solo kill (only one player attacker)\n        // 2. All player attackers are from this group\n        const isTrueSolo = playerAttackers.length === 1;\n        const allFromGroup = playerAttackers.every((attacker: Attacker) => {\n          if (!attacker.characterId) return false;\n          return groupCharacterIds.includes(BigInt(attacker.characterId));\n        });\n\n        if (isTrueSolo || allFromGroup) {\n          soloKills++;\n          const killmailIdStr = kill.killmailId?.toString() ?? 'unknown';\n          logger.info(\n            `Found ${isTrueSolo ? 'true' : 'group'} solo kill for group ${groupName}: Kill ID ${killmailIdStr} - ${\n              playerAttackers.length\n            } player attackers`\n          );\n        }\n      }\n\n      return {\n        group,\n        kills: groupKills,\n        totalKills,\n        soloKills,\n      };\n    });\n\n    // Log all group data before filtering\n    groupData.forEach(data => {\n      const groupName = this.getGroupDisplayName(data.group);\n      logger.info(`Group ${groupName}: ${data.totalKills} total kills, ${data.soloKills} solo kills`);\n    });\n\n    // Filter out groups with no kills\n    const groupsWithKills = groupData.filter(data => data.totalKills > 0);\n\n    logger.info(`Filtered to ${groupsWithKills.length} groups with kills out of ${groupData.length} total groups`);\n\n    // List the groups that were filtered out\n    const filteredOutGroups = groupData\n      .filter(data => data.totalKills === 0)\n      .map(data => this.getGroupDisplayName(data.group));\n\n    if (filteredOutGroups.length > 0) {\n      logger.info(\n        `Groups with no kills: ${filteredOutGroups.slice(0, 5).join(', ')}${\n          filteredOutGroups.length > 5 ? '...' : ''\n        } (${filteredOutGroups.length} total)`\n      );\n    }\n\n    // If no groups have kills, return empty chart\n    if (groupsWithKills.length === 0) {\n      logger.info('No groups with kills found, returning empty chart');\n      return {\n        labels: [],\n        datasets: [],\n        displayType: 'horizontalBar' as ChartDisplayType,\n        summary: 'No kills found in the specified time period',\n      };\n    }\n\n    // Sort groups by total kills\n    groupsWithKills.sort((a, b) => b.totalKills - a.totalKills);\n\n    logger.info(\n      `Top 5 groups by kill count: ${groupsWithKills\n        .slice(0, 5)\n        .map(g => `${this.getGroupDisplayName(g.group)}: ${g.totalKills}`)\n        .join(', ')}`\n    );\n\n    // Create chart data\n    return {\n      labels: groupsWithKills.map(data => this.getGroupDisplayName(data.group)),\n      datasets: [\n        {\n          label: 'Total Kills',\n          data: groupsWithKills.map(data => data.totalKills),\n          backgroundColor: this.getDatasetColors('kills').primary,\n        },\n        {\n          label: 'Solo Kills',\n          data: groupsWithKills.map(data => data.soloKills),\n          backgroundColor: this.getDatasetColors('kills').secondary,\n        },\n      ],\n      displayType: 'horizontalBar' as ChartDisplayType,\n      options: {\n        indexAxis: 'y',\n        scales: {\n          x: {\n            stacked: true,\n            beginAtZero: true,\n          },\n          y: {\n            stacked: true,\n          },\n        },\n        plugins: {\n          legend: {\n            position: 'top',\n          },\n        },\n      },\n      summary: KillsChartConfig.getDefaultSummary(\n        groupsWithKills.reduce((total, data) => total + data.totalKills, 0),\n        groupsWithKills.reduce((total, data) => total + data.soloKills, 0)\n      ),\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/LossChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (155). Maximum allowed is 50.","line":27,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":212,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100000000.","line":82,"column":84,"nodeType":"Literal","messageId":"noMagic","endLine":82,"endColumn":93},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000_000.","line":122,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":122,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000_000.","line":123,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":123,"endColumn":51},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":124,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":46},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":125,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":125,"endColumn":47},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":126,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":127,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":128,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":128,"endColumn":38},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":129,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":129,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":137,"column":88,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":101}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData, ChartDisplayType } from '../../../types/chart';\nimport { LossChartConfig } from '../config';\nimport { logger } from '../../../lib/logger';\nimport { LossRepository } from '../../../infrastructure/repositories/LossRepository';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\nimport { LossFact } from '../../../domain/killmail/LossFact';\n\n/**\n * Generator for loss charts\n */\nexport class LossChartGenerator extends BaseChartGenerator {\n  private lossRepository: LossRepository;\n\n  /**\n   * Create a new loss chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.lossRepository = this.repoManager.getLossRepository();\n  }\n\n  /**\n   * Generate a loss chart\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { startDate, endDate, characterGroups } = options;\n\n    // Get all character IDs from all groups\n    const characterIds = characterGroups.flatMap(group => group.characters.map(c => BigInt(c.eveId)));\n\n    // Debug: Log character IDs and time range\n    logger.info(`[LossChart] Character IDs: ${characterIds.map(String).join(', ')}`);\n    logger.info(`[LossChart] Time range: ${startDate.toISOString()} to ${endDate.toISOString()}`);\n\n    // Get losses for all characters\n    const losses = await this.lossRepository.getLossesByTimeRange(startDate, endDate);\n\n    // Debug: Log total number of losses returned\n    logger.info(`[LossChart] Total losses returned from repository: ${losses.length}`);\n\n    // Remove duplicate killmail_ids from losses\n    const seenKillmails = new Set<bigint>();\n    const dedupedLosses: LossFact[] = [];\n    let duplicateCount = 0;\n    for (const loss of losses) {\n      if (!seenKillmails.has(loss.killmailId)) {\n        seenKillmails.add(loss.killmailId);\n        dedupedLosses.push(loss);\n      } else {\n        duplicateCount++;\n      }\n    }\n    if (duplicateCount > 0) {\n      logger.warn(`[LossChart] Removed ${duplicateCount} duplicate losses by killmail_id`);\n    } else {\n      logger.info(`[LossChart] No duplicate losses found by killmail_id`);\n    }\n\n    // Group losses by character group\n    const groupData = characterGroups.map(group => {\n      const groupCharacterIds = group.characters.map(c => BigInt(c.eveId));\n      const groupLosses = dedupedLosses.filter((loss: LossFact) => groupCharacterIds.includes(loss.characterId));\n\n      // Debug: Log number of losses for this group\n      logger.info(`[LossChart] Group '${group.name}' (${group.groupId}) has ${groupLosses.length} losses`);\n\n      // Calculate total losses and value\n      const totalLosses = groupLosses.length;\n      const totalValue = groupLosses.reduce((sum: bigint, loss: LossFact) => sum + loss.totalValue, BigInt(0));\n      const highValueLosses = groupLosses.filter(loss => loss.totalValue >= BigInt(100000000)).length;\n\n      return {\n        group,\n        losses: groupLosses,\n        totalLosses,\n        totalValue,\n        highValueLosses,\n      };\n    });\n\n    // Filter out groups with no losses\n    const groupsWithLosses = groupData.filter(data => data.totalLosses > 0);\n\n    // If no groups have losses, return empty chart\n    if (groupsWithLosses.length === 0) {\n      logger.info('No groups with losses found, returning empty chart');\n      return {\n        labels: [],\n        datasets: [],\n        displayType: 'horizontalBar' as ChartDisplayType,\n        summary: 'No losses found in the specified time period',\n      };\n    }\n\n    // Sort groups by total value\n    groupsWithLosses.sort((a, b) => {\n      if (a.totalValue > b.totalValue) return -1;\n      if (a.totalValue < b.totalValue) return 1;\n      return 0;\n    });\n\n    // Calculate totals for summary\n    const totalLosses = groupsWithLosses.reduce((sum, data) => sum + data.totalLosses, 0);\n    const totalHighValueLosses = groupsWithLosses.reduce((sum, data) => sum + data.highValueLosses, 0);\n    const totalIskLost = groupsWithLosses.reduce((sum, data) => sum + data.totalValue, BigInt(0));\n\n    // Format ISK value\n    const formatIsk = (value: bigint): string => {\n      const valueNumber = Number(value);\n      if (valueNumber >= 1_000_000_000_000) {\n        return `${(valueNumber / 1_000_000_000_000).toFixed(2)}T`;\n      } else if (valueNumber >= 1_000_000_000) {\n        return `${(valueNumber / 1_000_000_000).toFixed(2)}B`;\n      } else if (valueNumber >= 1_000_000) {\n        return `${(valueNumber / 1_000_000).toFixed(2)}M`;\n      } else if (valueNumber >= 1_000) {\n        return `${(valueNumber / 1_000).toFixed(2)}K`;\n      } else {\n        return valueNumber.toString();\n      }\n    };\n\n    // Create chart data\n    // Round ISK lost to billions for chart\n    const valueLostBillions = groupsWithLosses.map(data => +(Number(data.totalValue) / 1_000_000_000).toFixed(2));\n\n    return {\n      labels: groupsWithLosses.map(data => this.getGroupDisplayName(data.group)),\n      datasets: [\n        {\n          label: 'Number of Losses',\n          data: groupsWithLosses.map(data => data.totalLosses),\n          backgroundColor: this.getDatasetColors('loss').secondary,\n          yAxisID: 'y',\n          type: 'bar',\n        },\n        {\n          label: 'Total Value Lost (B ISK)',\n          data: valueLostBillions,\n          backgroundColor: `${this.getDatasetColors('loss').primary}33`,\n          borderColor: this.getDatasetColors('loss').primary,\n          borderWidth: 2,\n          tension: 0.3,\n          yAxisID: 'y2',\n          type: 'line',\n        },\n      ],\n      displayType: 'horizontalBar' as ChartDisplayType,\n      options: {\n        indexAxis: 'y',\n        scales: {\n          x: {\n            grid: {\n              color: '#444',\n            },\n            ticks: {\n              color: '#fff',\n            },\n          },\n          y: {\n            type: 'linear',\n            position: 'left',\n            title: {\n              display: true,\n              text: 'Loss Count',\n            },\n            beginAtZero: true,\n            grid: {\n              color: '#444',\n            },\n            ticks: {\n              color: '#fff',\n            },\n          },\n          y2: {\n            type: 'linear',\n            position: 'right',\n            title: {\n              display: true,\n              text: 'ISK Lost (Billion)',\n            },\n            beginAtZero: true,\n            grid: {\n              drawOnChartArea: false,\n              color: '#444',\n            },\n            ticks: {\n              color: '#fff',\n            },\n          },\n        },\n        plugins: {\n          legend: {\n            position: 'top',\n          },\n        },\n      },\n      summary: LossChartConfig.getDefaultSummary(totalLosses, totalHighValueLosses, formatIsk(totalIskLost)),\n    };\n  }\n\n  /**\n   * Generate a chart showing daily losses over time\n   * @param start Start date for the chart\n   * @param end End date for the chart\n   */\n  async generateDailyLossesChart(start: string, end: string): Promise<ChartData> {\n    const startDate = new Date(start);\n    const endDate = new Date(end);\n\n    // Get losses for the time range\n    const losses = await this.lossRepository.getLossesByTimeRange(startDate, endDate);\n\n    // Group losses by day\n    const groupedLosses = losses.reduce(\n      (acc, loss) => {\n        const date = loss.killTime.toISOString().split('T')[0];\n        if (!acc[date]) {\n          acc[date] = [];\n        }\n        acc[date].push(loss);\n        return acc;\n      },\n      {} as Record<string, LossFact[]>\n    );\n\n    // Calculate daily totals\n    const data = Object.entries(groupedLosses).map(([date, dayLosses]) => ({\n      date,\n      value: dayLosses.reduce((sum, loss) => sum + Number(loss.totalValue), 0),\n      count: dayLosses.length,\n    }));\n\n    // Sort by date\n    data.sort((a, b) => a.date.localeCompare(b.date));\n\n    return {\n      title: 'Daily Losses',\n      labels: data.map(d => d.date),\n      datasets: [\n        {\n          label: 'Total Value Lost (ISK)',\n          data: data.map(d => d.value),\n          backgroundColor: 'rgba(255, 99, 132, 0.5)',\n          borderColor: 'rgb(255, 99, 132)',\n        },\n        {\n          label: 'Number of Losses',\n          data: data.map(d => d.count),\n          backgroundColor: 'rgba(54, 162, 235, 0.5)',\n          borderColor: 'rgb(54, 162, 235)',\n        },\n      ],\n      displayType: 'line' as ChartDisplayType,\n    };\n  }\n\n  /**\n   * Generate a chart showing losses by ship type\n   * @param start Start date for the chart\n   * @param end End date for the chart\n   */\n  async generateShipTypeLossesChart(start: string, end: string): Promise<ChartData> {\n    const startDate = new Date(start);\n    const endDate = new Date(end);\n\n    // Get losses for the time range\n    const losses = await this.lossRepository.getLossesByTimeRange(startDate, endDate);\n\n    // Group losses by ship type\n    const groupedLosses = losses.reduce(\n      (acc, loss) => {\n        if (!acc[loss.shipTypeId]) {\n          acc[loss.shipTypeId] = [];\n        }\n        acc[loss.shipTypeId].push(loss);\n        return acc;\n      },\n      {} as Record<number, LossFact[]>\n    );\n\n    // Calculate totals by ship type\n    const data = Object.entries(groupedLosses).map(([shipTypeId, shipLosses]) => ({\n      shipTypeId: Number(shipTypeId),\n      value: shipLosses.reduce((sum, loss) => sum + Number(loss.totalValue), 0),\n      count: shipLosses.length,\n    }));\n\n    // Sort by value\n    data.sort((a, b) => b.value - a.value);\n\n    return {\n      title: 'Losses by Ship Type',\n      labels: data.map(d => `Ship Type ${d.shipTypeId}`),\n      datasets: [\n        {\n          label: 'Total Value Lost (ISK)',\n          data: data.map(d => d.value),\n          backgroundColor: 'rgba(255, 99, 132, 0.5)',\n          borderColor: 'rgb(255, 99, 132)',\n        },\n        {\n          label: 'Number of Losses',\n          data: data.map(d => d.count),\n          backgroundColor: 'rgba(54, 162, 235, 0.5)',\n          borderColor: 'rgb(54, 162, 235)',\n        },\n      ],\n      displayType: 'bar' as ChartDisplayType,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/MapChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (79). Maximum allowed is 50.","line":25,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":121,"endColumn":4},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":70,"column":34,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":70,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData, ChartDisplayType } from '../../../types/chart';\nimport { MapActivityRepository } from '../../../infrastructure/repositories/MapActivityRepository';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\nimport { logger } from '../../../lib/logger';\n\n/**\n * Generator for map activity charts\n */\nexport class MapChartGenerator extends BaseChartGenerator {\n  private mapActivityRepository: MapActivityRepository;\n\n  /**\n   * Create a new map activity chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.mapActivityRepository = this.repoManager.getMapActivityRepository();\n  }\n\n  /**\n   * Generate a map activity chart based on the provided options\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    const { startDate, endDate, characterGroups } = options;\n\n    // Get all character IDs from all groups\n    const characterIds = characterGroups.flatMap(group => group.characters.map(c => c.eveId));\n\n    // Get map activity for all characters\n    const activities = await this.mapActivityRepository.getActivityForCharacters(characterIds, startDate, endDate);\n\n    // Group activities by character group\n    const groupData = characterGroups.map(group => {\n      // Filter out characters with invalid eveIds and convert valid ones to BigInt\n      const validCharacters = group.characters.filter(c => {\n        // Debug log the actual character data\n        logger.info(`Character in group ${group.name}: ${JSON.stringify(c)}`);\n\n        if (!c.eveId || c.eveId === '' || c.eveId === 'undefined' || c.eveId === 'null') {\n          logger.warn(`Skipping character with invalid eveId in group ${group.name}: ${JSON.stringify(c)}`);\n          return false;\n        }\n        return true;\n      });\n\n      const groupCharacterIds = validCharacters\n        .map(c => {\n          try {\n            return BigInt(c.eveId);\n          } catch (error) {\n            logger.warn(`Failed to convert character eveId to BigInt: ${c.eveId}`, error);\n            return null;\n          }\n        })\n        .filter((id): id is bigint => id !== null);\n\n      const groupActivities = activities.filter(activity => {\n        if (activity.characterId == null || activity.characterId === undefined) {\n          return false;\n        }\n        return groupCharacterIds.includes(activity.characterId);\n      });\n\n      // Calculate totals for each metric\n      const totalSignatures = groupActivities.reduce((sum, activity) => sum + activity.signatures, 0);\n      const totalConnections = groupActivities.reduce((sum, activity) => sum + activity.connections, 0);\n      const totalPassages = groupActivities.reduce((sum, activity) => sum + activity.passages, 0);\n\n      return {\n        group,\n        activities: groupActivities,\n        totalSignatures,\n        totalConnections,\n        totalPassages,\n      };\n    });\n\n    // Sort groups by total activity (sum of all metrics)\n    groupData.sort(\n      (a, b) =>\n        b.totalSignatures +\n        b.totalConnections +\n        b.totalPassages -\n        (a.totalSignatures + a.totalConnections + a.totalPassages)\n    );\n\n    // Create chart data\n    return {\n      labels: groupData.map(data => this.getGroupDisplayName(data.group)),\n      datasets: [\n        {\n          label: 'Signatures',\n          data: groupData.map(data => data.totalSignatures),\n          backgroundColor: this.getDatasetColors('map').primary,\n        },\n        {\n          label: 'Connections',\n          data: groupData.map(data => data.totalConnections),\n          backgroundColor: this.getDatasetColors('map').secondary,\n        },\n        {\n          label: 'Passages',\n          data: groupData.map(data => data.totalPassages),\n          backgroundColor: this.getColorForIndex(2),\n        },\n      ],\n      displayType: 'horizontalBar' as ChartDisplayType,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/RatioChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateChart' has too many lines (75). Maximum allowed is 50.","line":28,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":114,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateChart' has a complexity of 12. Maximum allowed is 10.","line":28,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":114,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":75,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":71},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":120,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":120,"endColumn":82},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":120,"column":85,"nodeType":"Literal","messageId":"noMagic","endLine":120,"endColumn":87},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":120,"column":90,"nodeType":"Literal","messageId":"noMagic","endLine":120,"endColumn":92},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":120,"column":95,"nodeType":"Literal","messageId":"noMagic","endLine":120,"endColumn":97},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":124,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":29},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":126,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { logger } from '../../../lib/logger';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { LossRepository } from '../../../infrastructure/repositories/LossRepository';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\n/**\n * Generator for kill-death ratio charts\n */\nexport class RatioChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n  private lossRepository: LossRepository;\n\n  /**\n   * Create a new ratio chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n    this.lossRepository = this.repoManager.getLossRepository();\n  }\n\n  /**\n   * Generate a kill-death ratio chart\n   */\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n      mainCharacterId?: string;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    logger.info('Generating kill-death ratio chart');\n\n    const { startDate, endDate, characterGroups } = options;\n\n    // Prepare data arrays\n    const filteredLabels: string[] = [];\n    const kdRatios: number[] = [];\n    const efficiencies: number[] = [];\n\n    for (const group of characterGroups) {\n      const characterIds = group.characters.map(char => BigInt(char.eveId));\n      if (characterIds.length === 0) continue;\n      // Compute stats manually\n      const kills = await this.killRepository.getKillsForCharacters(characterIds, startDate, endDate);\n      const lossesSummary = await this.lossRepository.getLossesSummaryByCharacters(characterIds, startDate, endDate);\n      const totalKills = kills.length;\n      const totalLosses = lossesSummary.totalLosses;\n      // Only include groups with at least one kill or death\n      if (totalKills > 0 || totalLosses > 0) {\n        // Use main character name if available\n        let label = group.name;\n        if (group.mainCharacterId) {\n          const mainChar = group.characters.find(c => c.eveId === group.mainCharacterId);\n          if (mainChar) label = mainChar.name;\n        } else if (group.characters.length > 0) {\n          label = group.characters[0].name;\n        }\n        filteredLabels.push(label);\n        let kdRatio = 0;\n        if (totalLosses > 0) {\n          kdRatio = totalKills / totalLosses;\n        } else if (totalKills > 0) {\n          kdRatio = totalKills;\n        }\n        let efficiency = 0;\n        if (totalKills + totalLosses > 0) {\n          efficiency = (totalKills / (totalKills + totalLosses)) * 100;\n        }\n        kdRatios.push(kdRatio);\n        efficiencies.push(efficiency);\n      }\n    }\n\n    // Generate summary text\n    const timeRangeText = this.getTimeRangeText(startDate, endDate);\n    let summary = `Kill-Death ratios for tracked characters (${timeRangeText})`;\n\n    // Add top performer if there's data\n    if (Math.max(...kdRatios) > 0) {\n      const bestGroupIndex = kdRatios.indexOf(Math.max(...kdRatios));\n      summary += `\\nBest performer: ${\n        filteredLabels[bestGroupIndex]\n      } with K/D ratio of ${kdRatios[bestGroupIndex].toFixed(2)}`;\n    }\n\n    return {\n      labels: filteredLabels,\n      datasets: [\n        {\n          label: 'K/D Ratio',\n          data: kdRatios,\n          backgroundColor: '#3366CC',\n          borderColor: '#3366CC',\n        },\n        {\n          label: 'Efficiency %',\n          data: efficiencies,\n          backgroundColor: '#DC3912',\n          borderColor: '#DC3912',\n        },\n      ],\n      title: `Kill-Death Ratio - ${timeRangeText}`,\n      summary,\n      displayType: 'bar',\n    };\n  }\n\n  /**\n   * Get a formatted string describing the time range\n   */\n  private getTimeRangeText(startDate: Date, endDate: Date): string {\n    const diffDays = Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n\n    if (diffDays <= 1) {\n      return 'Last 24 hours';\n    } else if (diffDays <= 7) {\n      return 'Last 7 days';\n    } else if (diffDays <= 30) {\n      return 'Last 30 days';\n    } else {\n      return `${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/ShipKillChartGenerator.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 15.","line":75,"column":112,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":114},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -20.","line":98,"column":99,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":98,"endColumn":102},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateTimelineChart' has too many lines (77). Maximum allowed is 50.","line":126,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":202,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'generateTimelineChart' has a complexity of 14. Maximum allowed is 10.","line":126,"column":38,"nodeType":"FunctionExpression","messageId":"complex","endLine":202,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6107,6110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6107,6110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":164,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7199,7202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7199,7202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { ShipTypesChartConfig } from '../config';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\nimport axios from 'axios';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\nexport class ShipKillChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n  private shipTypeNameCache: Record<string, string> = {};\n\n  /**\n   * Create a new ship kill chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n  }\n\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    try {\n      const { startDate, endDate, characterGroups, displayType } = options;\n      logger.info(`Generating ship kill chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      logger.debug(`Chart type: ${displayType}, Groups: ${characterGroups.length}`);\n      if (displayType === 'horizontalBar') {\n        return this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n      } else if (displayType === 'verticalBar') {\n        return this.generateVerticalBarChart(characterGroups, startDate, endDate);\n      } else {\n        return this.generateTimelineChart(characterGroups, startDate, endDate);\n      }\n    } catch (error) {\n      logger.error('Error generating ship kill chart:', error);\n      throw error;\n    }\n  }\n\n  private async getShipTypeName(typeId: string): Promise<string> {\n    if (this.shipTypeNameCache[typeId]) return this.shipTypeNameCache[typeId];\n    try {\n      const resp = await axios.get(`https://esi.evetech.net/latest/universe/types/${typeId}/?datasource=tranquility`);\n      const name = resp.data.name ?? typeId;\n      this.shipTypeNameCache[typeId] = name;\n      return name;\n    } catch {\n      return typeId;\n    }\n  }\n\n  private async generateHorizontalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    const characterIds = characterGroups.flatMap(group => group.characters).map(character => BigInt(character.eveId));\n    if (characterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n    const shipTypesData = await this.killRepository.getTopShipTypesDestroyed(characterIds, startDate, endDate, 15);\n    if (shipTypesData.length === 0) {\n      throw new Error('No ship type data found for the specified time period');\n    }\n    const shipTypeNames = await Promise.all(shipTypesData.map(type => this.getShipTypeName(type.shipTypeId)));\n    const filtered = shipTypesData\n      .map((type, i) => ({ ...type, name: shipTypeNames[i] }))\n      .filter(entry => entry.name.toLowerCase() !== 'capsule');\n    if (filtered.length === 0) {\n      throw new Error('No ship type data found for the specified time period (after filtering capsules)');\n    }\n    filtered.sort((a, b) => b.count - a.count);\n    const totalDestroyed = filtered.reduce((sum, shipType) => sum + shipType.count, 0);\n    const chartData: ChartData = {\n      labels: filtered.map(type => type.name),\n      datasets: [\n        {\n          label: 'Ships Destroyed',\n          data: filtered.map(type => type.count),\n          backgroundColor: this.getVisibleColors(\n            filtered.map(type => type.count),\n            ShipTypesChartConfig.colors\n          ),\n          borderColor: ShipTypesChartConfig.colors.map(color => this.adjustColorBrightness(color, -20)),\n        },\n      ],\n      displayType: 'bar',\n      options: {\n        indexAxis: 'y',\n      },\n      title: `${ShipTypesChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      summary: ShipTypesChartConfig.getDefaultSummary(filtered.length, totalDestroyed),\n    };\n    return chartData;\n  }\n\n  private async generateVerticalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    const chartData = await this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n    chartData.options = ShipTypesChartConfig.verticalBarOptions;\n    chartData.displayType = 'bar';\n    return chartData;\n  }\n\n  private async generateTimelineChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    const characterIds = characterGroups.flatMap(group => group.characters).map(character => BigInt(character.eveId));\n    if (characterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n    const shipTypesTimeData = await this.killRepository.getShipTypesOverTime(\n      characterIds,\n      startDate,\n      endDate,\n      'day' // interval should be a string\n    );\n    if (Object.keys(shipTypesTimeData).length === 0) {\n      throw new Error('No ship type time data found for the specified period');\n    }\n    const dates = Object.keys(shipTypesTimeData).sort();\n    const shipTypeTotals = new Map<string, { total: number }>();\n    for (const date of dates) {\n      const dateData = shipTypesTimeData[date];\n      for (const [shipTypeId, data] of Object.entries(dateData)) {\n        const current = shipTypeTotals.get(shipTypeId) ?? {\n          total: 0,\n        };\n        if (data && typeof data === 'object' && 'count' in data) {\n          current.total += (data as any).count;\n        }\n        shipTypeTotals.set(shipTypeId, current);\n      }\n    }\n    const topShipTypes = Array.from(shipTypeTotals.entries())\n      .sort((a, b) => b[1].total - a[1].total)\n      .slice(0, 5)\n      .map(([id]) => id);\n    const shipTypeNames = await Promise.all(topShipTypes.map(typeId => this.getShipTypeName(typeId)));\n    const datasets = topShipTypes.map((shipTypeId, index) => {\n      const data = dates.map(date => {\n        const dateData = shipTypesTimeData[date];\n        return dateData[shipTypeId]?.count ?? 0;\n      });\n      return {\n        label: shipTypeNames[index],\n        data,\n        backgroundColor: ShipTypesChartConfig.colors[index % ShipTypesChartConfig.colors.length],\n        borderColor: ShipTypesChartConfig.colors[index % ShipTypesChartConfig.colors.length],\n      };\n    });\n    let totalDestroyed = 0;\n    for (const date of dates) {\n      const dateData = shipTypesTimeData[date];\n      for (const data of Object.values(dateData)) {\n        if (data && typeof data === 'object' && 'count' in data) {\n          totalDestroyed += (data as any).count;\n        }\n      }\n    }\n    const chartData: ChartData = {\n      labels: dates.map(date => format(new Date(date), 'MMM d')),\n      datasets,\n      displayType: 'line',\n      title: `${ShipTypesChartConfig.title} Over Time - ${format(\n        startDate,\n        'MMM d'\n      )} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: ShipTypesChartConfig.timelineOptions,\n      summary: `Showing top ${\n        topShipTypes.length\n      } ship types destroyed over time (${totalDestroyed.toLocaleString()} total kills)`,\n    };\n    return chartData;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/ShipLossChartGenerator.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 15.","line":75,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":109},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -20.","line":98,"column":99,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":98,"endColumn":102}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { ShipTypesChartConfig } from '../config';\nimport { LossRepository } from '../../../infrastructure/repositories/LossRepository';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\nimport axios from 'axios';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\nexport class ShipLossChartGenerator extends BaseChartGenerator {\n  private lossRepository: LossRepository;\n  private shipTypeNameCache: Record<string, string> = {};\n\n  /**\n   * Create a new ship loss chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.lossRepository = this.repoManager.getLossRepository();\n  }\n\n  async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    try {\n      const { startDate, endDate, characterGroups, displayType } = options;\n      logger.info(`Generating ship loss chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      logger.debug(`Chart type: ${displayType}, Groups: ${characterGroups.length}`);\n      if (displayType === 'horizontalBar') {\n        return this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n      } else if (displayType === 'verticalBar') {\n        return this.generateVerticalBarChart(characterGroups, startDate, endDate);\n      } else {\n        return this.generateTimelineChart(characterGroups, startDate, endDate);\n      }\n    } catch (error) {\n      logger.error('Error generating ship loss chart:', error);\n      throw error;\n    }\n  }\n\n  private async getShipTypeName(typeId: string): Promise<string> {\n    if (this.shipTypeNameCache[typeId]) return this.shipTypeNameCache[typeId];\n    try {\n      const resp = await axios.get(`https://esi.evetech.net/latest/universe/types/${typeId}/?datasource=tranquility`);\n      const name = resp.data.name || typeId;\n      this.shipTypeNameCache[typeId] = name;\n      return name;\n    } catch {\n      return typeId;\n    }\n  }\n\n  private async generateHorizontalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    const characterIds = characterGroups.flatMap(group => group.characters).map(character => BigInt(character.eveId));\n    if (characterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n    const shipTypesData = await this.lossRepository.getTopShipTypesLost(characterIds, startDate, endDate, 15);\n    if (shipTypesData.length === 0) {\n      throw new Error('No ship type data found for the specified time period');\n    }\n    const shipTypeNames = await Promise.all(shipTypesData.map(type => this.getShipTypeName(type.shipTypeId)));\n    const filtered = shipTypesData\n      .map((type, i) => ({ ...type, name: shipTypeNames[i] }))\n      .filter(entry => entry.name.toLowerCase() !== 'capsule');\n    if (filtered.length === 0) {\n      throw new Error('No ship type data found for the specified time period (after filtering capsules)');\n    }\n    filtered.sort((a, b) => b.count - a.count);\n    const totalLost = filtered.reduce((sum, shipType) => sum + shipType.count, 0);\n    const chartData: ChartData = {\n      labels: filtered.map(type => type.name),\n      datasets: [\n        {\n          label: 'Ships Lost',\n          data: filtered.map(type => type.count),\n          backgroundColor: this.getVisibleColors(\n            filtered.map(type => type.count),\n            ShipTypesChartConfig.colors\n          ),\n          borderColor: ShipTypesChartConfig.colors.map(color => this.adjustColorBrightness(color, -20)),\n        },\n      ],\n      displayType: 'bar',\n      options: {\n        indexAxis: 'y',\n      },\n      title: `${ShipTypesChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      summary: ShipTypesChartConfig.getDefaultSummary(filtered.length, totalLost),\n    };\n    return chartData;\n  }\n\n  private async generateVerticalBarChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    const chartData = await this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n    chartData.options = ShipTypesChartConfig.verticalBarOptions;\n    chartData.displayType = 'bar';\n    return chartData;\n  }\n\n  private async generateTimelineChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // For now, just show a bar chart (timeline for losses is less common)\n    return this.generateHorizontalBarChart(characterGroups, startDate, endDate);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/ShipTypesChartGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/TrendChartGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateTimelineChart' has too many lines (80). Maximum allowed is 50.","line":60,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":175,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":71,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":71,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":71,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":45},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":71,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":76,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":76,"endColumn":25},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":158,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":158,"endColumn":81},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":158,"column":84,"nodeType":"Literal","messageId":"noMagic","endLine":158,"endColumn":86},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":158,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":158,"endColumn":91},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":158,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":158,"endColumn":96},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateAreaChart' has too many lines (85). Maximum allowed is 50.","line":180,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":300,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":191,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":191,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":191,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":45},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":191,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":196,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":196,"endColumn":25},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.6.","line":266,"column":116,"nodeType":"Literal","messageId":"noMagic","endLine":266,"endColumn":119},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":280,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":81},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":280,"column":84,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":86},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":280,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":91},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":280,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":96},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateDualAxisChart' has too many lines (75). Maximum allowed is 50.","line":305,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":406,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":328,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":328,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":328,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":328,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":328,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":328,"endColumn":45},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":328,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":328,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":333,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":333,"endColumn":25},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.7.","line":371,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":371,"endColumn":69},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.7.","line":380,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":69},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":389,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":389,"endColumn":81},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":389,"column":84,"nodeType":"Literal","messageId":"noMagic","endLine":389,"endColumn":86},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":389,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":389,"endColumn":91},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":389,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":389,"endColumn":96},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":412,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":412,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.05.","line":436,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":436,"endColumn":21},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -0.05.","line":438,"column":24,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":438,"endColumn":29},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (328). Maximum allowed is 300.","line":442,"column":1,"nodeType":null,"messageId":"exceed","endLine":481,"endColumn":1},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":467,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":467,"endColumn":46},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 3.","line":468,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":468,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":468,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":468,"endColumn":46},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":469,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":469,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":469,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":469,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartGenerator } from '../BaseChartGenerator';\nimport { ChartData } from '../../../types/chart';\nimport { TrendChartConfig } from '../config';\nimport { KillRepository } from '../../../infrastructure/repositories/KillRepository';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\nimport { RepositoryManager } from '../../../infrastructure/repositories/RepositoryManager';\n\n/**\n * Generator for trend charts showing kills over time\n */\nexport class TrendChartGenerator extends BaseChartGenerator {\n  private killRepository: KillRepository;\n\n  /**\n   * Create a new trend chart generator\n   * @param repoManager Repository manager for data access\n   */\n  constructor(repoManager: RepositoryManager) {\n    super(repoManager);\n    this.killRepository = this.repoManager.getKillRepository();\n  }\n\n  /**\n   * Generate a trend chart based on the provided options\n   */\n  override async generateChart(options: {\n    startDate: Date;\n    endDate: Date;\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>;\n    displayType: string;\n  }): Promise<ChartData> {\n    try {\n      const { startDate, endDate, characterGroups, displayType } = options;\n      logger.info(`Generating trend chart from ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      logger.debug(`Chart type: ${displayType}, Groups: ${characterGroups.length}`);\n\n      // Select chart generation function based on display type\n      if (displayType === 'area') {\n        return this.generateAreaChart(characterGroups, startDate, endDate);\n      } else if (displayType === 'dual') {\n        return this.generateDualAxisChart(characterGroups, startDate, endDate);\n      } else {\n        // Default to line chart (timeline)\n        return this.generateTimelineChart(characterGroups, startDate, endDate);\n      }\n    } catch (error) {\n      logger.error('Error generating trend chart:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a timeline chart showing kills over time\n   */\n  private async generateTimelineChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // First, determine the appropriate time grouping based on date range\n    const dateRange = endDate.getTime() - startDate.getTime();\n    const days = dateRange / (1000 * 60 * 60 * 24);\n\n    let groupBy: 'hour' | 'day' | 'week' = 'day';\n    if (days <= 2) {\n      groupBy = 'hour';\n    } else if (days > 30) {\n      groupBy = 'week';\n    }\n\n    // Create a dataset for each character group\n    const datasets = [];\n    const timeLabels = new Set<string>();\n    let overallTotalKills = 0;\n    const allDataPoints: number[] = []; // Used for trend calculation\n\n    // Process each group\n    for (let i = 0; i < characterGroups.length; i++) {\n      const group = characterGroups[i];\n\n      // Get all character IDs for this group\n      const characterIds = group.characters.map(char => BigInt(char.eveId));\n\n      if (characterIds.length === 0) {\n        continue;\n      }\n\n      // Get kill data grouped by time\n      const killData = await this.killRepository.getKillsGroupedByTime(characterIds, startDate, endDate, groupBy);\n\n      // Skip if no data\n      if (killData.length === 0) {\n        continue;\n      }\n\n      // Determine proper display name for the group\n      let displayName = group.name;\n\n      // Try to find the main character or use the first character\n      if (group.characters.length > 0) {\n        const mainCharacter = group.characters.find(char =>\n          group.characters.some(c => c.eveId !== char.eveId && c.name.includes(char.name.split(' ')[0]))\n        );\n\n        if (mainCharacter) {\n          displayName = mainCharacter.name;\n        } else {\n          displayName = group.characters[0].name;\n        }\n      }\n\n      // Extract the data points and collect labels\n      const dataPoints: number[] = [];\n      const timePoints: string[] = [];\n\n      let groupTotalKills = 0;\n\n      for (const point of killData) {\n        const formattedTime = format(point.timestamp, this.getDateFormat(groupBy));\n        timePoints.push(formattedTime);\n        timeLabels.add(formattedTime);\n\n        dataPoints.push(point.kills);\n        groupTotalKills += point.kills;\n        allDataPoints.push(point.kills); // For trend calculation\n      }\n\n      // Update overall statistics\n      overallTotalKills += groupTotalKills;\n\n      // Add dataset for this group\n      datasets.push({\n        label: displayName,\n        data: dataPoints,\n        backgroundColor: TrendChartConfig.colors[i % TrendChartConfig.colors.length],\n        borderColor: TrendChartConfig.colors[i % TrendChartConfig.colors.length],\n        fill: false,\n      });\n    }\n\n    // Sort the time labels chronologically\n    const sortedLabels = Array.from(timeLabels).sort((a, b) => {\n      const dateA = new Date(a);\n      const dateB = new Date(b);\n      return dateA.getTime() - dateB.getTime();\n    });\n\n    // Calculate average kills per day\n    const dayCount = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n    const averageKillsPerDay = overallTotalKills / dayCount;\n\n    // Calculate the trend (increasing, stable, or decreasing)\n    const trend = this.calculateTrend(allDataPoints);\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: sortedLabels,\n      datasets,\n      displayType: 'line',\n      title: `${TrendChartConfig.title} - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: TrendChartConfig.timelineOptions,\n      summary: TrendChartConfig.getDefaultSummary(overallTotalKills, averageKillsPerDay, trend),\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Generate an area chart showing cumulative kills over time\n   */\n  private async generateAreaChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // First, determine the appropriate time grouping based on date range\n    const dateRange = endDate.getTime() - startDate.getTime();\n    const days = dateRange / (1000 * 60 * 60 * 24);\n\n    let groupBy: 'hour' | 'day' | 'week' = 'day';\n    if (days <= 2) {\n      groupBy = 'hour';\n    } else if (days > 30) {\n      groupBy = 'week';\n    }\n\n    // Create a dataset for each character group\n    const datasets = [];\n    const timeLabels = new Set<string>();\n    let overallTotalKills = 0;\n    const allDataPoints: number[] = []; // Used for trend calculation\n\n    // Process each group\n    for (let i = 0; i < characterGroups.length; i++) {\n      const group = characterGroups[i];\n\n      // Get all character IDs for this group\n      const characterIds = group.characters.map(char => BigInt(char.eveId));\n\n      if (characterIds.length === 0) {\n        continue;\n      }\n\n      // Get kill data grouped by time\n      const killData = await this.killRepository.getKillsGroupedByTime(characterIds, startDate, endDate, groupBy);\n\n      // Skip if no data\n      if (killData.length === 0) {\n        continue;\n      }\n\n      // Determine proper display name for the group\n      let displayName = group.name;\n\n      // Try to find the main character or use the first character\n      if (group.characters.length > 0) {\n        const mainCharacter = group.characters.find(char =>\n          group.characters.some(c => c.eveId !== char.eveId && c.name.includes(char.name.split(' ')[0]))\n        );\n\n        if (mainCharacter) {\n          displayName = mainCharacter.name;\n        } else {\n          displayName = group.characters[0].name;\n        }\n      }\n\n      // Extract the data points and collect labels (cumulative sum)\n      const dataPoints: number[] = [];\n      const timePoints: string[] = [];\n\n      let cumulativeKills = 0;\n      let groupTotalKills = 0;\n\n      for (const point of killData) {\n        const formattedTime = format(point.timestamp, this.getDateFormat(groupBy));\n        timePoints.push(formattedTime);\n        timeLabels.add(formattedTime);\n\n        cumulativeKills += point.kills;\n        dataPoints.push(cumulativeKills);\n        groupTotalKills += point.kills;\n        allDataPoints.push(point.kills); // For trend calculation\n      }\n\n      // Update overall statistics\n      overallTotalKills += groupTotalKills;\n\n      // Add dataset for this group with area filling\n      datasets.push({\n        label: displayName,\n        data: dataPoints,\n        backgroundColor: this.adjustColorTransparency(TrendChartConfig.colors[i % TrendChartConfig.colors.length], 0.6),\n        borderColor: TrendChartConfig.colors[i % TrendChartConfig.colors.length],\n        fill: true,\n      });\n    }\n\n    // Sort the time labels chronologically\n    const sortedLabels = Array.from(timeLabels).sort((a, b) => {\n      const dateA = new Date(a);\n      const dateB = new Date(b);\n      return dateA.getTime() - dateB.getTime();\n    });\n\n    // Calculate average kills per day\n    const dayCount = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n    const averageKillsPerDay = overallTotalKills / dayCount;\n\n    // Calculate the trend (increasing, stable, or decreasing)\n    const trend = this.calculateTrend(allDataPoints);\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: sortedLabels,\n      datasets,\n      displayType: 'line', // Still use line type but with fill\n      title: `Cumulative ${TrendChartConfig.title} - ${format(\n        startDate,\n        'MMM d'\n      )} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: TrendChartConfig.areaOptions,\n      summary: TrendChartConfig.getDefaultSummary(overallTotalKills, averageKillsPerDay, trend),\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Generate a dual-axis chart showing kills and value over time\n   */\n  private async generateDualAxisChart(\n    characterGroups: Array<{\n      groupId: string;\n      name: string;\n      characters: Array<{ eveId: string; name: string }>;\n    }>,\n    startDate: Date,\n    endDate: Date\n  ): Promise<ChartData> {\n    // Combine all groups for a total view\n    const allCharacterIds: bigint[] = [];\n\n    // Extract all character IDs from all groups\n    for (const group of characterGroups) {\n      allCharacterIds.push(...group.characters.map(char => BigInt(char.eveId)));\n    }\n\n    if (allCharacterIds.length === 0) {\n      throw new Error('No characters found in the provided groups');\n    }\n\n    // Determine appropriate time grouping\n    const dateRange = endDate.getTime() - startDate.getTime();\n    const days = dateRange / (1000 * 60 * 60 * 24);\n\n    let groupBy: 'hour' | 'day' | 'week' = 'day';\n    if (days <= 2) {\n      groupBy = 'hour';\n    } else if (days > 30) {\n      groupBy = 'week';\n    }\n\n    // Get kill data grouped by time\n    const killData = await this.killRepository.getKillsGroupedByTime(allCharacterIds, startDate, endDate, groupBy);\n\n    if (killData.length === 0) {\n      throw new Error('No kill data found for the specified time period');\n    }\n\n    // Prepare data for the dual-axis chart\n    const killsData: number[] = [];\n    const valueData: number[] = []; // Convert bigint to number for charting\n    const timeLabels: string[] = [];\n\n    let totalKills = 0;\n    const allKillsData: number[] = []; // For trend calculation\n\n    // Process the kill data\n    for (const point of killData) {\n      const formattedTime = format(point.timestamp, this.getDateFormat(groupBy));\n      timeLabels.push(formattedTime);\n\n      killsData.push(point.kills);\n      allKillsData.push(point.kills);\n      totalKills += point.kills;\n\n      // Convert bigint to number, handling potential overflow\n      const valueInISK = Number(point.value) > Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : Number(point.value);\n      valueData.push(valueInISK);\n    }\n\n    // Create datasets for kills (line) and values (bar)\n    const datasets = [\n      {\n        label: 'Kills',\n        data: killsData,\n        backgroundColor: this.adjustColorTransparency('#3366CC', 0.7),\n        borderColor: '#3366CC',\n        fill: false,\n        type: 'line' as 'line',\n        yAxisID: 'y',\n      },\n      {\n        label: 'Total Value (ISK)',\n        data: valueData,\n        backgroundColor: this.adjustColorTransparency('#DC3912', 0.7),\n        borderColor: '#DC3912',\n        fill: false,\n        type: 'bar' as 'bar',\n        yAxisID: 'y1',\n      },\n    ];\n\n    // Calculate average kills per day\n    const dayCount = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n    const averageKillsPerDay = totalKills / dayCount;\n\n    // Calculate the trend (increasing, stable, or decreasing)\n    const trend = this.calculateTrend(allKillsData);\n\n    // Create chart data\n    const chartData: ChartData = {\n      labels: timeLabels,\n      datasets,\n      displayType: 'line', // Use line type for dual-axis chart\n      title: `Kills vs. Value Over Time - ${format(startDate, 'MMM d')} to ${format(endDate, 'MMM d, yyyy')}`,\n      options: TrendChartConfig.dualAxisOptions,\n      summary: `${TrendChartConfig.getDefaultSummary(totalKills, averageKillsPerDay, trend)} with value metrics`,\n    };\n\n    return chartData;\n  }\n\n  /**\n   * Calculate trend direction from a series of data points\n   */\n  private calculateTrend(dataPoints: number[]): 'increasing' | 'stable' | 'decreasing' {\n    if (dataPoints.length < 3) {\n      return 'stable'; // Not enough data to determine trend\n    }\n\n    // Simple linear regression to determine trend\n    const n = dataPoints.length;\n    const xValues = Array.from({ length: n }, (_, i) => i);\n\n    // Calculate means\n    const xMean = xValues.reduce((sum, x) => sum + x, 0) / n;\n    const yMean = dataPoints.reduce((sum, y) => sum + y, 0) / n;\n\n    // Calculate slope\n    let numerator = 0;\n    let denominator = 0;\n\n    for (let i = 0; i < n; i++) {\n      numerator += (xValues[i] - xMean) * (dataPoints[i] - yMean);\n      denominator += Math.pow(xValues[i] - xMean, 2);\n    }\n\n    const slope = denominator !== 0 ? numerator / denominator : 0;\n\n    // Determine trend direction\n    if (slope > 0.05) {\n      return 'increasing';\n    } else if (slope < -0.05) {\n      return 'decreasing';\n    } else {\n      return 'stable';\n    }\n  }\n\n  /**\n   * Get a date format string based on the grouping level\n   */\n  protected override getDateFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    switch (groupBy) {\n      case 'hour':\n        return 'MMM d, HH:mm';\n      case 'day':\n        return 'MMM d';\n      case 'week':\n        return \"'Week' W, MMM yyyy\";\n      default:\n        return 'MMM d';\n    }\n  }\n\n  /**\n   * Adjust color transparency (for area charts)\n   */\n  private adjustColorTransparency(color: string, alpha: number): string {\n    if (color.startsWith('#')) {\n      // Convert hex to rgb\n      const r = parseInt(color.substring(1, 3), 16);\n      const g = parseInt(color.substring(3, 5), 16);\n      const b = parseInt(color.substring(5, 7), 16);\n      return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n    } else if (color.startsWith('rgb(')) {\n      // Convert rgb to rgba\n      return color.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);\n    } else if (color.startsWith('rgba(')) {\n      // Replace existing alpha\n      return color.replace(/,\\s*[\\d.]+\\)$/, `, ${alpha})`);\n    }\n    return color;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/generators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/implementations/KillsChartService.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateKillsChart' has too many lines (60). Maximum allowed is 50.","line":17,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":93,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2248,2251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2248,2251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2638,2641],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2638,2641],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateGroupedKillsChart' has too many lines (67). Maximum allowed is 50.","line":95,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":173,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4980,4983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4980,4983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5244,5247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5244,5247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7264,7267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7264,7267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7320,7323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7320,7323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":223,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":223,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":251,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8346,8349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8346,8349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8389,8392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8389,8392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8991,8994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8991,8994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9089,9092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9089,9092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9940,9943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9940,9943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10187,10190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10187,10190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":323,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":323,"endColumn":49},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (343). Maximum allowed is 300.","line":363,"column":1,"nodeType":null,"messageId":"exceed","endLine":413,"endColumn":1},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":366,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":377,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":377,"endColumn":74},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":377,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":377,"endColumn":78},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":404,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":404,"endColumn":37},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":404,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":404,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":404,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":404,"endColumn":47},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":405,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":405,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":407,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":407,"endColumn":24},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":408,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":408,"endColumn":22},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":409,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":409,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartService } from '../BaseChartService';\nimport { IKillsChartService } from '../interfaces/IKillsChartService';\nimport { ChartData, ChartDisplayType, ChartMetric } from '../../../types/chart';\nimport { Character } from '../../../domain/character/Character';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\n\ninterface KillData {\n  killTime: Date;\n  totalValue: bigint;\n  points: number;\n  attackerCount: number;\n  characters: Array<{ characterId: bigint }>;\n}\n\nexport class KillsChartService extends BaseChartService implements IKillsChartService {\n  async generateKillsChart(\n    characterIds: string[],\n    startDate: Date,\n    groupBy: string,\n    displayMetric: ChartMetric,\n    limit: number\n  ): Promise<ChartData> {\n    const characterIdsBigInt = characterIds.map(id => BigInt(id));\n\n    logger.info(`Generating kills chart for ${characterIds.length} characters from ${startDate.toISOString()}`);\n    logger.info(`Character IDs: ${characterIds.join(', ')}`);\n\n    try {\n      // Find all related characters via character groups\n      const allCharactersNested = await Promise.all(\n        characterIds.map(async (id: string) => {\n          const character = await this.characterRepository.getCharacter(BigInt(id));\n          if (character?.characterGroupId) {\n            return this.characterRepository.getCharactersByGroup(character.characterGroupId);\n          }\n          return character ? [character] : [];\n        })\n      );\n      const allCharacters = allCharactersNested.flat();\n      const allCharacterIds = allCharacters.map((c: Character) => c.eveId);\n\n      logger.info(`Including all characters in same groups: ${allCharacters.length} characters total`);\n\n      // Get kills for characters\n      logger.info('Querying killFact table with expanded character list...');\n      const killsQuery = await this.killRepository.getKillsForCharacters(\n        allCharacterIds.map(id => BigInt(id)),\n        startDate,\n        new Date()\n      );\n\n      logger.info(`Found ${killsQuery.length} kill records in database`);\n\n      if (killsQuery.length === 0) {\n        return this.createEmptyKillsChart(characterIdsBigInt, groupBy, limit);\n      }\n\n      const kills = killsQuery.map((kill: any) => {\n        logger.debug(`Processing kill: ID ${kill.killmail_id}, time ${kill.kill_time}, character ${kill.character_id}`);\n\n        return {\n          killTime: new Date(kill.kill_time),\n          totalValue: BigInt(kill.total_value),\n          points: kill.points,\n          attackerCount: kill.attackers?.length ?? 0,\n          characters:\n            kill.characters?.map((char: any) => ({\n              characterId: BigInt(char.character_id),\n            })) ?? [],\n        };\n      });\n\n      // Group data by time periods and character\n      const groupedData = this.groupKillsByTimeAndCharacter(kills, groupBy, allCharacters);\n\n      // Create chart datasets\n      const datasets = await this.createKillsDatasets(groupedData, characterIdsBigInt, displayMetric, limit);\n\n      // Generate time labels\n      const labels = this.generateTimeLabels(startDate, new Date(), groupBy);\n\n      return {\n        labels,\n        datasets,\n        title: this.generateChartTitle('kills', displayMetric, this.periodFromDates(startDate)),\n        displayType: 'line' as ChartDisplayType,\n      };\n    } catch (error) {\n      logger.error('Error generating kills chart:', error);\n      throw error;\n    }\n  }\n\n  async generateGroupedKillsChart(config: {\n    characterGroups: string[];\n    period: string;\n    groupBy: string;\n    displayType: ChartDisplayType;\n    displayMetric: ChartMetric;\n    limit: number;\n  }): Promise<ChartData> {\n    const startDate = this.calculateStartDate(config.period);\n\n    logger.info(\n      `Generating grouped kills chart for ${config.characterGroups.length} groups from ${startDate.toISOString()}`\n    );\n\n    try {\n      // Get all characters from the specified groups\n      const characterGroups = await Promise.all(\n        config.characterGroups.map(async groupId => {\n          const group = await this.characterRepository.getCharacterGroup(groupId);\n          return {\n            group,\n            characters: group ? await this.characterRepository.getCharactersByGroup(groupId) : [],\n          };\n        })\n      );\n\n      // Process each group\n      const datasets = await Promise.all(\n        characterGroups.map(async (groupData, index) => {\n          const { group, characters } = groupData;\n\n          if (!group || characters.length === 0) {\n            return {\n              label: group?.name ?? `Group ${index + 1}`,\n              data: [],\n              borderColor: this.getColor(index),\n              fill: false,\n            };\n          }\n\n          const characterIds = characters.map(c => BigInt(c.eveId));\n          const killsQuery = await this.killRepository.getKillsForCharacters(characterIds, startDate, new Date());\n\n          const kills = killsQuery.map((kill: any) => ({\n            killTime: new Date(kill.kill_time),\n            totalValue: BigInt(kill.total_value),\n            points: kill.points,\n            attackerCount: kill.attackers?.length ?? 0,\n            characters:\n              kill.characters?.map((char: any) => ({\n                characterId: BigInt(char.character_id),\n              })) ?? [],\n          }));\n\n          const groupedData = this.groupKillsByTime(kills, config.groupBy);\n          const chartData = this.calculateDisplayMetricData(groupedData, config.displayMetric);\n\n          return {\n            label: group.name,\n            data: chartData,\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        })\n      );\n\n      const labels = this.generateTimeLabels(startDate, new Date(), config.groupBy);\n\n      return {\n        labels,\n        datasets,\n        title: this.generateChartTitle('kills', config.displayMetric, config.period),\n        displayType: config.displayType,\n      };\n    } catch (error) {\n      logger.error('Error generating grouped kills chart:', error);\n      throw error;\n    }\n  }\n\n  private async createEmptyKillsChart(characterIds: bigint[], groupBy: string, limit: number): Promise<ChartData> {\n    logger.warn('No kills found for the specified characters and time period');\n\n    const emptyDatasets = await Promise.all(\n      characterIds.slice(0, limit).map(async (characterId, index) => {\n        try {\n          const character = await this.characterRepository.getCharacter(characterId);\n          return {\n            label: character?.name ?? `Character ${characterId}`,\n            data: [],\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        } catch (err) {\n          return {\n            label: `Character ${characterId}`,\n            data: [],\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        }\n      })\n    );\n\n    const labels = this.generateEmptyTimeLabels(groupBy);\n\n    return {\n      labels,\n      datasets: emptyDatasets,\n      title: '',\n      displayType: 'line' as ChartDisplayType,\n    };\n  }\n\n  private groupKillsByTimeAndCharacter(\n    kills: KillData[],\n    groupBy: string,\n    characters: Character[]\n  ): Map<string, Map<string, any>> {\n    const grouped = new Map<string, Map<string, any>>();\n\n    kills.forEach(kill => {\n      const timeKey = this.getTimeKey(kill.killTime, groupBy);\n\n      if (!grouped.has(timeKey)) {\n        grouped.set(timeKey, new Map());\n      }\n\n      const timeGroup = grouped.get(timeKey)!;\n\n      kill.characters.forEach(killChar => {\n        const character = characters.find(c => BigInt(c.eveId) === killChar.characterId);\n        if (character) {\n          const charKey = character.eveId.toString();\n\n          if (!timeGroup.has(charKey)) {\n            timeGroup.set(charKey, {\n              kills: 0,\n              totalValue: BigInt(0),\n              points: 0,\n              attackers: 0,\n            });\n          }\n\n          const charData = timeGroup.get(charKey);\n          charData.kills += 1;\n          charData.totalValue += kill.totalValue;\n          charData.points += kill.points;\n          charData.attackers += kill.attackerCount;\n        }\n      });\n    });\n\n    return grouped;\n  }\n\n  private groupKillsByTime(kills: KillData[], groupBy: string): Map<string, any> {\n    const grouped = new Map<string, any>();\n\n    kills.forEach(kill => {\n      const timeKey = this.getTimeKey(kill.killTime, groupBy);\n\n      if (!grouped.has(timeKey)) {\n        grouped.set(timeKey, {\n          kills: 0,\n          totalValue: BigInt(0),\n          points: 0,\n          attackers: 0,\n        });\n      }\n\n      const timeData = grouped.get(timeKey);\n      timeData.kills += 1;\n      timeData.totalValue += kill.totalValue;\n      timeData.points += kill.points;\n      timeData.attackers += kill.attackerCount;\n    });\n\n    return grouped;\n  }\n\n  private async createKillsDatasets(\n    groupedData: Map<string, Map<string, any>>,\n    characterIds: bigint[],\n    displayMetric: ChartMetric,\n    limit: number\n  ): Promise<any[]> {\n    const limitedCharacterIds = characterIds.slice(0, limit);\n\n    return Promise.all(\n      limitedCharacterIds.map(async (characterId, index) => {\n        const character = await this.characterRepository.getCharacter(characterId);\n        const charKey = characterId.toString();\n\n        const data: number[] = [];\n\n        for (const [, timeGroup] of groupedData) {\n          const charData = timeGroup.get(charKey);\n          if (charData) {\n            data.push(this.getMetricValue(charData, displayMetric));\n          } else {\n            data.push(0);\n          }\n        }\n\n        return {\n          label: character?.name ?? `Character ${characterId}`,\n          data,\n          borderColor: this.getColor(index),\n          fill: false,\n        };\n      })\n    );\n  }\n\n  private calculateDisplayMetricData(groupedData: Map<string, any>, displayMetric: ChartMetric): number[] {\n    const data: number[] = [];\n\n    for (const [, timeData] of groupedData) {\n      data.push(this.getMetricValue(timeData, displayMetric));\n    }\n\n    return data;\n  }\n\n  private getMetricValue(data: any, displayMetric: ChartMetric): number {\n    switch (displayMetric) {\n      case 'value':\n        return Number(data.totalValue) / 1000000; // Convert to millions\n      case 'kills':\n        return data.kills;\n      case 'points':\n        return data.points;\n      case 'attackers':\n        return data.attackers;\n      default:\n        return 0;\n    }\n  }\n\n  private getTimeKey(date: Date, groupBy: string): string {\n    switch (groupBy) {\n      case 'hour':\n        return format(date, 'yyyy-MM-dd HH:00');\n      case 'day':\n        return format(date, 'yyyy-MM-dd');\n      case 'week': {\n        const weekStart = new Date(date);\n        weekStart.setDate(date.getDate() - date.getDay());\n        return format(weekStart, 'yyyy-MM-dd');\n      }\n      default:\n        return format(date, 'yyyy-MM-dd');\n    }\n  }\n\n  private generateTimeLabels(startDate: Date, endDate: Date, groupBy: string): string[] {\n    const labels: string[] = [];\n    const current = new Date(startDate);\n\n    while (current <= endDate) {\n      labels.push(this.formatLabel(current, groupBy));\n\n      switch (groupBy) {\n        case 'hour':\n          current.setHours(current.getHours() + 1);\n          break;\n        case 'day':\n          current.setDate(current.getDate() + 1);\n          break;\n        case 'week':\n          current.setDate(current.getDate() + 7);\n          break;\n      }\n    }\n\n    return labels;\n  }\n\n  private generateEmptyTimeLabels(groupBy: string): string[] {\n    const labels = [];\n    const today = new Date();\n    const daysToGenerate = groupBy === 'hour' ? 1 : groupBy === 'day' ? 7 : 4;\n\n    for (let i = daysToGenerate - 1; i >= 0; i--) {\n      const date = new Date(today);\n      date.setDate(date.getDate() - i);\n      labels.push(this.formatLabel(date, groupBy));\n    }\n\n    return labels;\n  }\n\n  private formatLabel(date: Date, groupBy: string): string {\n    switch (groupBy) {\n      case 'hour':\n        return format(date, 'HH:mm');\n      case 'day':\n        return format(date, 'MMM dd');\n      case 'week':\n        return format(date, 'MMM dd');\n      default:\n        return format(date, 'MMM dd');\n    }\n  }\n\n  private periodFromDates(startDate: Date): string {\n    const now = new Date();\n    const diffMs = now.getTime() - startDate.getTime();\n    const diffHours = diffMs / (1000 * 60 * 60);\n    const diffDays = diffHours / 24;\n\n    if (diffHours <= 24) return '24h';\n    if (diffDays <= 7) return '7d';\n    if (diffDays <= 30) return '30d';\n    return '90d';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/implementations/MainChartService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/implementations/MapActivityChartService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1992,1995],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1992,1995],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateGroupedMapActivityChart' has too many lines (66). Maximum allowed is 50.","line":80,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":157,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4503,4506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4503,4506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6649,6652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6649,6652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6705,6708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6705,6708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":207,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":207,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7538,7541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7538,7541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7581,7584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7581,7584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":251,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8075,8078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8075,8078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8173,8176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8173,8176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9024,9027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9024,9027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9271,9274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9271,9274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":336,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":336,"endColumn":48},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":347,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":347,"endColumn":74},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":347,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":347,"endColumn":78},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (315). Maximum allowed is 300.","line":366,"column":1,"nodeType":null,"messageId":"exceed","endLine":383,"endColumn":1},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":374,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":37},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":374,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":42},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 60.","line":374,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":47},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":375,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":375,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 24.","line":377,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":377,"endColumn":24},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":378,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":378,"endColumn":22},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 30.","line":379,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseChartService } from '../BaseChartService';\nimport { IMapActivityChartService } from '../interfaces/IMapActivityChartService';\nimport { ChartData, ChartDisplayType, ChartMetric } from '../../../types/chart';\nimport { Character } from '../../../domain/character/Character';\nimport { format } from 'date-fns';\nimport { logger } from '../../../lib/logger';\n\ninterface ActivityData {\n  timestamp: Date;\n  signatures: number;\n  characterId: bigint;\n}\n\nexport class MapActivityChartService extends BaseChartService implements IMapActivityChartService {\n  async generateMapActivityChart(\n    characterIds: string[],\n    startDate: Date,\n    groupBy: string,\n    displayMetric: ChartMetric,\n    limit: number\n  ): Promise<ChartData> {\n    const characterIdsBigInt = characterIds.map(id => BigInt(id));\n\n    logger.info(`Generating map activity chart for ${characterIds.length} characters from ${startDate.toISOString()}`);\n\n    try {\n      // Find all related characters via character groups\n      const allCharactersNested = await Promise.all(\n        characterIds.map(async (id: string) => {\n          const character = await this.characterRepository.getCharacter(BigInt(id));\n          if (character?.characterGroupId) {\n            return this.characterRepository.getCharactersByGroup(character.characterGroupId);\n          }\n          return character ? [character] : [];\n        })\n      );\n      const allCharacters = allCharactersNested.flat();\n      const allCharacterIds = allCharacters.map((c: Character) => c.eveId);\n\n      // Get map activity data\n      const activityQuery = await this.mapActivityRepository.getActivityForCharacters(\n        allCharacterIds,\n        startDate,\n        new Date()\n      );\n\n      logger.info(`Found ${activityQuery.length} activity records in database`);\n\n      if (activityQuery.length === 0) {\n        return this.createEmptyActivityChart(characterIdsBigInt, groupBy, limit);\n      }\n\n      const activities = activityQuery.map((activity: any) => ({\n        timestamp: new Date(activity.timestamp),\n        signatures: activity.signatures ?? 0,\n        characterId: BigInt(activity.character_id),\n      }));\n\n      // Group data by time periods and character\n      const groupedData = this.groupActivitiesByTimeAndCharacter(activities, groupBy, allCharacters);\n\n      // Create chart datasets\n      const datasets = await this.createActivityDatasets(groupedData, characterIdsBigInt, displayMetric, limit);\n\n      // Generate time labels\n      const labels = this.generateTimeLabels(startDate, new Date(), groupBy);\n\n      return {\n        labels,\n        datasets,\n        title: this.generateChartTitle('map_activity', displayMetric, this.periodFromDates(startDate)),\n        displayType: 'line' as ChartDisplayType,\n      };\n    } catch (error) {\n      logger.error('Error generating map activity chart:', error);\n      throw error;\n    }\n  }\n\n  async generateGroupedMapActivityChart(config: {\n    characterGroups: string[];\n    period: string;\n    groupBy: string;\n    displayType: ChartDisplayType;\n    displayMetric: ChartMetric;\n    limit: number;\n  }): Promise<ChartData> {\n    const startDate = this.calculateStartDate(config.period);\n\n    logger.info(\n      `Generating grouped map activity chart for ${config.characterGroups.length} groups from ${startDate.toISOString()}`\n    );\n\n    try {\n      // Get all characters from the specified groups\n      const characterGroups = await Promise.all(\n        config.characterGroups.map(async groupId => {\n          const group = await this.characterRepository.getCharacterGroup(groupId);\n          return {\n            group,\n            characters: group ? await this.characterRepository.getCharactersByGroup(groupId) : [],\n          };\n        })\n      );\n\n      // Process each group\n      const datasets = await Promise.all(\n        characterGroups.map(async (groupData, index) => {\n          const { group, characters } = groupData;\n\n          if (!group || characters.length === 0) {\n            return {\n              label: group?.name ?? `Group ${index + 1}`,\n              data: [],\n              borderColor: this.getColor(index),\n              fill: false,\n            };\n          }\n\n          const characterIds = characters.map(c => c.eveId);\n          const activitiesQuery = await this.mapActivityRepository.getActivityForCharacters(\n            characterIds,\n            startDate,\n            new Date()\n          );\n\n          const activities = activitiesQuery.map((activity: any) => ({\n            timestamp: new Date(activity.timestamp),\n            signatures: activity.signatures ?? 0,\n            characterId: BigInt(activity.character_id),\n          }));\n\n          const groupedData = this.groupActivitiesByTime(activities, config.groupBy);\n          const chartData = this.calculateDisplayMetricData(groupedData, config.displayMetric);\n\n          return {\n            label: group.name,\n            data: chartData,\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        })\n      );\n\n      const labels = this.generateTimeLabels(startDate, new Date(), config.groupBy);\n\n      return {\n        labels,\n        datasets,\n        title: this.generateChartTitle('map_activity', config.displayMetric, config.period),\n        displayType: config.displayType,\n      };\n    } catch (error) {\n      logger.error('Error generating grouped map activity chart:', error);\n      throw error;\n    }\n  }\n\n  private async createEmptyActivityChart(characterIds: bigint[], groupBy: string, limit: number): Promise<ChartData> {\n    logger.warn('No map activity found for the specified characters and time period');\n\n    const emptyDatasets = await Promise.all(\n      characterIds.slice(0, limit).map(async (characterId, index) => {\n        try {\n          const character = await this.characterRepository.getCharacter(characterId);\n          return {\n            label: character?.name ?? `Character ${characterId}`,\n            data: [],\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        } catch (err) {\n          return {\n            label: `Character ${characterId}`,\n            data: [],\n            borderColor: this.getColor(index),\n            fill: false,\n          };\n        }\n      })\n    );\n\n    const labels = this.generateEmptyTimeLabels(groupBy);\n\n    return {\n      labels,\n      datasets: emptyDatasets,\n      title: '',\n      displayType: 'line' as ChartDisplayType,\n    };\n  }\n\n  private groupActivitiesByTimeAndCharacter(\n    activities: ActivityData[],\n    groupBy: string,\n    characters: Character[]\n  ): Map<string, Map<string, any>> {\n    const grouped = new Map<string, Map<string, any>>();\n\n    activities.forEach(activity => {\n      const timeKey = this.getTimeKey(activity.timestamp, groupBy);\n\n      if (!grouped.has(timeKey)) {\n        grouped.set(timeKey, new Map());\n      }\n\n      const timeGroup = grouped.get(timeKey)!;\n      const character = characters.find(c => BigInt(c.eveId) === activity.characterId);\n\n      if (character) {\n        const charKey = character.eveId.toString();\n\n        if (!timeGroup.has(charKey)) {\n          timeGroup.set(charKey, {\n            signatures: 0,\n            activities: 0,\n          });\n        }\n\n        const charData = timeGroup.get(charKey);\n        charData.signatures += activity.signatures;\n        charData.activities += 1;\n      }\n    });\n\n    return grouped;\n  }\n\n  private groupActivitiesByTime(activities: ActivityData[], groupBy: string): Map<string, any> {\n    const grouped = new Map<string, any>();\n\n    activities.forEach(activity => {\n      const timeKey = this.getTimeKey(activity.timestamp, groupBy);\n\n      if (!grouped.has(timeKey)) {\n        grouped.set(timeKey, {\n          signatures: 0,\n          activities: 0,\n        });\n      }\n\n      const timeData = grouped.get(timeKey);\n      timeData.signatures += activity.signatures;\n      timeData.activities += 1;\n    });\n\n    return grouped;\n  }\n\n  private async createActivityDatasets(\n    groupedData: Map<string, Map<string, any>>,\n    characterIds: bigint[],\n    displayMetric: ChartMetric,\n    limit: number\n  ): Promise<any[]> {\n    const limitedCharacterIds = characterIds.slice(0, limit);\n\n    return Promise.all(\n      limitedCharacterIds.map(async (characterId, index) => {\n        const character = await this.characterRepository.getCharacter(characterId);\n        const charKey = characterId.toString();\n\n        const data: number[] = [];\n\n        for (const [, timeGroup] of groupedData) {\n          const charData = timeGroup.get(charKey);\n          if (charData) {\n            data.push(this.getMetricValue(charData, displayMetric));\n          } else {\n            data.push(0);\n          }\n        }\n\n        return {\n          label: character?.name ?? `Character ${characterId}`,\n          data,\n          borderColor: this.getColor(index),\n          fill: false,\n        };\n      })\n    );\n  }\n\n  private calculateDisplayMetricData(groupedData: Map<string, any>, displayMetric: ChartMetric): number[] {\n    const data: number[] = [];\n\n    for (const [, timeData] of groupedData) {\n      data.push(this.getMetricValue(timeData, displayMetric));\n    }\n\n    return data;\n  }\n\n  private getMetricValue(data: any, displayMetric: ChartMetric): number {\n    switch (displayMetric) {\n      case 'value': // For map activity, value means signatures\n        return data.signatures;\n      case 'kills': // For map activity, kills means activities\n        return data.activities;\n      default:\n        return data.signatures;\n    }\n  }\n\n  private getTimeKey(date: Date, groupBy: string): string {\n    switch (groupBy) {\n      case 'hour':\n        return format(date, 'yyyy-MM-dd HH:00');\n      case 'day':\n        return format(date, 'yyyy-MM-dd');\n      case 'week': {\n        const weekStart = new Date(date);\n        weekStart.setDate(date.getDate() - date.getDay());\n        return format(weekStart, 'yyyy-MM-dd');\n      }\n      default:\n        return format(date, 'yyyy-MM-dd');\n    }\n  }\n\n  private generateTimeLabels(startDate: Date, endDate: Date, groupBy: string): string[] {\n    const labels: string[] = [];\n    const current = new Date(startDate);\n\n    while (current <= endDate) {\n      labels.push(this.formatLabel(current, groupBy));\n\n      switch (groupBy) {\n        case 'hour':\n          current.setHours(current.getHours() + 1);\n          break;\n        case 'day':\n          current.setDate(current.getDate() + 1);\n          break;\n        case 'week':\n          current.setDate(current.getDate() + 7);\n          break;\n      }\n    }\n\n    return labels;\n  }\n\n  private generateEmptyTimeLabels(groupBy: string): string[] {\n    const labels = [];\n    const today = new Date();\n    const daysToGenerate = groupBy === 'hour' ? 1 : groupBy === 'day' ? 7 : 4;\n\n    for (let i = daysToGenerate - 1; i >= 0; i--) {\n      const date = new Date(today);\n      date.setDate(date.getDate() - i);\n      labels.push(this.formatLabel(date, groupBy));\n    }\n\n    return labels;\n  }\n\n  private formatLabel(date: Date, groupBy: string): string {\n    switch (groupBy) {\n      case 'hour':\n        return format(date, 'HH:mm');\n      case 'day':\n        return format(date, 'MMM dd');\n      case 'week':\n        return format(date, 'MMM dd');\n      default:\n        return format(date, 'MMM dd');\n    }\n  }\n\n  private periodFromDates(startDate: Date): string {\n    const now = new Date();\n    const diffMs = now.getTime() - startDate.getTime();\n    const diffHours = diffMs / (1000 * 60 * 60);\n    const diffDays = diffHours / 24;\n\n    if (diffHours <= 24) return '24h';\n    if (diffDays <= 7) return '7d';\n    if (diffDays <= 30) return '30d';\n    return '90d';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/interfaces/IChartService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/interfaces/IKillsChartService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/interfaces/IMapActivityChartService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/utils/ChartLayoutUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/utils/FormatUtils.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":11,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":11,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":12,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":12,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":13,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":13,"endColumn":34},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":14,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":14,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":15,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":15,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":16,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":16,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000_000.","line":38,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":38,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000_000.","line":39,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":39,"endColumn":39},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":40,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":34},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000_000.","line":41,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":41,"endColumn":35},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":42,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":42,"endColumn":30},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000_000.","line":43,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":43,"endColumn":31},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":44,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1_000.","line":45,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":45,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Utilities for formatting chart values for display\n */\nexport class FormatUtils {\n  /**\n   * Format a numeric value with appropriate suffix (K, M, B)\n   * @param value The numeric value to format\n   * @returns Formatted string with suffix\n   */\n  static formatValue(value: number): string {\n    if (value >= 1_000_000_000) {\n      return `${(value / 1_000_000_000).toFixed(1)}B`;\n    } else if (value >= 1_000_000) {\n      return `${(value / 1_000_000).toFixed(1)}M`;\n    } else if (value >= 1_000) {\n      return `${(value / 1_000).toFixed(1)}K`;\n    } else {\n      return value.toString();\n    }\n  }\n\n  /**\n   * Format a BigInt value with appropriate suffix\n   * @param value The BigInt value to format\n   * @returns Formatted string with suffix\n   */\n  static formatBigIntValue(value: bigint): string {\n    return this.formatValue(Number(value.toString()));\n  }\n\n  /**\n   * Format an ISK (EVE currency) value with appropriate suffix\n   * @param value The ISK amount as BigInt\n   * @returns Formatted string with ISK suffix\n   */\n  static formatIsk(value: bigint): string {\n    const n = Number(value);\n    if (n >= 1_000_000_000_000) {\n      return `${(n / 1_000_000_000_000).toFixed(2)}T`;\n    } else if (n >= 1_000_000_000) {\n      return `${(n / 1_000_000_000).toFixed(2)}B`;\n    } else if (n >= 1_000_000) {\n      return `${(n / 1_000_000).toFixed(2)}M`;\n    } else if (n >= 1_000) {\n      return `${(n / 1_000).toFixed(2)}K`;\n    } else {\n      return n.toString();\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/charts/utils/TimeUtils.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":57,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":57,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { format } from 'date-fns';\n\n/**\n * Utilities for time-related chart operations\n */\nexport class TimeUtils {\n  /**\n   * Get date format string based on group by period\n   * @param groupBy The time grouping\n   * @returns A date-fns format string\n   */\n  static getGroupByFormat(groupBy: 'hour' | 'day' | 'week'): string {\n    switch (groupBy) {\n      case 'hour':\n        return 'HH:mm';\n      case 'week':\n        return 'MMM dd';\n      default:\n        return 'MMM dd';\n    }\n  }\n\n  /**\n   * Format a time range as a string\n   * @param start Start date\n   * @param end End date\n   * @returns Formatted date range string\n   */\n  static formatTimeRange(start: Date, end: Date): string {\n    return `${format(start, 'yyyy-MM-dd')} to ${format(end, 'yyyy-MM-dd')}`;\n  }\n\n  /**\n   * Create time buckets for a date range\n   * @param startDate Start date\n   * @param endDate End date\n   * @param groupBy Time grouping\n   * @returns Array of date objects with formatted labels\n   */\n  static createTimeBuckets(\n    startDate: Date,\n    endDate: Date,\n    groupBy: 'hour' | 'day' | 'week' = 'day'\n  ): Array<{ date: Date; label: string }> {\n    const result: Array<{ date: Date; label: string }> = [];\n    const formatStr = this.getGroupByFormat(groupBy);\n    let current = new Date(startDate);\n\n    // Determine increment based on groupBy\n    const getNextDate = (date: Date): Date => {\n      const next = new Date(date);\n      switch (groupBy) {\n        case 'hour':\n          next.setHours(next.getHours() + 1);\n          break;\n        case 'week':\n          next.setDate(next.getDate() + 7);\n          break;\n        case 'day':\n        default:\n          next.setDate(next.getDate() + 1);\n          break;\n      }\n      return next;\n    };\n\n    // Generate all time buckets in the range\n    while (current <= endDate) {\n      result.push({\n        date: new Date(current),\n        label: format(current, formatStr),\n      });\n      current = getNextDate(current);\n    }\n\n    return result;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ingestion/CharacterSyncService.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Async method 'syncUserCharacters' has a complexity of 11. Maximum allowed is 10.","line":69,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":121,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2680,2683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2680,2683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4059,4062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4059,4062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'createCharacterGroups' has too many lines (84). Maximum allowed is 50.","line":126,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":230,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Async method 'createCharacterGroups' has a complexity of 13. Maximum allowed is 10.","line":126,"column":38,"nodeType":"FunctionExpression","messageId":"complex","endLine":230,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4309,4312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4309,4312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5032,5035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5032,5035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7680,7683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7680,7683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":283,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9568,9571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9568,9571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ESIService } from '../ESIService';\nimport { retryOperation } from '../../utils/retry';\nimport { logger } from '../../lib/logger';\nimport { Character } from '../../domain/character/Character';\nimport { CharacterRepository } from '../../infrastructure/repositories/CharacterRepository';\nimport { MapClient } from '../../infrastructure/http/MapClient';\nimport { PrismaClient } from '@prisma/client';\nimport prisma from '../../infrastructure/persistence/client';\nimport { Configuration } from '../../config';\n\nexport class CharacterSyncService {\n  private readonly characterRepository: CharacterRepository;\n  private readonly esiService: ESIService;\n  private readonly map: MapClient;\n  private readonly maxRetries: number;\n  private readonly retryDelay: number;\n  private readonly prisma: PrismaClient;\n\n  constructor(mapApiUrl: string, mapApiKey: string, maxRetries: number = 3, retryDelay: number = 5000) {\n    this.characterRepository = new CharacterRepository(prisma);\n    this.esiService = new ESIService();\n    this.map = new MapClient(mapApiUrl, mapApiKey);\n    this.maxRetries = maxRetries;\n    this.retryDelay = retryDelay;\n    this.prisma = prisma;\n  }\n\n  /**\n   * Start the character sync service\n   */\n  public async start(): Promise<void> {\n    logger.info('Starting character sync service...');\n\n    const mapName = Configuration.apis.map.name;\n    if (!mapName) {\n      logger.warn('MAP_NAME environment variable not set, skipping character sync');\n      return;\n    }\n\n    try {\n      // Fetch map data once and use it for both operations\n      const mapData = await retryOperation(\n        () => this.map.getUserCharacters(mapName),\n        `Fetching character data for map ${mapName}`,\n        {\n          maxRetries: this.maxRetries,\n          initialRetryDelay: this.retryDelay,\n          timeout: 30000,\n        }\n      );\n\n      if (!mapData?.data || !Array.isArray(mapData.data)) {\n        logger.warn(`No valid character data available for map ${mapName}`);\n        return;\n      }\n\n      const characterSyncResults = await this.syncUserCharacters(mapData);\n      const groupResults = await this.createCharacterGroups(mapData, mapName);\n\n      logger.info(\n        `Character sync service started successfully - Characters: ${characterSyncResults.total} total (${characterSyncResults.synced} synced, ${characterSyncResults.skipped} skipped, ${characterSyncResults.errors} errors), Groups: ${groupResults.total} total (${groupResults.created} created, ${groupResults.updated} updated)`\n      );\n    } catch (error) {\n      logger.error(`Error during character sync: ${error}`);\n      throw error;\n    }\n  }\n\n  public async syncUserCharacters(mapData: any): Promise<{\n    total: number;\n    synced: number;\n    skipped: number;\n    errors: number;\n  }> {\n    try {\n      if (!mapData?.data || !Array.isArray(mapData.data)) {\n        logger.warn(`No valid character data available`);\n        return { total: 0, synced: 0, skipped: 0, errors: 0 };\n      }\n\n      // Extract unique characters from the map data\n      const uniqueCharacters = new Map();\n      for (const user of mapData.data) {\n        for (const character of user.characters) {\n          if (character.eve_id) {\n            uniqueCharacters.set(character.eve_id, character);\n          }\n        }\n      }\n\n      // Track sync statistics\n      let syncedCount = 0;\n      let errorCount = 0;\n      let skippedCount = 0;\n\n      // Sync each character\n      for (const [eveId, characterData] of uniqueCharacters) {\n        try {\n          const result = await this.syncCharacter(eveId.toString(), characterData);\n          if (result === 'synced') {\n            syncedCount++;\n          } else if (result === 'skipped') {\n            skippedCount++;\n          }\n        } catch (error) {\n          errorCount++;\n          logger.error(`Error syncing character ${eveId}: ${error}`);\n        }\n      }\n\n      return {\n        total: uniqueCharacters.size,\n        synced: syncedCount,\n        skipped: skippedCount,\n        errors: errorCount,\n      };\n    } catch (error: any) {\n      logger.error(`Error syncing user characters: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Create character groups based on users from Map API after character sync\n   */\n  private async createCharacterGroups(\n    mapData: any,\n    mapName: string\n  ): Promise<{\n    total: number;\n    created: number;\n    updated: number;\n  }> {\n    try {\n      if (!mapData?.data || !Array.isArray(mapData.data)) {\n        logger.warn(`No valid user data available for map ${mapName}`);\n        return { total: 0, created: 0, updated: 0 };\n      }\n\n      let createdCount = 0;\n      let updatedCount = 0;\n\n      // Process each user group\n      for (let i = 0; i < mapData.data.length; i++) {\n        const user = mapData.data[i];\n        const userCharacters = user.characters ?? [];\n\n        if (userCharacters.length === 0) {\n          continue;\n        }\n\n        // Extract character IDs for this group\n        const characterIds = userCharacters.map((c: any) => BigInt(c.eve_id));\n\n        // Check if we already have a group containing any of these characters\n        const existingGroup = await this.prisma.characterGroup.findFirst({\n          where: {\n            characters: {\n              some: {\n                eveId: { in: characterIds },\n              },\n            },\n          },\n          include: {\n            characters: true,\n          },\n        });\n\n        let groupId: string;\n        let groupName: string;\n\n        if (existingGroup) {\n          // Use existing group\n          groupId = existingGroup.id;\n          groupName = existingGroup.map_name;\n\n          // Check if we need to update the main character\n          // Use the main_character_eve_id from API, or fall back to first character if null\n          const intendedMainCharId = user.main_character_eve_id\n            ? BigInt(user.main_character_eve_id)\n            : BigInt(userCharacters[0].eve_id);\n\n          if (existingGroup.mainCharacterId !== intendedMainCharId) {\n            await this.prisma.characterGroup.update({\n              where: { id: groupId },\n              data: { mainCharacterId: intendedMainCharId },\n            });\n            updatedCount++;\n          }\n        } else {\n          // Create new group - use a stable identifier based on user index and main character\n          const mainCharacterId = user.main_character_eve_id\n            ? BigInt(user.main_character_eve_id)\n            : BigInt(userCharacters[0].eve_id);\n\n          groupName = `user-${i}-${mainCharacterId}`;\n\n          const group = await this.prisma.characterGroup.create({\n            data: {\n              map_name: mapName, // Use the MAP_NAME environment variable\n              mainCharacterId: mainCharacterId,\n            },\n          });\n          groupId = group.id;\n          createdCount++;\n        }\n\n        // Ensure all characters in this user are assigned to this group\n        for (const character of userCharacters) {\n          try {\n            await this.prisma.character.updateMany({\n              where: { eveId: BigInt(character.eve_id) },\n              data: { characterGroupId: groupId },\n            });\n          } catch (error) {\n            logger.warn(`Could not assign character ${character.eve_id} to group ${groupName}: ${error}`);\n          }\n        }\n      }\n\n      return {\n        total: mapData.data.length,\n        created: createdCount,\n        updated: updatedCount,\n      };\n    } catch (error) {\n      logger.error('Error creating character groups from Map API users:', error);\n      throw error;\n    }\n  }\n\n  private async syncCharacter(eveId: string, mapCharacterData: any): Promise<'synced' | 'skipped'> {\n    try {\n      // Check if character already exists\n      const existingCharacter = await this.characterRepository.getCharacter(BigInt(eveId));\n\n      let characterName: string;\n      if (existingCharacter) {\n        // Use existing name for updates\n        characterName = existingCharacter.name;\n      } else {\n        // Get character name from ESI only for new characters\n        const esiData = await retryOperation(\n          () => this.esiService.getCharacter(parseInt(eveId)),\n          `Fetching character name for ${eveId}`,\n          {\n            maxRetries: this.maxRetries,\n            initialRetryDelay: this.retryDelay,\n            timeout: 30000,\n          }\n        );\n\n        if (!esiData) {\n          logger.warn(`No ESI data available for character ${eveId}`);\n          return 'skipped';\n        }\n        characterName = esiData.name;\n      }\n\n      // Create character instance using domain entity with data from both sources\n      const character = new Character({\n        eveId,\n        name: characterName,\n        corporationId: mapCharacterData.corporation_id,\n        corporationTicker: mapCharacterData.corporation_ticker ?? '',\n        allianceId: mapCharacterData.alliance_id,\n        allianceTicker: mapCharacterData.alliance_ticker ?? '',\n        createdAt: existingCharacter?.createdAt ?? new Date(),\n        updatedAt: new Date(),\n      });\n\n      // Save character using repository\n      await this.characterRepository.upsertCharacter({\n        eveId: BigInt(character.eveId),\n        name: character.name,\n        corporationId: character.corporationId,\n        corporationTicker: character.corporationTicker,\n        allianceId: character.allianceId,\n        allianceTicker: character.allianceTicker,\n        characterGroupId: character.characterGroupId,\n      });\n      return 'synced';\n    } catch (error: any) {\n      logger.error(`Error syncing character ${eveId}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async close(): Promise<void> {\n    await this.prisma.$disconnect();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ingestion/MapActivityService.ts","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 7.","line":47,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":47,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2809,2812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2809,2812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3060,3063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3060,3063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3255,3258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3255,3258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3628,3631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3628,3631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3793,3796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3793,3796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5005,5008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5005,5008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MapClient } from '../../infrastructure/http/MapClient';\nimport { CacheRedisAdapter } from '../../cache/CacheRedisAdapter';\nimport { retryOperation } from '../../utils/retry';\nimport { logger } from '../../lib/logger';\nimport { MapActivityResponseSchema } from '../../types/ingestion';\nimport { MapActivityRepository } from '../../infrastructure/repositories/MapActivityRepository';\nimport { MapActivity } from '../../domain/activity/MapActivity';\nimport { Configuration } from '../../config';\n\nexport class MapActivityService {\n  private readonly map: MapClient;\n  private readonly cache: CacheRedisAdapter;\n  private readonly mapActivityRepository: MapActivityRepository;\n  private readonly maxRetries: number;\n  private readonly retryDelay: number;\n\n  constructor(\n    mapApiUrl: string,\n    mapApiKey: string,\n    redisUrl: string = 'redis://localhost:6379',\n    cacheTtl: number = 300,\n    maxRetries: number = 3,\n    retryDelay: number = 5000\n  ) {\n    this.map = new MapClient(mapApiUrl, mapApiKey);\n    this.cache = new CacheRedisAdapter(redisUrl, cacheTtl);\n    this.mapActivityRepository = new MapActivityRepository();\n    this.maxRetries = maxRetries;\n    this.retryDelay = retryDelay;\n  }\n\n  /**\n   * Start the map activity service\n   */\n  public async start(): Promise<void> {\n    logger.info('Starting map activity service...');\n\n    // Get map name from centralized configuration\n    const mapName = Configuration.apis.map.name;\n    if (!mapName) {\n      logger.warn('MAP_NAME environment variable not set, skipping map activity ingestion');\n      return;\n    }\n\n    try {\n      // Fetch map activity data for the entire map (not per character)\n      await this.ingestMapActivity(mapName, 7); // Last 7 days\n      logger.info('Map activity service started successfully');\n    } catch (error) {\n      logger.error(`Error ingesting map activity for map ${mapName}:`, error);\n    }\n  }\n\n  public async ingestMapActivity(slug: string, days = 7): Promise<void> {\n    try {\n      // Get map data with retry\n      const mapData = await retryOperation(\n        async () => {\n          const result = await this.map.getCharacterActivity(slug, days);\n          if (!result) {\n            throw new Error('No data returned from Map API');\n          }\n          return result;\n        },\n        `Fetching map data for ${slug}`,\n        {\n          maxRetries: this.maxRetries,\n          initialRetryDelay: this.retryDelay,\n          timeout: 30000,\n        }\n      );\n\n      if (!mapData?.data || !Array.isArray(mapData.data)) {\n        logger.warn(`No valid map data available for ${slug}`);\n        return;\n      }\n\n      // Cache the map data\n      await this.cache.set(`map:${slug}`, mapData);\n\n      // Process and store the data\n      await this.processMapData(mapData);\n    } catch (error: any) {\n      logger.error(`Error ingesting map activity for ${slug}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async syncRecentMapActivity(slug: string): Promise<void> {\n    try {\n      const cachedData = await this.cache.get<{ data: any[] }>(`map:${slug}`);\n      if (!cachedData) {\n        logger.warn(`No cached map data for ${slug}`);\n        return;\n      }\n\n      await this.processMapData(cachedData);\n    } catch (error: any) {\n      logger.error(`Error syncing recent map activity for ${slug}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async refreshMapActivityData(slug: string, days = 7): Promise<void> {\n    try {\n      // Clear cache\n      await this.cache.delete(`map:${slug}`);\n\n      // Re-ingest data\n      await this.ingestMapActivity(slug, days);\n    } catch (error: any) {\n      logger.error(`Error refreshing map activity data for ${slug}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private async processMapData(mapData: any): Promise<void> {\n    try {\n      // Validate the data structure\n      const validatedData = MapActivityResponseSchema.parse(mapData);\n\n      if (!validatedData.data || !Array.isArray(validatedData.data)) {\n        logger.warn('Invalid map data format');\n        return;\n      }\n\n      // Process each activity record\n      for (const activity of validatedData.data) {\n        const mapActivity = new MapActivity({\n          characterId: BigInt(activity.character.eve_id),\n          timestamp: new Date(activity.timestamp),\n          signatures: activity.signatures || 0,\n          connections: activity.connections || 0,\n          passages: activity.passages || 0,\n          allianceId: activity.character.alliance_id ?? null,\n          corporationId: activity.character.corporation_id ?? null,\n        });\n\n        await this.upsertMapActivity(\n          mapActivity.characterId,\n          mapActivity.timestamp,\n          mapActivity.signatures,\n          mapActivity.connections,\n          mapActivity.passages,\n          mapActivity.allianceId,\n          mapActivity.corporationId\n        );\n      }\n\n      logger.info(`Processed ${validatedData.data.length} map activity records`);\n    } catch (error: any) {\n      logger.error(`Error processing map data: ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async close(): Promise<void> {\n    await this.cache.close();\n  }\n\n  async upsertMapActivity(\n    characterId: bigint,\n    timestamp: Date,\n    signatures: number,\n    connections: number,\n    passages: number,\n    allianceId: number | null,\n    corporationId: number | null\n  ): Promise<void> {\n    await this.mapActivityRepository.upsertMapActivity(\n      characterId,\n      timestamp,\n      signatures,\n      connections,\n      passages,\n      allianceId,\n      corporationId\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ingestion/WebSocketDataMapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4560,4563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4560,4563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4815,4818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4815,4818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WebSocketKillmail, WebSocketVictim, WebSocketAttacker } from '../../types/websocket';\nimport { KillFact } from '@prisma/client';\n\ninterface MappedKillData {\n  killFact: Omit<KillFact, 'killmail_id'> & { killmail_id: bigint };\n  victim: {\n    character_id?: bigint;\n    corporation_id?: bigint;\n    alliance_id?: bigint;\n    ship_type_id: number;\n    damage_taken: number;\n  };\n  attackers: Array<{\n    character_id?: bigint;\n    corporation_id?: bigint;\n    alliance_id?: bigint;\n    damage_done: number;\n    final_blow: boolean;\n    security_status?: number;\n    ship_type_id?: number;\n    weapon_type_id?: number;\n  }>;\n  involvedCharacters: Array<{\n    character_id: bigint;\n    role: 'attacker' | 'victim';\n  }>;\n}\n\nexport class WebSocketDataMapper {\n  /**\n   * Maps a WebSocket killmail to database entities\n   */\n  mapKillmail(killmail: WebSocketKillmail): MappedKillData {\n    // Map the main kill fact\n    const killFact: MappedKillData['killFact'] = {\n      killmail_id: BigInt(killmail.killmail_id),\n      kill_time: new Date(killmail.kill_time),\n      npc: killmail.zkb.npc,\n      solo: killmail.zkb.solo,\n      awox: killmail.zkb.awox,\n      ship_type_id: killmail.victim.ship_type_id,\n      system_id: killmail.system_id,\n      labels: killmail.zkb.labels ?? [],\n      total_value: BigInt(Math.floor(killmail.zkb.total_value)),\n      points: killmail.zkb.points,\n    };\n\n    // Map victim data\n    const victim = this.mapVictim(killmail.victim);\n\n    // Map attackers\n    const attackers = killmail.attackers.map(attacker => this.mapAttacker(attacker));\n\n    // Collect all involved characters\n    const involvedCharacters = this.collectInvolvedCharacters(killmail);\n\n    return {\n      killFact,\n      victim,\n      attackers,\n      involvedCharacters,\n    };\n  }\n\n  private mapVictim(victim: WebSocketVictim): MappedKillData['victim'] {\n    return {\n      character_id: victim.character_id ? BigInt(victim.character_id) : undefined,\n      corporation_id: victim.corporation_id ? BigInt(victim.corporation_id) : undefined,\n      alliance_id: victim.alliance_id ? BigInt(victim.alliance_id) : undefined,\n      ship_type_id: victim.ship_type_id,\n      damage_taken: victim.damage_taken,\n    };\n  }\n\n  private mapAttacker(attacker: WebSocketAttacker): MappedKillData['attackers'][0] {\n    return {\n      character_id: attacker.character_id ? BigInt(attacker.character_id) : undefined,\n      corporation_id: attacker.corporation_id ? BigInt(attacker.corporation_id) : undefined,\n      alliance_id: attacker.alliance_id ? BigInt(attacker.alliance_id) : undefined,\n      damage_done: attacker.damage_done,\n      final_blow: attacker.final_blow,\n      security_status: attacker.security_status,\n      ship_type_id: attacker.ship_type_id,\n      weapon_type_id: attacker.weapon_type_id,\n    };\n  }\n\n  private collectInvolvedCharacters(killmail: WebSocketKillmail): MappedKillData['involvedCharacters'] {\n    const characters: MappedKillData['involvedCharacters'] = [];\n\n    // Add victim if it's a character\n    if (killmail.victim.character_id) {\n      characters.push({\n        character_id: BigInt(killmail.victim.character_id),\n        role: 'victim',\n      });\n    }\n\n    // Add all attackers that are characters\n    for (const attacker of killmail.attackers) {\n      if (attacker.character_id) {\n        characters.push({\n          character_id: BigInt(attacker.character_id),\n          role: 'attacker',\n        });\n      }\n    }\n\n    return characters;\n  }\n\n  /**\n   * Extracts loss data for a specific character from a killmail\n   */\n  extractLossForCharacter(\n    killmail: WebSocketKillmail,\n    characterId: bigint\n  ): {\n    killmail_id: bigint;\n    character_id: bigint;\n    kill_time: Date;\n    ship_type_id: number;\n    system_id: number;\n    total_value: bigint;\n    attacker_count: number;\n    labels: string[];\n  } | null {\n    // Check if this character is the victim\n    if (killmail.victim.character_id && BigInt(killmail.victim.character_id) === characterId) {\n      return {\n        killmail_id: BigInt(killmail.killmail_id),\n        character_id: characterId,\n        kill_time: new Date(killmail.kill_time),\n        ship_type_id: killmail.victim.ship_type_id,\n        system_id: killmail.system_id,\n        total_value: BigInt(Math.floor(killmail.zkb.total_value)),\n        attacker_count: killmail.attackers.length,\n        labels: killmail.zkb.labels ?? [],\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Maps WebSocket position data to database format\n   */\n  mapPosition(position?: WebSocketKillmail['position']): any | null {\n    if (!position) {\n      return null;\n    }\n\n    return {\n      x: position.x,\n      y: position.y,\n      z: position.z,\n    };\n  }\n\n  /**\n   * Maps item data from victim (if needed in the future)\n   */\n  mapItems(victim: WebSocketVictim): any[] | null {\n    if (!victim.items || victim.items.length === 0) {\n      return null;\n    }\n\n    return victim.items.map(item => ({\n      type_id: item.type_id,\n      type_name: item.type_name,\n      singleton: item.singleton,\n      flag: item.flag,\n      quantity_dropped: item.quantity_dropped,\n      quantity_destroyed: item.quantity_destroyed,\n    }));\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/services/ingestion/WebSocketIngestionService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1043,1046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1043,1046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":116,"column":9,"nodeType":"AwaitExpression","messageId":"await","endLine":116,"endColumn":57,"suggestions":[{"messageId":"removeAwait","fix":{"range":[4002,4007],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'joinLobby' has too many lines (57). Maximum allowed is 50.","line":156,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":220,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5642,5645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5642,5645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000000.","line":189,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":189,"endColumn":59},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7092,7095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7092,7095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8480,8483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8480,8483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":242,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":242,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":256,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":256,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10004,10007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10004,10007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10535,10538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10535,10538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":307,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11066,11069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11066,11069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":318,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11383,11386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11383,11386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":327,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":327,"endColumn":41},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (307). Maximum allowed is 300.","line":405,"column":1,"nodeType":null,"messageId":"exceed","endLine":412,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/*\n * WebSocketIngestionService\n * Converted from the browser‑centric `phoenix` client to the Node‑first\n * `phoenix-websocket` implementation.\n *\n * **Key changes**\n * 1. Uses `phoenix-websocket` (async/await API, Node friendly) instead of\n *    the browser Phoenix client.\n * 2. Only a single global WebSocket polyfill is required (`ws`). No more\n *    `location`, `document`, etc.\n * 3. Channels are addressed by topic string – there is no separate\n *    `Channel` object.  We keep a constant `TOPIC` (\"killmails:lobby\") and\n *    use `subscribeToTopic` / `sendMessage` for all interactions.\n * 4. Built‑in reconnect logic in `phoenix-websocket` replaces the custom\n *    retry loop.  We still track connected state so existing metrics work.\n * 5. Event handlers are supplied when subscribing.\n *\n * Library docs: https://inkarnaterpg.github.io/phoenix-websocket/ ([npmjs.com](https://www.npmjs.com/package/phoenix-websocket))\n */\n\n// Expose a Node WebSocket implementation for phoenix‑websocket.\nimport { WebSocket } from 'ws';\n(global as any).WebSocket ??= WebSocket; // Required in a pure‑Node context ([npmjs.com](https://www.npmjs.com/package/phoenix-websocket))\n\nimport { PhoenixWebsocket } from 'phoenix-websocket';\n\nimport { logger } from '../../lib/logger';\nimport { CharacterRepository } from '../../infrastructure/repositories/CharacterRepository';\nimport { KillRepository } from '../../infrastructure/repositories/KillRepository';\nimport { WebSocketKillmail, WebSocketKillmailUpdate } from '../../types/websocket';\nimport { WebSocketDataMapper } from './WebSocketDataMapper';\nimport { PrismaClient } from '@prisma/client';\n\ninterface WebSocketPreloadConfig {\n  enabled: boolean;\n  limitPerSystem: number;\n  sinceHours: number;\n  deliveryBatchSize: number;\n  deliveryIntervalMs: number;\n}\n\ninterface WebSocketConfig {\n  url: string;\n  reconnectIntervalMs?: number; // kept for backwards‑compat, but automatic reconnect is now handled by the lib\n  maxReconnectAttempts?: number;\n  timeout?: number;\n  preload?: WebSocketPreloadConfig;\n}\n\nexport class WebSocketIngestionService {\n  /** Phoenix‑WebSocket client instance */\n  private socket: PhoenixWebsocket | null = null;\n  /** Constant topic we work with */\n  private readonly TOPIC = 'killmails:lobby';\n\n  private characterRepository: CharacterRepository;\n  private killRepository: KillRepository;\n  private dataMapper: WebSocketDataMapper;\n  private config: WebSocketConfig;\n\n  private isRunning = false;\n  private connected = false;\n\n  private subscribedCharacters: Set<number> = new Set();\n  private subscribedSystems: Set<number> = new Set();\n\n  constructor(config: WebSocketConfig, prisma: PrismaClient) {\n    this.config = {\n      reconnectIntervalMs: 5_000,\n      maxReconnectAttempts: 10,\n      timeout: 10_000,\n      ...config,\n    };\n\n    this.characterRepository = new CharacterRepository(prisma);\n    this.killRepository = new KillRepository(prisma);\n    this.dataMapper = new WebSocketDataMapper();\n  }\n\n  /* ------------------------------------------------------------------\n   * Lifecycle\n   * ---------------------------------------------------------------- */\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      logger.warn('WebSocket ingestion service is already running');\n      return;\n    }\n\n    this.isRunning = true;\n    logger.info('Starting WebSocket ingestion service');\n\n    try {\n      await this.connect();\n      await this.subscribeToTrackedCharacters();\n    } catch (error) {\n      logger.error('Failed to start WebSocket ingestion service', {\n        error,\n        url: this.config.url,\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n      this.isRunning = false;\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    logger.info('Stopping WebSocket ingestion service');\n    this.isRunning = false;\n\n    if (this.socket) {\n      try {\n        await this.socket.unsubscribeToTopic(this.TOPIC);\n      } catch (err) {\n        logger.debug('Topic unsubscribe threw (ignoring)', err);\n      }\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.connected = false;\n    this.subscribedCharacters.clear();\n    this.subscribedSystems.clear();\n  }\n\n  /* ------------------------------------------------------------------\n   * Connection & topic join\n   * ---------------------------------------------------------------- */\n\n  private async connect(): Promise<void> {\n    logger.info(`Connecting to Phoenix WebSocket at ${this.config.url}`);\n\n    this.socket = new PhoenixWebsocket(this.config.url, { client_identifier: 'eve-chart-bot' }, this.config.timeout);\n\n    // Track connection status for metrics.\n    this.socket.onConnectedCallback = () => {\n      this.connected = true;\n      logger.info('WebSocket connected');\n    };\n\n    this.socket.onDisconnectedCallback = () => {\n      this.connected = false;\n      logger.warn('WebSocket disconnected – library will retry automatically');\n    };\n\n    // Establish the low‑level connection.\n    await this.socket.connect();\n\n    // Join the lobby topic & attach broadcast handlers.\n    await this.joinLobby();\n  }\n\n  private async joinLobby(): Promise<void> {\n    if (!this.socket) throw new Error('Socket not initialised');\n\n    const preload = this.getPreloadConfig();\n    const params = preload ? { preload } : undefined;\n\n    logger.info('Subscribing to lobby topic', { params });\n\n    await this.socket.subscribeToTopic(\n      this.TOPIC,\n      params,\n      {\n        killmail_update: async (data?: { [key: string]: any }) => {\n          if (!data) return;\n          const payload = data as WebSocketKillmailUpdate;\n          try {\n            logger.info(`Received killmail update for system ${payload.system_id}`, {\n              killmailCount: payload.killmails.length,\n              preload: payload.preload,\n              timestamp: payload.timestamp,\n            });\n\n            // Log each individual killmail\n            payload.killmails.forEach((killmail, index) => {\n              logger.info(`Killmail ${index + 1}/${payload.killmails.length}:`, {\n                killmailId: killmail.killmail_id,\n                systemId: killmail.system_id,\n                killTime: killmail.kill_time,\n                victimName: killmail.victim?.character_name ?? 'Unknown',\n                victimShip: killmail.victim?.ship_name ?? 'Unknown',\n                attackerCount: killmail.attackers?.length ?? 0,\n                finalBlowBy: killmail.attackers?.find(a => a.final_blow)?.character_name ?? 'Unknown',\n                totalValue: killmail.zkb?.total_value\n                  ? `${(killmail.zkb.total_value / 1000000).toFixed(2)}M ISK`\n                  : 'Unknown',\n              });\n            });\n\n            await this.processKillmails(payload.killmails, payload.preload ?? false);\n          } catch (err) {\n            logger.error('Failed to process killmail update', err);\n          }\n        },\n        kill_count_update: (data?: { [key: string]: any }) => {\n          if (!data) return;\n          logger.debug(`Kill count update for system ${data.system_id}: ${data.count} kills`);\n        },\n      },\n      // Reconnect handler – ensure character/system subscriptions are replayed\n      async (reconnectPromise: Promise<void>) => {\n        try {\n          await reconnectPromise;\n          logger.info('Re‑joined lobby after reconnect – refreshing subscriptions');\n          await this.subscribeToTrackedCharacters();\n          if (this.subscribedSystems.size) {\n            await this.subscribeToSystems(Array.from(this.subscribedSystems));\n          }\n        } catch (error) {\n          logger.error('Failed to re‑join lobby', error);\n        }\n      }\n    );\n\n    logger.info('Joined lobby topic successfully');\n  }\n\n  /* ------------------------------------------------------------------\n   * Subscription helpers\n   * ---------------------------------------------------------------- */\n\n  private async subscribeToTrackedCharacters(): Promise<void> {\n    if (!this.socket) throw new Error('Socket not initialized');\n\n    const characters = await this.characterRepository.getAllCharacters();\n    const characterIds = characters.map(c => Number(c.eveId));\n\n    if (characterIds.length === 0) {\n      logger.warn('No tracked characters found');\n      return;\n    }\n\n    const preload = this.getPreloadConfig();\n    const payload: any = { character_ids: characterIds };\n    if (preload) payload.preload = preload;\n\n    logger.info(`Subscribing to ${characterIds.length} characters...`, {\n      sampleIds: characterIds.slice(0, 5),\n      preloadEnabled: !!preload,\n    });\n\n    try {\n      const startTime = Date.now();\n      const response = await this.socket.sendMessage(this.TOPIC, 'subscribe_characters', payload);\n      const duration = Date.now() - startTime;\n\n      characterIds.forEach(id => this.subscribedCharacters.add(id));\n      logger.info(\n        `Successfully subscribed to ${characterIds.length} characters in ${duration}ms${preload ? ' with preload' : ''}`,\n        {\n          response,\n          characterIds: characterIds.slice(0, 10), // Log first 10 for debugging\n          totalCount: characterIds.length,\n          duration,\n        }\n      );\n    } catch (error) {\n      logger.error('Failed to subscribe to characters', {\n        error,\n        characterCount: characterIds.length,\n        errorMessage: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  async updateCharacterSubscriptions(addCharacterIds: number[] = [], removeCharacterIds: number[] = []): Promise<void> {\n    if (!this.socket) {\n      logger.warn('Socket not initialised – cannot update subscriptions');\n      return;\n    }\n\n    const preload = this.getPreloadConfig();\n\n    if (addCharacterIds.length) {\n      logger.info(`Adding subscription for ${addCharacterIds.length} characters...`);\n      const payload: any = { character_ids: addCharacterIds };\n      if (preload) payload.preload = preload;\n      await this.socket\n        .sendMessage(this.TOPIC, 'subscribe_characters', payload)\n        .then(() => {\n          addCharacterIds.forEach(id => this.subscribedCharacters.add(id));\n          logger.info(\n            `Successfully added subscription for ${addCharacterIds.length} characters${preload ? ' with preload' : ''}`,\n            { totalSubscribed: this.subscribedCharacters.size }\n          );\n        })\n        .catch((error: any) => {\n          logger.error('Failed to add character subscriptions', error);\n          throw error;\n        });\n    }\n\n    if (removeCharacterIds.length) {\n      await this.socket\n        .sendMessage(this.TOPIC, 'unsubscribe_characters', {\n          character_ids: removeCharacterIds,\n        })\n        .then(() => {\n          removeCharacterIds.forEach(id => this.subscribedCharacters.delete(id));\n          logger.info(`Removed subscription for ${removeCharacterIds.length} characters`);\n        })\n        .catch((error: any) => {\n          logger.error('Failed to remove character subscriptions', error);\n          throw error;\n        });\n    }\n  }\n\n  async subscribeToSystems(systemIds: number[]): Promise<void> {\n    if (!this.socket || systemIds.length === 0) return;\n\n    const preload = this.getPreloadConfig();\n    const payload: any = { systems: systemIds };\n    if (preload) payload.preload = preload;\n\n    logger.info(`Subscribing to ${systemIds.length} systems...`);\n\n    try {\n      await this.socket.sendMessage(this.TOPIC, 'subscribe_systems', payload);\n      systemIds.forEach(id => this.subscribedSystems.add(id));\n      logger.info(`Successfully subscribed to ${systemIds.length} systems${preload ? ' with preload' : ''}`, {\n        systemIds: systemIds.slice(0, 10), // Log first 10 for debugging\n        totalCount: systemIds.length,\n      });\n    } catch (error) {\n      logger.error('Failed to subscribe to systems', error);\n      throw error;\n    }\n  }\n\n  /* ------------------------------------------------------------------\n   * Killmail processing\n   * ---------------------------------------------------------------- */\n\n  private async processKillmails(killmails: WebSocketKillmail[], isPreload: boolean): Promise<void> {\n    for (const killmail of killmails) {\n      try {\n        const involvedCharacters = this.getInvolvedCharacters(killmail);\n        const trackedCharacters = involvedCharacters.filter(id => this.subscribedCharacters.has(id));\n\n        if (trackedCharacters.length === 0 && !this.subscribedSystems.has(killmail.system_id)) {\n          continue; // Skip if not relevant\n        }\n\n        const killData = this.dataMapper.mapKillmail(killmail);\n        await this.killRepository.ingestKillmail(\n          killData.killFact,\n          killData.victim,\n          killData.attackers,\n          killData.involvedCharacters\n        );\n\n        logger.info(`Ingested killmail ${killmail.killmail_id}`, {\n          system: killmail.system_id,\n          isPreload,\n          trackedCharacters,\n        });\n      } catch (error) {\n        logger.error(`Failed to process killmail ${killmail.killmail_id}`, error);\n      }\n    }\n  }\n\n  private getInvolvedCharacters(killmail: WebSocketKillmail): number[] {\n    const characters: number[] = [];\n\n    if (killmail.victim?.character_id) {\n      characters.push(killmail.victim.character_id);\n    }\n\n    if (killmail.attackers) {\n      for (const attacker of killmail.attackers) {\n        if (attacker.character_id) {\n          characters.push(attacker.character_id);\n        }\n      }\n    }\n\n    return characters;\n  }\n\n  /* ------------------------------------------------------------------\n   * Utility helpers\n   * ---------------------------------------------------------------- */\n\n  private getPreloadConfig() {\n    if (!this.config.preload?.enabled) return undefined;\n\n    return {\n      enabled: true,\n      limit_per_system: this.config.preload.limitPerSystem,\n      since_hours: this.config.preload.sinceHours,\n      delivery_batch_size: this.config.preload.deliveryBatchSize,\n      delivery_interval_ms: this.config.preload.deliveryIntervalMs,\n    };\n  }\n\n  getStatus() {\n    return {\n      isRunning: this.isRunning,\n      isConnected: this.connected,\n      subscribedCharacters: this.subscribedCharacters.size,\n      subscribedSystems: this.subscribedSystems.size,\n    };\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/types/chart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/types/discord.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[692,695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[692,695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Types related to Discord interactions\n */\n\n/**\n * Basic character summary for simplified display\n */\nexport interface CharacterSummary {\n  eveId: string;\n  name: string;\n}\n\n/**\n * Character group summary for discord commands\n */\nexport interface CharacterGroupSummary {\n  groupId: string;\n  name: string;\n  characters: CharacterSummary[];\n}\n\n/**\n * Interface for chart command options\n */\nexport interface ChartCommandOptions {\n  type: string;\n  period: string;\n  group?: string;\n  character?: string;\n  metric?: string;\n  displayType?: string;\n}\n\n/**\n * Response structure for Discord commands\n */\nexport interface CommandResponse {\n  content?: string;\n  imageUrl?: string;\n  embed?: any;\n  error?: string;\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/types/ingestion.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3070,3073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3070,3073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3092,3095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3092,3095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\n\n// API Response Types\nexport const ZkillResponseSchema = z.object({\n  killmail_id: z.number(),\n  zkb: z.object({\n    locationID: z.number().optional(),\n    hash: z.string(),\n    fittedValue: z.number().optional().default(0),\n    droppedValue: z.number().optional().default(0),\n    destroyedValue: z.number().optional().default(0),\n    totalValue: z.number(),\n    points: z.number().optional().default(0),\n    npc: z.boolean().optional().default(false),\n    solo: z.boolean().optional().default(false),\n    awox: z.boolean().optional().default(false),\n    labels: z.array(z.string()).optional().default([]),\n  }),\n});\n\n// Basic Killmail Schema (from zKillboard)\nexport const BasicKillmailSchema = ZkillResponseSchema;\n\n// Complete Killmail Schema (after ESI data is fetched)\nexport const CompleteKillmailSchema = BasicKillmailSchema.extend({\n  killmail_time: z.string().optional(),\n  solar_system_id: z.number().optional(),\n  victim: z\n    .object({\n      character_id: z.number().optional(),\n      corporation_id: z.number().optional(),\n      alliance_id: z.number().optional(),\n      ship_type_id: z.number().optional(),\n      damage_taken: z.number().optional(),\n      position: z\n        .object({\n          x: z.number(),\n          y: z.number(),\n          z: z.number(),\n        })\n        .optional(),\n      items: z\n        .array(\n          z.object({\n            type_id: z.number().optional(),\n            flag: z.number().optional(),\n            quantity_destroyed: z.number().optional(),\n            quantity_dropped: z.number().optional(),\n            singleton: z.number().optional(),\n          })\n        )\n        .optional(),\n    })\n    .optional(),\n  attackers: z\n    .array(\n      z.object({\n        character_id: z.number().optional(),\n        corporation_id: z.number().optional(),\n        alliance_id: z.number().optional(),\n        damage_done: z.number().optional(),\n        final_blow: z.boolean().optional(),\n        security_status: z.number().optional(),\n        ship_type_id: z.number().optional(),\n        weapon_type_id: z.number().optional(),\n      })\n    )\n    .optional(),\n});\n\n// Character Schema\nexport const CharacterSchema = z.object({\n  eve_id: z.string(),\n  name: z.string(),\n  alliance_id: z.number().nullable(),\n  alliance_ticker: z.string().nullable(),\n  corporation_id: z.number(),\n  corporation_ticker: z.string(),\n});\n\n// Map Activity Response Schema\nexport const MapActivityResponseSchema = z.object({\n  data: z.array(\n    z.object({\n      timestamp: z.string(),\n      character: CharacterSchema,\n      signatures: z.number(),\n      connections: z.number(),\n      passages: z.number(),\n    })\n  ),\n});\n\n// User Characters Response Schema\nexport const UserCharactersResponseSchema = z.object({\n  data: z.array(\n    z.object({\n      main_character_eve_id: z.string().nullable(),\n      characters: z.array(CharacterSchema),\n    })\n  ),\n});\n\n// Database Types\nexport interface KillFact {\n  killmailId: bigint;\n  killTime: Date;\n  systemId: number;\n  totalValue: bigint;\n  points: number;\n  position?: any | null;\n  items?: any | null;\n}\n\nexport interface MapActivity {\n  characterId: string;\n  timestamp: Date;\n  signatures: number;\n  connections: number;\n  passages: number;\n  allianceId: number | null;\n  corporationId: number;\n}\n\nexport interface Character {\n  eveId: string;\n  name: string;\n  allianceId: number | null;\n  allianceTicker: string | null;\n  corporationId: number;\n  corporationTicker: string;\n  createdAt: Date;\n  updatedAt: Date;\n  lastBackfillAt?: Date | null;\n  characterGroupId?: string | null;\n}\n\nexport interface CharacterGroup {\n  id: string;\n  slug: string;\n  mainCharacterId: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CharacterWithRelations extends Character {\n  characterGroup?: CharacterGroup | null;\n  mainCharacter?: Character | null;\n  altCharacters?: Character[];\n  groupMainCharacter?: CharacterGroup | null;\n}\n\nexport interface CharacterGroupWithRelations extends CharacterGroup {\n  mainCharacter?: Character | null;\n  characters: Character[];\n}\n\n// Ingestion Config\nexport interface IngestionConfig {\n  zkillApiUrl: string;\n  mapApiUrl?: string;\n  mapApiKey?: string;\n  esiApiUrl?: string;\n  redisUrl?: string;\n  cacheTtl?: number;\n  batchSize?: number;\n  backoffMs?: number;\n  maxRetries?: number;\n}\n\n// Checkpoint Types\nexport interface IngestionCheckpoint {\n  streamName: string;\n  lastSeenId: bigint;\n  lastSeenTime: Date;\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/types/websocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/CharacterGroupUtils.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Static async method 'createCharacterGroupSafely' has too many lines (96). Maximum allowed is 50.","line":17,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":137,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Static async method 'createCharacterGroupSafely' has a complexity of 11. Maximum allowed is 10.","line":17,"column":42,"nodeType":"FunctionExpression","messageId":"complex","endLine":137,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Static async method 'upsertCharacterGroupSafely' has too many lines (94). Maximum allowed is 50.","line":147,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":263,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Static async method 'upsertCharacterGroupSafely' has a complexity of 15. Maximum allowed is 10.","line":147,"column":42,"nodeType":"FunctionExpression","messageId":"complex","endLine":263,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\nimport { logger } from '../lib/logger';\n\n/**\n * Utility class for safely managing character groups\n * to prevent empty groups from being created\n */\nexport class CharacterGroupUtils {\n  /**\n   * Create a character group only if we have characters to associate with it\n   * @param prisma Prisma client instance\n   * @param mapName The group map name\n   * @param characterIds Array of character IDs to associate with the group\n   * @param mainCharacterId Optional main character ID for the group\n   * @returns The created group ID or null if no group was created\n   */\n  static async createCharacterGroupSafely(\n    prisma: PrismaClient,\n    mapName: string,\n    characterIds: string[],\n    mainCharacterId?: string\n  ): Promise<string | null> {\n    try {\n      // Validate inputs\n      if (!mapName) {\n        logger.error('Cannot create group: missing map name');\n        return null;\n      }\n\n      if (!characterIds || characterIds.length === 0) {\n        logger.warn(`Cannot create group '${mapName}': no characters provided`);\n        return null;\n      }\n\n      // Convert character IDs to BigInt for database queries\n      const characterIdsBigInt = characterIds.map(id => BigInt(id));\n\n      // First, check if any of these characters already belong to a group\n      const existingCharacters = await prisma.character.findMany({\n        where: {\n          eveId: {\n            in: characterIdsBigInt,\n          },\n          characterGroupId: {\n            not: null,\n          },\n        },\n        include: {\n          characterGroup: true,\n        },\n      });\n\n      // If some characters already belong to a group, use that group instead of creating a new one\n      if (existingCharacters.length > 0) {\n        // Use the first character's group as the target group for all characters\n        const existingGroup = existingCharacters[0].characterGroup;\n        if (!existingGroup) {\n          logger.warn('Character has null characterGroup');\n          return null;\n        }\n        logger.info(\n          `Found existing group ${existingGroup.id} (${existingGroup.map_name}) for ${existingCharacters.length} characters`\n        );\n\n        // Update all provided characters to use this group\n        await Promise.all(\n          characterIdsBigInt.map(charId =>\n            prisma.character.updateMany({\n              where: { eveId: charId },\n              data: { characterGroupId: existingGroup.id },\n            })\n          )\n        );\n\n        // Update main character if provided\n        if (mainCharacterId) {\n          await prisma.characterGroup.update({\n            where: { id: existingGroup.id },\n            data: { mainCharacterId: BigInt(mainCharacterId) },\n          });\n        }\n\n        return existingGroup.id;\n      }\n\n      // Check if characters exist in the database\n      const charactersInDb = await prisma.character.findMany({\n        where: {\n          eveId: {\n            in: characterIdsBigInt,\n          },\n        },\n      });\n\n      if (charactersInDb.length === 0) {\n        logger.warn(`Cannot create group '${mapName}': no valid characters found`);\n        return null;\n      }\n\n      logger.info(`Creating character group '${mapName}' with ${charactersInDb.length} characters`);\n\n      // Use a transaction to ensure atomicity\n      const result = await prisma.$transaction(async tx => {\n        // Create the group first\n        const group = await tx.characterGroup.create({\n          data: {\n            map_name: mapName,\n            mainCharacterId: mainCharacterId ? BigInt(mainCharacterId) : null,\n          },\n        });\n\n        // Associate characters with the group\n        await Promise.all(\n          charactersInDb.map(char =>\n            tx.character.update({\n              where: { eveId: char.eveId },\n              data: { characterGroupId: group.id },\n            })\n          )\n        );\n\n        return group;\n      });\n\n      logger.info(`Successfully created character group ${result.id} with ${charactersInDb.length} characters`);\n      return result.id;\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        `Failed to create character group '${mapName}'`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * A safer version of the upsert operation that ensures groups always have characters\n   * @param prisma Prisma client instance\n   * @param mapName The group map name\n   * @param characterIds Array of character IDs to associate with the group\n   * @param mainCharacterId Optional main character ID for the group\n   * @returns The created/updated group ID or null if no group was created/updated\n   */\n  static async upsertCharacterGroupSafely(\n    prisma: PrismaClient,\n    mapName: string,\n    characterIds: string[],\n    mainCharacterId?: string\n  ): Promise<string | null> {\n    try {\n      // First, check if any of these characters already belong to a group\n      if (characterIds && characterIds.length > 0) {\n        // Convert character IDs to BigInt for database queries\n        const characterIdsBigInt = characterIds.map(id => BigInt(id));\n\n        const existingCharacters = await prisma.character.findMany({\n          where: {\n            eveId: {\n              in: characterIdsBigInt,\n            },\n            characterGroupId: {\n              not: null,\n            },\n          },\n          include: {\n            characterGroup: true,\n          },\n        });\n\n        // If some characters already belong to a group, use that group instead of creating a new one\n        if (existingCharacters.length > 0) {\n          // Use the first character's group as the target group for all characters\n          const existingGroup = existingCharacters[0].characterGroup;\n          if (!existingGroup) {\n            logger.warn('Character has null characterGroup');\n            return null;\n          }\n          logger.info(\n            `Found existing group ${existingGroup.id} (${existingGroup.map_name}) for ${existingCharacters.length} characters`\n          );\n\n          // Update all provided characters to use this group\n          await Promise.all(\n            characterIdsBigInt.map(charId =>\n              prisma.character\n                .update({\n                  where: { eveId: charId },\n                  data: { characterGroupId: existingGroup.id },\n                })\n                .catch(e => {\n                  logger.warn(`Could not update character ${charId}: ${e.message}`);\n                  return null;\n                })\n            )\n          );\n\n          // Update main character if provided\n          if (mainCharacterId && existingGroup.mainCharacterId?.toString() !== mainCharacterId) {\n            await prisma.characterGroup.update({\n              where: { id: existingGroup.id },\n              data: { mainCharacterId: BigInt(mainCharacterId) },\n            });\n          }\n\n          return existingGroup.id;\n        }\n      }\n\n      // Try to find existing group by map name\n      const existingGroupByMapName = await prisma.characterGroup.findFirst({\n        where: { map_name: mapName },\n        include: { characters: true },\n      });\n\n      if (existingGroupByMapName) {\n        // Group exists but may need character updates\n        if (characterIds && characterIds.length > 0) {\n          // Convert character IDs to BigInt\n          const characterIdsBigInt = characterIds.map(id => BigInt(id));\n\n          // Update characters to belong to this group\n          await Promise.all(\n            characterIdsBigInt.map(charId =>\n              prisma.character\n                .update({\n                  where: { eveId: charId },\n                  data: { characterGroupId: existingGroupByMapName.id },\n                })\n                .catch(e => {\n                  logger.warn(`Could not update character ${charId}: ${e.message}`);\n                  return null;\n                })\n            )\n          );\n        }\n\n        // Update main character if provided\n        if (mainCharacterId && existingGroupByMapName.mainCharacterId?.toString() !== mainCharacterId) {\n          await prisma.characterGroup.update({\n            where: { id: existingGroupByMapName.id },\n            data: { mainCharacterId: BigInt(mainCharacterId) },\n          });\n        }\n\n        return existingGroupByMapName.id;\n      }\n\n      // No existing group found, create new one using safe method\n      return await CharacterGroupUtils.createCharacterGroupSafely(prisma, mapName, characterIds, mainCharacterId);\n    } catch (error) {\n      logger.error(\n        {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n        },\n        `Failed to upsert character group '${mapName}'`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Clean up empty character groups (groups with no associated characters)\n   * @param prisma Prisma client instance\n   * @returns Number of groups deleted\n   */\n  static async cleanupEmptyCharacterGroups(prisma: PrismaClient): Promise<number> {\n    try {\n      // Find all groups that have no characters\n      const emptyGroups = await prisma.characterGroup.findMany({\n        where: {\n          characters: {\n            none: {},\n          },\n        },\n        select: {\n          id: true,\n          map_name: true,\n        },\n      });\n\n      if (emptyGroups.length === 0) {\n        logger.info('No empty character groups found');\n        return 0;\n      }\n\n      logger.info(`Found ${emptyGroups.length} empty character groups to delete`);\n\n      // Delete all empty groups\n      const deletedCount = await prisma.characterGroup.deleteMany({\n        where: {\n          id: {\n            in: emptyGroups.map(group => group.id),\n          },\n        },\n      });\n\n      logger.info(\n        `Deleted ${deletedCount.count} empty character groups: ${emptyGroups\n          .map(g => `${g.map_name} (${g.id})`)\n          .join(', ')}`\n      );\n\n      return deletedCount.count;\n    } catch (error) {\n      logger.error('Failed to cleanup empty character groups:', error);\n      return 0;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/RateLimiterManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/conversion.ts","messages":[{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":9,"column":13,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":9,"endColumn":15},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":21,"column":14,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":21,"endColumn":16}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Common conversion utilities for domain entities\n */\n\n/**\n * Ensures a value is converted to BigInt, handling string, number, and bigint inputs\n */\nexport function ensureBigInt(value?: string | number | bigint | null): bigint | null {\n  if (value == null) return null;\n  if (typeof value === 'bigint') return value;\n  if (typeof value === 'number') return BigInt(value);\n  if (typeof value === 'string') return BigInt(value);\n  throw new Error(`Cannot convert ${typeof value} to BigInt`);\n}\n\n/**\n * Ensures a value is converted to BigInt, with a required non-null result\n */\nexport function ensureRequiredBigInt(value?: string | number | bigint | null): bigint {\n  const result = ensureBigInt(value);\n  if (result == null) {\n    throw new Error('Value cannot be null when BigInt is required');\n  }\n  return result;\n}\n\n/**\n * Converts BigInt to string for serialization\n */\nexport function bigIntToString(value: bigint | null): string | null {\n  return value?.toString() ?? null;\n}\n\n/**\n * Converts Date to ISO string for serialization, handling null values\n */\nexport function dateToISOString(value: Date | string | null): string | null {\n  if (!value) return null;\n  if (value instanceof Date) return value.toISOString();\n  return value;\n}\n\n/**\n * Ensures a value is converted to Date, handling string and Date inputs\n */\nexport function ensureDate(value: Date | string | null): Date | null {\n  if (!value) return null;\n  if (value instanceof Date) return value;\n  return new Date(value);\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/feature-flags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/query-helper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[363,366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[363,366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[947,950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[947,950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4188,4191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4188,4191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5034,5037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5034,5037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 5.","line":185,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":185,"endColumn":22},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 36.","line":189,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":189,"endColumn":61},{"ruleId":"complexity","severity":1,"message":"Function 'parseQueryString' has a complexity of 16. Maximum allowed is 10.","line":198,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":250,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6164,6167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6164,6167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -2.","line":228,"column":44,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":228,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8341,8344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8341,8344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8376,8379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8376,8379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8436,8439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8436,8439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8754,8757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8754,8757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":317,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9386,9389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9386,9389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":341,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10186,10189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10186,10189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10927,10930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10927,10930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Helper functions for building Prisma queries\n */\n\n/**\n * Builds a where filter object for Prisma queries based on a set of filters.\n * Automatically handles date fields by converting them to 'gte' operators.\n *\n * @param filters The filters to apply\n * @returns A where filter object for Prisma\n */\nexport function buildWhereFilter(filters: Record<string, any>) {\n  return Object.entries(filters).reduce(\n    (acc, [key, value]) => {\n      if (value === undefined || value === null) {\n        return acc;\n      }\n\n      // Handle date fields\n      if (key.toLowerCase().includes('date') && value instanceof Date) {\n        acc[key] = { gte: value };\n      }\n      // Handle array values\n      else if (Array.isArray(value)) {\n        if (value.length > 0) {\n          acc[key] = { in: value };\n        }\n      }\n      // Handle simple values\n      else {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n}\n\n/**\n * Builds a pagination object for Prisma queries\n *\n * @param page The page number (1-based)\n * @param pageSize The number of items per page\n * @returns A pagination object with skip and take values\n */\nexport function buildPagination(page: number = 1, pageSize: number = 10) {\n  const skip = (page - 1) * pageSize;\n  return {\n    skip,\n    take: pageSize,\n  };\n}\n\n/**\n * Utility functions for building query strings and handling URL parameters\n */\n\n/**\n * Build a query string from an object of parameters\n * @param params Object containing query parameters\n * @param options Options for query string building\n * @returns Query string (without leading ?)\n */\nexport function buildQueryString(\n  params: Record<string, string | number | boolean | undefined | null>,\n  options: {\n    sort?: boolean;\n    encodeValues?: boolean;\n    skipEmpty?: boolean;\n    arrayFormat?: 'brackets' | 'comma' | 'repeat';\n  } = {}\n): string {\n  const { sort = true, encodeValues = true, skipEmpty = true, arrayFormat = 'repeat' } = options;\n\n  // Filter out empty values if requested\n  const filteredParams = skipEmpty\n    ? Object.entries(params).filter(([, value]) => value !== null && value !== undefined && value !== '')\n    : Object.entries(params).filter(([, value]) => value !== null && value !== undefined);\n\n  // Sort parameters if requested\n  const sortedParams = sort ? filteredParams.sort(([a], [b]) => a.localeCompare(b)) : filteredParams;\n\n  // Build query string\n  return sortedParams\n    .map(([key, value]) => {\n      // Handle arrays\n      if (Array.isArray(value)) {\n        switch (arrayFormat) {\n          case 'brackets':\n            return value\n              .map(v => {\n                const encodedKey = encodeValues ? encodeURIComponent(`${key}[]`) : `${key}[]`;\n                const encodedValue = encodeValues ? encodeURIComponent(String(v)) : String(v);\n                return `${encodedKey}=${encodedValue}`;\n              })\n              .join('&');\n          case 'comma': {\n            const encodedKey = encodeValues ? encodeURIComponent(key) : key;\n            const encodedValue = encodeValues ? encodeURIComponent(value.join(',')) : value.join(',');\n            return `${encodedKey}=${encodedValue}`;\n          }\n          case 'repeat':\n          default:\n            return value\n              .map(v => {\n                const encodedKey = encodeValues ? encodeURIComponent(key) : key;\n                const encodedValue = encodeValues ? encodeURIComponent(String(v)) : String(v);\n                return `${encodedKey}=${encodedValue}`;\n              })\n              .join('&');\n        }\n      }\n\n      const stringValue = String(value);\n      const encodedValue = encodeValues ? encodeURIComponent(stringValue) : stringValue;\n      const encodedKey = encodeValues ? encodeURIComponent(key) : key;\n      return `${encodedKey}=${encodedValue}`;\n    })\n    .join('&');\n}\n\n/**\n * Build a cache key from endpoint and parameters\n * @param prefix Cache key prefix\n * @param endpoint API endpoint\n * @param params Query parameters\n * @param options Cache key building options\n * @returns Cache key string\n */\nexport function buildCacheKey(\n  prefix: string,\n  endpoint: string,\n  params?: Record<string, any>,\n  options: {\n    includeTimestamp?: boolean;\n    ttl?: number;\n    version?: string;\n  } = {}\n): string {\n  const { includeTimestamp = false, version } = options;\n\n  let cacheKey = `${prefix}:${endpoint}`;\n\n  if (version) {\n    cacheKey += `:v${version}`;\n  }\n\n  if (params && Object.keys(params).length > 0) {\n    const queryString = buildQueryString(params, {\n      sort: true,\n      encodeValues: false,\n    });\n    cacheKey += `?${queryString}`;\n  }\n\n  if (includeTimestamp) {\n    cacheKey += `:${Date.now()}`;\n  }\n\n  return cacheKey;\n}\n\n/**\n * Generate cache key with hash for long parameter lists\n * @param prefix Cache key prefix\n * @param endpoint API endpoint\n * @param params Query parameters\n * @returns Cache key string with hash\n */\nexport function buildHashedCacheKey(prefix: string, endpoint: string, params?: Record<string, any>): string {\n  if (!params || Object.keys(params).length === 0) {\n    return `${prefix}:${endpoint}`;\n  }\n\n  const queryString = buildQueryString(params, {\n    sort: true,\n    encodeValues: false,\n  });\n\n  // Simple hash function for cache keys\n  let hash = 0;\n  for (let i = 0; i < queryString.length; i++) {\n    const char = queryString.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  return `${prefix}:${endpoint}:${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Parse a query string into an object\n * @param queryString Query string (with or without leading ?)\n * @param options Parsing options\n * @returns Object containing parsed parameters\n */\nexport function parseQueryString(\n  queryString: string,\n  options: {\n    decodeValues?: boolean;\n    arrayFormat?: 'brackets' | 'comma' | 'repeat';\n    parseNumbers?: boolean;\n    parseBooleans?: boolean;\n  } = {}\n): Record<string, string | string[] | number | boolean> {\n  const { decodeValues = true, arrayFormat = 'repeat', parseNumbers = false, parseBooleans = false } = options;\n\n  const params: Record<string, any> = {};\n\n  // Remove leading ? if present\n  const cleanQuery = queryString.startsWith('?') ? queryString.slice(1) : queryString;\n\n  if (!cleanQuery) {\n    return params;\n  }\n\n  const pairs = cleanQuery.split('&');\n  for (const pair of pairs) {\n    const [key, value] = pair.split('=');\n    if (!key) continue;\n\n    const decodedKey = decodeValues ? decodeURIComponent(key) : key;\n    const decodedValue = value ? (decodeValues ? decodeURIComponent(value) : value) : '';\n\n    // Handle array formats\n    if (arrayFormat === 'brackets' && decodedKey.endsWith('[]')) {\n      const arrayKey = decodedKey.slice(0, -2);\n      if (!params[arrayKey]) {\n        params[arrayKey] = [];\n      }\n      params[arrayKey].push(parseValue(decodedValue, { parseNumbers, parseBooleans }));\n    } else if (arrayFormat === 'comma' && decodedValue.includes(',')) {\n      params[decodedKey] = decodedValue.split(',').map(v => parseValue(v.trim(), { parseNumbers, parseBooleans }));\n    } else if (arrayFormat === 'repeat' && params[decodedKey]) {\n      // Convert to array if we see the same key again\n      if (!Array.isArray(params[decodedKey])) {\n        params[decodedKey] = [params[decodedKey]];\n      }\n      params[decodedKey].push(parseValue(decodedValue, { parseNumbers, parseBooleans }));\n    } else {\n      params[decodedKey] = parseValue(decodedValue, {\n        parseNumbers,\n        parseBooleans,\n      });\n    }\n  }\n\n  return params;\n}\n\n/**\n * Parse a string value to appropriate type\n */\nfunction parseValue(\n  value: string,\n  options: { parseNumbers?: boolean; parseBooleans?: boolean }\n): string | number | boolean {\n  const { parseNumbers = false, parseBooleans = false } = options;\n\n  if (parseBooleans) {\n    if (value.toLowerCase() === 'true') return true;\n    if (value.toLowerCase() === 'false') return false;\n  }\n\n  if (parseNumbers && !isNaN(Number(value)) && value !== '') {\n    return Number(value);\n  }\n\n  return value;\n}\n\n/**\n * Merge multiple parameter objects, with later objects taking precedence\n * @param paramObjects Array of parameter objects to merge\n * @returns Merged parameter object\n */\nexport function mergeParams(...paramObjects: Array<Record<string, any> | undefined>): Record<string, any> {\n  return paramObjects.reduce((merged: Record<string, any>, params) => {\n    if (params) {\n      return { ...merged, ...params };\n    }\n    return merged;\n  }, {});\n}\n\n/**\n * Convert parameters to strings suitable for URL encoding\n * @param params Parameter object\n * @returns Parameter object with string values\n */\nexport function stringifyParams(params: Record<string, any>): Record<string, string> {\n  const stringified: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== null && value !== undefined) {\n      if (Array.isArray(value)) {\n        stringified[key] = value.join(',');\n      } else {\n        stringified[key] = String(value);\n      }\n    }\n  }\n\n  return stringified;\n}\n\n/**\n * Build URL with query parameters\n * @param baseUrl Base URL\n * @param params Query parameters\n * @param options Query string building options\n * @returns Complete URL with query string\n */\nexport function buildUrl(\n  baseUrl: string,\n  params?: Record<string, any>,\n  options?: Parameters<typeof buildQueryString>[1]\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return baseUrl;\n  }\n\n  const queryString = buildQueryString(params, options);\n  const separator = baseUrl.includes('?') ? '&' : '?';\n\n  return `${baseUrl}${separator}${queryString}`;\n}\n\n/**\n * Build URL with path parameters and query parameters\n * @param baseUrl Base URL with path parameter placeholders (e.g., '/api/users/:id')\n * @param pathParams Object containing path parameter values\n * @param queryParams Query parameters\n * @param options Query string building options\n * @returns Complete URL with path and query parameters\n */\nexport function buildUrlWithPath(\n  baseUrl: string,\n  pathParams: Record<string, string | number> = {},\n  queryParams?: Record<string, any>,\n  options?: Parameters<typeof buildQueryString>[1]\n): string {\n  let url = baseUrl;\n\n  // Replace path parameters\n  for (const [key, value] of Object.entries(pathParams)) {\n    url = url.replace(`:${key}`, encodeURIComponent(String(value)));\n  }\n\n  // Add query parameters\n  if (queryParams && Object.keys(queryParams).length > 0) {\n    const queryString = buildQueryString(queryParams, options);\n    const separator = url.includes('?') ? '&' : '?';\n    url += `${separator}${queryString}`;\n  }\n\n  return url;\n}\n\n/**\n * Sanitize parameters by removing undefined/null values and converting to strings\n * @param params Raw parameter object\n * @returns Sanitized parameter object\n */\nexport function sanitizeParams(params: Record<string, any>): Record<string, string> {\n  const sanitized: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== null && value !== undefined && value !== '') {\n      // Convert BigInt to string\n      if (typeof value === 'bigint') {\n        sanitized[key] = value.toString();\n      } else if (Array.isArray(value)) {\n        sanitized[key] = value.map(v => (typeof v === 'bigint' ? v.toString() : String(v))).join(',');\n      } else {\n        sanitized[key] = String(value);\n      }\n    }\n  }\n\n  return sanitized;\n}\n\n/**\n * Validate URL format\n * @param url URL to validate\n * @returns True if URL is valid\n */\nexport function isValidUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extract domain from URL\n * @param url URL to extract domain from\n * @returns Domain string or null if invalid\n */\nexport function extractDomain(url: string): string | null {\n  try {\n    return new URL(url).hostname;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build pagination metadata\n * @param page Current page number\n * @param pageSize Items per page\n * @param totalItems Total number of items\n * @returns Pagination metadata object\n */\nexport function buildPaginationMeta(page: number, pageSize: number, totalItems: number) {\n  const totalPages = Math.ceil(totalItems / pageSize);\n  const hasNext = page < totalPages;\n  const hasPrev = page > 1;\n\n  return {\n    page,\n    pageSize,\n    totalItems,\n    totalPages,\n    hasNext,\n    hasPrev,\n    nextPage: hasNext ? page + 1 : null,\n    prevPage: hasPrev ? page - 1 : null,\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/rateLimiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/retry.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async function 'retry' has too many lines (83). Maximum allowed is 50.","line":52,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":162,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Async function 'retry' has a complexity of 28. Maximum allowed is 10.","line":52,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":162,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 1000.","line":139,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":139,"endColumn":67},{"ruleId":"complexity","severity":1,"message":"Method 'shouldRetry' has a complexity of 12. Maximum allowed is 10.","line":199,"column":20,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":215,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from '../lib/logger';\nimport { timerManager } from './timerManager';\nimport {\n  HTTP_MAX_RETRIES,\n  HTTP_INITIAL_RETRY_DELAY,\n  HTTP_MAX_RETRY_DELAY,\n  HTTP_TIMEOUT,\n  Configuration,\n} from '../config';\n\n/**\n * Configuration options for retry logic\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts */\n  maxRetries?: number;\n  /** Base delay in milliseconds between retries */\n  baseDelayMs?: number;\n  /** Initial delay for exponential backoff (alias for baseDelayMs) */\n  initialDelayMs?: number;\n  /** Initial retry delay (legacy alias) */\n  initialRetryDelay?: number;\n  /** Maximum delay in milliseconds for exponential backoff */\n  maxDelayMs?: number;\n  /** Maximum retry delay (legacy alias) */\n  maxRetryDelay?: number;\n  /** Whether to use exponential backoff (true) or constant delay (false) */\n  useExponentialBackoff?: boolean;\n  /** Backoff multiplier factor for exponential backoff */\n  backoffFactor?: number;\n  /** Custom error handler function */\n  onError?: (error: Error, attempt: number) => void;\n  /** Predicate to determine if an error should trigger a retry */\n  shouldRetry?: (error: Error) => boolean;\n  /** Optional timeout for each attempt in milliseconds */\n  timeout?: number;\n  /** Service/operation name for logging */\n  serviceName?: string;\n  /** Abort signal to cancel retry operation */\n  abortSignal?: AbortSignal;\n  /** Whether to add jitter to retry delays */\n  addJitter?: boolean;\n}\n\n/**\n * Unified retry function that combines features from all retry implementations\n * @param fn The function to retry\n * @param description Description of the operation for logging\n * @param options Retry configuration options\n * @returns A Promise that resolves with the result of the function or rejects after max retries\n */\nexport async function retry<T>(fn: () => Promise<T>, description?: string, options: RetryOptions = {}): Promise<T> {\n  // Normalize options to handle legacy aliases\n  const baseDelay =\n    options.baseDelayMs ?? options.initialDelayMs ?? options.initialRetryDelay ?? HTTP_INITIAL_RETRY_DELAY;\n\n  const maxDelay = options.maxDelayMs ?? options.maxRetryDelay ?? HTTP_MAX_RETRY_DELAY;\n\n  const {\n    maxRetries = HTTP_MAX_RETRIES,\n    useExponentialBackoff = true,\n    backoffFactor = 2,\n    onError,\n    shouldRetry = () => true,\n    timeout = options.timeout,\n    serviceName = options.serviceName ?? description ?? 'Operation',\n    abortSignal,\n    addJitter = true,\n  } = options;\n\n  let lastError: Error | null = null;\n  let currentDelay = baseDelay;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    // Check if operation was aborted\n    if (abortSignal?.aborted) {\n      throw new Error(`${serviceName} aborted: ${abortSignal.reason ?? 'Operation cancelled'}`);\n    }\n\n    try {\n      // Create operation promise\n      let operationPromise = fn();\n\n      // Add timeout if specified\n      if (timeout) {\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          setTimeout(() => {\n            reject(new Error(`${serviceName} timed out after ${timeout}ms`));\n          }, timeout);\n        });\n        operationPromise = Promise.race([operationPromise, timeoutPromise]);\n      }\n\n      return await operationPromise;\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Check if we should retry this error\n      if (!shouldRetry(lastError)) {\n        logger.error(`${serviceName} error not eligible for retry: ${lastError.message}`);\n        throw lastError;\n      }\n\n      // Check if this is the last attempt or if aborted\n      if (attempt >= maxRetries || abortSignal?.aborted) {\n        break;\n      }\n\n      // Call custom error handler if provided\n      if (onError) {\n        onError(lastError, attempt);\n      } else {\n        // Default error logging\n        const isTimeout = lastError.message.includes('timed out');\n        const isRateLimit = lastError.message.includes('rate limit') || lastError.message.includes('429');\n\n        if (isTimeout) {\n          logger.warn(`${serviceName} timeout on attempt ${attempt}/${maxRetries}`);\n        } else if (isRateLimit) {\n          logger.warn(`${serviceName} rate limit hit on attempt ${attempt}/${maxRetries}`);\n        } else {\n          logger.warn(`${serviceName} failed on attempt ${attempt}/${maxRetries}: ${lastError.message}`);\n        }\n      }\n\n      // Calculate next delay\n      if (useExponentialBackoff) {\n        currentDelay = Math.min(currentDelay * Math.pow(backoffFactor, attempt - 1), maxDelay);\n      }\n\n      // Add jitter if enabled\n      let finalDelay = currentDelay;\n      if (addJitter) {\n        const jitter = Math.random() * Configuration.jitter.maxMs;\n        finalDelay = currentDelay + jitter;\n      }\n\n      logger.info(\n        `Retrying ${serviceName} in ${Math.round(finalDelay / 1000)}s (attempt ${attempt + 1}/${maxRetries})`\n      );\n\n      // Wait before retrying with abort support\n      try {\n        if (abortSignal) {\n          await timerManager.delay(finalDelay, abortSignal);\n        } else {\n          await new Promise(resolve => setTimeout(resolve, finalDelay));\n        }\n      } catch (error) {\n        throw new Error(\n          `${serviceName} aborted during retry delay: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n  }\n\n  if (abortSignal?.aborted) {\n    throw new Error(`${serviceName} aborted: ${abortSignal.reason || 'Operation cancelled'}`);\n  }\n\n  throw new Error(`${serviceName} failed after ${maxRetries} attempts: ${lastError?.message}`);\n}\n\n/**\n * Legacy function name for backward compatibility\n * @deprecated Use retry() instead\n */\nexport async function retryOperation<T>(\n  operation: () => Promise<T>,\n  description: string,\n  options: RetryOptions = {}\n): Promise<T> {\n  return retry(operation, description, options);\n}\n\n/**\n * Legacy function name for backward compatibility\n * @deprecated Use retry() instead\n */\nexport async function retryWithBackoff<T>(operation: () => Promise<T>, options: RetryOptions = {}): Promise<T> {\n  return retry(operation, options.serviceName, options);\n}\n\n/**\n * Convenience wrapper for common retry patterns\n */\nexport const retryStrategies = {\n  /**\n   * HTTP request retry with exponential backoff\n   * Retries on network errors and 5xx responses\n   */\n  http: <T>(fn: () => Promise<T>, maxRetries = HTTP_MAX_RETRIES): Promise<T> =>\n    retry(fn, 'HTTP request', {\n      maxRetries,\n      baseDelayMs: HTTP_INITIAL_RETRY_DELAY,\n      maxDelayMs: HTTP_MAX_RETRY_DELAY,\n      useExponentialBackoff: true,\n      timeout: HTTP_TIMEOUT,\n      shouldRetry: error => {\n        // Retry on network errors or server errors (5xx)\n        const isNetworkError =\n          error.message.includes('ECONNREFUSED') ||\n          error.message.includes('ETIMEDOUT') ||\n          error.message.includes('ENOTFOUND') ||\n          error.message.includes('ECONNRESET') ||\n          error.message.includes('ECONNABORTED');\n        const isServerError =\n          error.message.includes('500') ||\n          error.message.includes('502') ||\n          error.message.includes('503') ||\n          error.message.includes('504');\n        const isTimeout = error.message.includes('timed out');\n        const isRateLimit = error.message.includes('429') || error.message.includes('rate limit');\n        return isNetworkError || isServerError || isTimeout || isRateLimit;\n      },\n    }),\n\n  /**\n   * Database operation retry with constant backoff\n   * Good for transient database connection issues\n   */\n  database: <T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> =>\n    retry(fn, 'Database operation', {\n      maxRetries,\n      baseDelayMs: 500,\n      useExponentialBackoff: false,\n      shouldRetry: error => {\n        // Retry on connection errors or deadlocks\n        return (\n          error.message.includes('connection') ||\n          error.message.includes('deadlock') ||\n          error.message.includes('too many connections') ||\n          error.message.includes('ECONNREFUSED')\n        );\n      },\n    }),\n};\n\n/**\n * Rate limit helper for API clients\n */\nexport class RateLimiter {\n  private lastRequestTime: number = 0;\n\n  constructor(private readonly minDelayMs: number) {}\n\n  /**\n   * Wait if necessary to respect rate limits\n   */\n  async wait(signal?: AbortSignal): Promise<void> {\n    const now = Date.now();\n    const elapsed = now - this.lastRequestTime;\n    if (elapsed < this.minDelayMs) {\n      const delay = this.minDelayMs - elapsed;\n      if (signal) {\n        await timerManager.delay(delay, signal);\n      } else {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n    this.lastRequestTime = Date.now();\n  }\n}\n\n/**\n * Circuit breaker pattern implementation\n */\nexport class CircuitBreaker {\n  private failureCount = 0;\n  private nextAttemptTime = 0;\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n\n  constructor(\n    private readonly maxFailuresBeforeOpen: number = 3,\n    private readonly cooldownPeriodMs: number = 30000, // 30 seconds\n    private readonly serviceName: string = 'Unknown Service'\n  ) {}\n\n  /**\n   * Execute an operation through the circuit breaker\n   */\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() < this.nextAttemptTime) {\n        throw new Error(\n          `Circuit breaker OPEN for ${\n            this.serviceName\n          }: cooling down until ${new Date(this.nextAttemptTime).toISOString()}`\n        );\n      } else {\n        // Transition to HALF_OPEN to test if service is back\n        this.state = 'HALF_OPEN';\n        logger.info(`Circuit breaker for ${this.serviceName} transitioning to HALF_OPEN for test`);\n      }\n    }\n\n    try {\n      const result = await operation();\n\n      // Success - reset failure count and close circuit if needed\n      if (this.state === 'HALF_OPEN') {\n        logger.info(`Circuit breaker for ${this.serviceName} test successful, transitioning to CLOSED`);\n        this.state = 'CLOSED';\n      }\n\n      this.failureCount = 0;\n      return result;\n    } catch (error) {\n      this.failureCount++;\n\n      logger.warn(\n        `Circuit breaker for ${this.serviceName} recorded failure ${this.failureCount}/${this.maxFailuresBeforeOpen}`,\n        {\n          error: error instanceof Error ? error.message : String(error),\n          currentState: this.state,\n        }\n      );\n\n      if (this.failureCount >= this.maxFailuresBeforeOpen || this.state === 'HALF_OPEN') {\n        // Open the circuit\n        this.state = 'OPEN';\n        this.nextAttemptTime = Date.now() + this.cooldownPeriodMs;\n\n        logger.error(\n          `Circuit breaker for ${this.serviceName} OPENED due to ${\n            this.failureCount\n          } failures. Will attempt retry at ${new Date(this.nextAttemptTime).toISOString()}`\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get current circuit breaker state\n   */\n  getState(): { state: string; failureCount: number; nextAttemptTime: number } {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      nextAttemptTime: this.nextAttemptTime,\n    };\n  }\n\n  /**\n   * Manually reset the circuit breaker\n   */\n  reset(): void {\n    this.state = 'CLOSED';\n    this.failureCount = 0;\n    this.nextAttemptTime = 0;\n    logger.info(`Circuit breaker for ${this.serviceName} manually reset`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/template.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/timerManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/workspace/bot/src/utils/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-process-exit","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
